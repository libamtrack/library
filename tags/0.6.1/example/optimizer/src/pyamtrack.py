#! /usr/bin/env python
'''
    pyamtrack.py
    =========
   Author: herrmann

   Python interface for the libamtrack functions defined in NAMESPACE file
   this script is generated by generate_Py_wrapper.py

   Requirements: Python2.6

   Copyright 2006, 2011 Steffen Greilich / the libamtrack team

   This file is part of the AmTrack program (libamtrack.sourceforge.net).

   AmTrack is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   AmTrack is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with AmTrack (file: copying.txt).
   If not, see <http://www.gnu.org/licenses/>
'''


import ctypes
import string
import os
import sys
from platform import python_version
from platform import system as os_system

__status__ = 'Prototype'

operating_system = os_system()
if operating_system == 'Windows':
	libamtrack = ctypes.cdll.libamtrack
else:
	os.environ['LD_LIBRARY_PATH']='libamtrack.so'
	libamtrack = ctypes.cdll.LoadLibrary("./libamtrack.so")

py_version = python_version()
if int(py_version[0]) < 3 and int(py_version[2]) <= 5:
	print 'ERROR:\nYou are using Python%s\nPython2.6 or later needed!\n'%py_version
	sys.exit(1)



def AT_Stopping_Power_Mass_Bethe_MeV_cm2_g_int ( E_MeV_u, params):
	'''
	 * Integrand function for CSDA computation:
	 * inverse stopping power as function of energy (all other dependencies [particle, material] in params structre)
	 * @param[in] E_MeV_u
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Stopping_Power_Mass_Bethe_MeV_cm2_g_int
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_params)
	return c_output


def AT_CSDA_range_g_cm_int ( E_MeV_u, params):
	'''
	 * Integrand function for CSDA computation:
	 * inverse stopping power as function of energy (all other dependencies [particle, material] in params structre)
	 * @param[in] E_MeV_u
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_CSDA_range_g_cm_int
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_params)
	return c_output


def AT_CSDA_range_Bethe_g_cm2_multi ( n, E_initial_MeV_u, E_final_MeV_u, particle_no, material_no, CSDA_range_cm2_g):
	'''
	 * Computes the CSDA range using the Bethe formula (AT_Stopping_Power_Bethe_Number)
	 * according to ICRU49, p.6, Eq. 2.1
	 * BUT WITHOUT shell or density, Bloch or Barkas correction!
	 * @param[in]  	   n                    number of particles
	 * @param[in]  	   E_initial_MeV_u      initial energy of particle per nucleon (array of size n)
	 * @param[in]  	   E_final_MeV_u        final energy of particle per nucleon (array of size n)
	 * @param[in]  	   particle_no  particle index (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[out]    CSDA_range_cm2_g resulting range (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_n = ctypes.c_long(n)
	tmp_array = (ctypes.c_double*n)()
	c_CSDA_range_cm2_g= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	tmp_array =ctypes.c_double* len(E_initial_MeV_u)
	c_E_initial_MeV_u = ctypes.byref(tmp_array(*E_initial_MeV_u))

	tmp_array =ctypes.c_double* len(E_final_MeV_u)
	c_E_final_MeV_u = ctypes.byref(tmp_array(*E_final_MeV_u))

	c_function =  libamtrack.AT_CSDA_range_Bethe_g_cm2_multi
	c_output = c_function( c_n, c_E_initial_MeV_u, c_E_final_MeV_u, c_particle_no, c_material_no, c_CSDA_range_cm2_g)
	return c_output,  c_CSDA_range_cm2_g._obj


def AT_CSDA_range_Bethe_g_cm2_single ( E_initial_MeV_u, E_final_MeV_u, particle_no, material_no):
	'''
	 * Computes the CSDA range using the Bethe formula (AT_Stopping_Power_Bethe_Number)
	 * according to ICRU49, p.6, Eq. 2.1
	 * BUT WITHOUT shell or density, Bloch or Barkas correction!
	 * @param[in]  	   E_initial_MeV_u      initial energy of particle per nucleon
	 * @param[in]  	   E_final_MeV_u       final energy of particle per nucleon
	 * @param[in]  	   particle_no  particle index
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @return     result
	'''
	c_material_no = ctypes.c_long(material_no)
	c_E_initial_MeV_u = ctypes.c_double(E_initial_MeV_u)
	c_E_final_MeV_u = ctypes.c_double(E_final_MeV_u)
	c_particle_no = ctypes.c_long(particle_no)
	c_function =  libamtrack.AT_CSDA_range_Bethe_g_cm2_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_initial_MeV_u, c_E_final_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_CSDA_range_difference_solver ( E_final_MeV_u, params):
	'''
	 * Solver function for CSDA energy after slab
	 * @param[in] E_final_MeV_u
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_E_final_MeV_u = ctypes.c_double(E_final_MeV_u)
	c_function =  libamtrack.AT_CSDA_range_difference_solver
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_final_MeV_u, c_params)
	return c_output


def AT_CSDA_energy_after_slab_E_MeV_u_single ( E_initial_MeV_u, particle_no, material_no, slab_thickness_m):
	'''
	 * Computes the ion energy after transversing a slab of material using Bethe stopping power
	 * and CSDA approach
	 * @param[in]  	   E_initial_MeV_u      initial energy of particle per nucleon (array of size n)
	 * @param[in]  	   particle_no          particle index (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no          material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]      slab_thickness_m     thickness of slab to transversed
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_initial_MeV_u)
	c_E_initial_MeV_u = ctypes.byref(tmp_array(*E_initial_MeV_u))

	c_slab_thickness_m = ctypes.c_double(slab_thickness_m)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_function =  libamtrack.AT_CSDA_energy_after_slab_E_MeV_u_single
	c_output = c_function( c_E_initial_MeV_u, c_particle_no, c_material_no, c_slab_thickness_m)
	return c_output


def AT_CSDA_energy_after_slab_E_MeV_u_multi ( n, E_initial_MeV_u, particle_no, material_no, slab_thickness_m, E_final_MeV_u):
	'''
	 * Computes the ion energy after transversing a slab of material using Bethe stopping power
	 * and CSDA approach for many energies / particles
	 *
	 * @param[in]  	   n                    number of particles
	 * @param[in]  	   E_initial_MeV_u      initial energy of particle per nucleon (array of size n)
	 * @param[in]  	   particle_no          particle index (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no          material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]      slab_thickness_m     thickness of slab to transversed
	 * @param[out]     E_final_MeV_u        final energy after slab (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_n = ctypes.c_long(n)
	c_slab_thickness_m = ctypes.c_double(slab_thickness_m)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	tmp_array =ctypes.c_double* len(E_initial_MeV_u)
	c_E_initial_MeV_u = ctypes.byref(tmp_array(*E_initial_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_E_final_MeV_u= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_CSDA_energy_after_slab_E_MeV_u_multi
	c_output = c_function( c_n, c_E_initial_MeV_u, c_particle_no, c_material_no, c_slab_thickness_m, c_E_final_MeV_u)
	return c_output,  c_E_final_MeV_u._obj


def AT_WEPL_Bethe_multi ( n, E_MeV_u, particle_no, material_no, slab_thickness_m, WEPL):
	'''
	 * Computes the water equivalent path length (WEPL) using the Bethe formula
	 * @param[in]  	   n            number of particles
	 * @param[in]  	   E_MeV_u      energy of particle per nucleon (array of size n)
	 * @param[in]  	   particle_no  particle index (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]      slab_thickness_m  thickness of slab of material different than water, in meter
	 * @param[out]    WEPL resulting water equivalent path length (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_slab_thickness_m = ctypes.c_double(slab_thickness_m)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	tmp_array = (ctypes.c_double*n)()
	c_WEPL= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_WEPL_Bethe_multi
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_slab_thickness_m, c_WEPL)
	return c_output,  c_WEPL._obj


def AT_GSM_sample_particle_positions ( number_of_field_components, fluence_cm2, sample_grid_size_m, random_number_generator_seed, number_of_particles_in_field_component, x_position, y_position):
	'''
	 * Computes how many particles will be in grid area (using Poissonian distribution
	 * and fluence) and distribute particles randomly on grid.
	 * Particles positions will be saved in x_position and y_position tables.
	 * @param[in]   number_of_field_components               number of particle types in the mixed particle field
	 * @param[in]   fluence_cm2                              fluences for the given particles (array of size number_of_field_components)
	 * @param[in]   sample_grid_size_m                       linear size of grid (length of grid square side)
	 * @param[in]   random_number_generator_seed             GSL random number generator seed
	 * @param[out]  number_of_particles_in_field_component   table of number of particles of each type in the mixed particle field
	 * @param[out]  x_position                               two-dimensional table (1st dimension - component of mixed field,
	 *                                                         2nd dimension - particle index for given component)
	 *                                                         of X-positions of particles of each type in the mixed particle field
	 * @param[out]  y_position                               two-dimensional table (1st dimension - component of mixed field,
	 *                                                         2nd dimension - particle index for given component)
	 *                                                         of Y-positions of particles of each type in the mixed particle field
	'''
	tmp_array = (ctypes.c_long*1)()
	c_number_of_particles_in_field_component= ctypes.byref(tmp_array)

	c_sample_grid_size_m = ctypes.c_double(sample_grid_size_m)
	tmp_array = (ctypes.c_double*1)()
	c_y_position= ctypes.byref(tmp_array)

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array = (ctypes.c_double*1)()
	c_x_position= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_random_number_generator_seed = ctypes.c_long(random_number_generator_seed)
	c_function =  libamtrack.AT_GSM_sample_particle_positions
	c_output = c_function( c_number_of_field_components, c_fluence_cm2, c_sample_grid_size_m, c_random_number_generator_seed, c_number_of_particles_in_field_component, c_x_position, c_y_position)
	return c_output,  c_number_of_particles_in_field_component._obj, c_x_position._obj, c_y_position._obj

# problem with function AT_GSM_dose_grid_from_particles_positions
# problem with function AT_GSM_local_dose_distrib_from_dose_grid
# problem with function AT_GSM_response_grid_from_dose_grid

def AT_run_GSM_method ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, stopping_power_source_no, rdd_model, rdd_parameters, er_model, gamma_model, gamma_parameters, N_runs, write_output, nX, voxel_size_m, lethal_events_mode, relative_efficiency, d_check, S_HCP, S_gamma, n_particles, sd_relative_efficiency, sd_d_check, sd_S_HCP, sd_S_gamma, sd_n_particles):
	'''
	 * Computes HCP response and relative efficiency/RBE using summation of tracks
	 * an a Cartesian grid (the \'GSM\' algorithm).
	 *
	 * Be aware that this routine can take considerable time to compute depending on
	 * the arguments, esp. for higher energy (>10 MeV/u) particles. It is therefore
	 * advantageous to test your settings with a low number of runs first.
	 *
	 * @param[in]      number_of_field_components     number of components in the mixed particle field
	 * @param[in]      E_MeV_u                        particle energy for each component in the mixed particle field [MeV/u] (array of size number_of_field_components)
	 * @param[in]      particle_no                    particle type for each component in the mixed particle field (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]      fluence_cm2_or_dose_Gy         if positive, particle fluence for each component in the mixed particle field [1/cm2]; if negative, particle dose for each component in the mixed particle field [Gy] (array of size number_of_field_components)
	 * @param[in]      material_no                    index number for detector material
	 * @param[in]      stopping_power_source_no       TODO
	 * @see AT_DataMaterial.h for definition
	 * @param[in]      rdd_model                      index number for chosen radial dose distribution
	 * @param[in]      rdd_parameters                 parameters for chosen radial dose distribution (array of size 4)
	 * @see AT_RDD.h for definition
	 * @param[in]      er_model                       index number for chosen electron-range model
	 * @see AT_ElectronRange.h for definition
	 * @param[in]      gamma_model                    index number for chosen gamma response
	 * @param[in]      gamma_parameters               parameters for chosen gamma response (array of size 9)
	 * @see AT_GammaResponse.h for definition
	 * @param[in]      N_runs                         number of runs within which track positions will be resampled
	 * @param[in]      write_output                   if true, a protocol is written to "SuccessiveConvolutions.txt" in the working directory
	 * @param[in]      nX                             number of voxels of the grid in x (and y as the grid is quadratic)
	 * @param[in]      voxel_size_m                   side length of a voxel in m
	 * @param[in]      lethal_events_mode             if true, allows to do calculations for cell survival
	 * @param[out]     relative_efficiency            particle response at dose D / gamma response at dose D
	 * @param[out]     d_check                        sanity check:  total dose (in Gy) as returned by the algorithm
	 * @param[out]     S_HCP                          absolute particle response
	 * @param[out]     S_gamma                        absolute gamma response
	 * @param[out]     n_particles                    average number of particle tracks on the detector grid
	 * @param[out]     sd_relative_efficiency         standard deviation for relative_efficiency
	 * @param[out]     sd_d_check                     standard deviation for d_check
	 * @param[out]     sd_S_HCP                       standard deviation for S_HCP
	 * @param[out]     sd_S_gamma                     standard deviation for S_gamma
	 * @param[out]     sd_n_particles                 standard deviation for n_particles
	'''
	c_voxel_size_m = ctypes.c_double(voxel_size_m)
	c_sd_S_HCP =  ctypes.byref(ctypes.c_double(sd_S_HCP))

	c_er_model = ctypes.c_long(er_model)
	c_nX = ctypes.c_long(nX)
	c_S_HCP =  ctypes.byref(ctypes.c_double(S_HCP))

	c_sd_n_particles =  ctypes.byref(ctypes.c_double(sd_n_particles))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_lethal_events_mode = ctypes.c_bool(lethal_events_mode)
	c_N_runs = ctypes.c_long(N_runs)
	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_n_particles =  ctypes.byref(ctypes.c_double(n_particles))

	c_sd_d_check =  ctypes.byref(ctypes.c_double(sd_d_check))

	c_gamma_model = ctypes.c_long(gamma_model)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_S_gamma =  ctypes.byref(ctypes.c_double(S_gamma))

	c_sd_S_gamma =  ctypes.byref(ctypes.c_double(sd_S_gamma))

	c_relative_efficiency =  ctypes.byref(ctypes.c_double(relative_efficiency))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	c_write_output = ctypes.c_bool(write_output)
	c_d_check =  ctypes.byref(ctypes.c_double(d_check))

	c_sd_relative_efficiency =  ctypes.byref(ctypes.c_double(sd_relative_efficiency))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_run_GSM_method
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_stopping_power_source_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_model, c_gamma_parameters, c_N_runs, c_write_output, c_nX, c_voxel_size_m, c_lethal_events_mode, c_relative_efficiency, c_d_check, c_S_HCP, c_S_gamma, c_n_particles, c_sd_relative_efficiency, c_sd_d_check, c_sd_S_HCP, c_sd_S_gamma, c_sd_n_particles)
	return c_output,  c_relative_efficiency._obj.value, c_d_check._obj.value, c_S_HCP._obj.value, c_S_gamma._obj.value, c_n_particles._obj.value, c_sd_relative_efficiency._obj.value, c_sd_d_check._obj.value, c_sd_S_HCP._obj.value, c_sd_S_gamma._obj.value, c_sd_n_particles._obj.value


def AT_GSM_local_dose_distrib ( number_of_field_components, E_MeV_u, fluence_cm2, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no, nX, pixel_size_m, number_of_bins, dose_bin_centers_Gy, random_number_generator_seed, zero_dose_fraction, dose_frequency_Gy):
	'''
	 * Computes local dose histogram for given mixed field
	 *
	 * @param[in]  number_of_field_components                number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u                                   energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  fluence_cm2                               fluences for the given particles (array of size number_of_field_components)
	 * @param[in]  particle_no                               type of the particles in the mixed particle field (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  material_no                               index number for detector material
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  rdd_model                                 index number for chosen radial dose distribution
	 * @param[in]  rdd_parameter                             parameters for chosen radial dose distribution (array of size depending on chosen model)
	 * @see          AT_RDD.h for definition
	 * @param[in]  er_model                                  index number for chosen electron-range model
	 * @see          AT_ElectronRange.h for definition
	 * @param[in] stopping_power_source_no                   TODO
	 * @param[in] nX                                         TODO
	 * @param[in] pixel_size_m                               TODO
	 * @param[in] number_of_bins                             TODO
	 * @param[in] dose_bin_centers_Gy                        TODO
	 * @param[out] random_number_generator_seed              TODO
	 * @param[out] zero_dose_fraction                        TODO
	 * @param[out] dose_frequency_Gy                         TODO
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_random_number_generator_seed =  ctypes.byref(ctypes.c_long(random_number_generator_seed))

	c_pixel_size_m = ctypes.c_double(pixel_size_m)
	c_zero_dose_fraction =  ctypes.byref(ctypes.c_double(zero_dose_fraction))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_nX = ctypes.c_long(nX)
	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array = (ctypes.c_double*1)()
	c_dose_frequency_Gy= ctypes.byref(tmp_array)

	c_er_model = ctypes.c_long(er_model)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	tmp_array =ctypes.c_double* len(dose_bin_centers_Gy)
	c_dose_bin_centers_Gy = ctypes.byref(tmp_array(*dose_bin_centers_Gy))

	c_function =  libamtrack.AT_GSM_local_dose_distrib
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_fluence_cm2, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no, c_nX, c_pixel_size_m, c_number_of_bins, c_dose_bin_centers_Gy, c_random_number_generator_seed, c_zero_dose_fraction, c_dose_frequency_Gy)
	return c_output,  c_random_number_generator_seed._obj.value, c_zero_dose_fraction._obj.value, c_dose_frequency_Gy._obj


def AT_GSM_multiple_local_dose_distrib ( number_of_field_components, E_MeV_u, fluence_cm2, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no, nX, pixel_size_m, N_runs, N_repetitions, number_of_bins, dose_bin_centers_Gy, dose_bin_width_Gy, mean_d_check_Gy, sd_d_check_Gy, mean_zero_dose_fraction, sd_zero_dose_fraction, mean_dose_frequency_Gy, sd_dose_frequency_Gy):
	'''
	 * TODO
	 * @param[in] number_of_field_components
	 * @param[in] E_MeV_u (array of size number_of_field_components)
	 * @param[in] fluence_cm2 (array of size number_of_field_components)
	 * @param[in] particle_no (array of size number_of_field_components)
	 * @param[in] material_no
	 * @param[in] rdd_model
	 * @param[in] rdd_parameter (array of size 4)
	 * @param[in] er_model
	 * @param[in] stopping_power_source_no
	 * @param[in] nX
	 * @param[in] pixel_size_m
	 * @param[in] N_runs
	 * @param[in] N_repetitions
	 * @param[in] number_of_bins
	 * @param[in] dose_bin_centers_Gy (array of size number_of_bins)
	 * @param[out] dose_bin_width_Gy (array of size number_of_bins)
	 * @param[out] mean_d_check_Gy
	 * @param[out] sd_d_check_Gy
	 * @param[out] mean_zero_dose_fraction
	 * @param[out] sd_zero_dose_fraction
	 * @param[out] mean_dose_frequency_Gy (array of size number_of_bins)
	 * @param[out] sd_dose_frequency_Gy (array of size number_of_bins)
	'''
	c_er_model = ctypes.c_long(er_model)
	c_nX = ctypes.c_long(nX)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_N_runs = ctypes.c_long(N_runs)
	tmp_array =ctypes.c_double* len(dose_bin_centers_Gy)
	c_dose_bin_centers_Gy = ctypes.byref(tmp_array(*dose_bin_centers_Gy))

	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_sd_d_check_Gy =  ctypes.byref(ctypes.c_double(sd_d_check_Gy))

	c_N_repetitions = ctypes.c_long(N_repetitions)
	tmp_array = (ctypes.c_double*number_of_bins)()
	c_sd_dose_frequency_Gy= ctypes.byref(tmp_array)

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array = (ctypes.c_double*number_of_bins)()
	c_dose_bin_width_Gy= ctypes.byref(tmp_array)

	c_pixel_size_m = ctypes.c_double(pixel_size_m)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	c_sd_zero_dose_fraction =  ctypes.byref(ctypes.c_double(sd_zero_dose_fraction))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_mean_d_check_Gy =  ctypes.byref(ctypes.c_double(mean_d_check_Gy))

	tmp_array = (ctypes.c_double*number_of_bins)()
	c_mean_dose_frequency_Gy= ctypes.byref(tmp_array)

	c_mean_zero_dose_fraction =  ctypes.byref(ctypes.c_double(mean_zero_dose_fraction))

	c_function =  libamtrack.AT_GSM_multiple_local_dose_distrib
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_fluence_cm2, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no, c_nX, c_pixel_size_m, c_N_runs, c_N_repetitions, c_number_of_bins, c_dose_bin_centers_Gy, c_dose_bin_width_Gy, c_mean_d_check_Gy, c_sd_d_check_Gy, c_mean_zero_dose_fraction, c_sd_zero_dose_fraction, c_mean_dose_frequency_Gy, c_sd_dose_frequency_Gy)
	return c_output,  c_dose_bin_width_Gy._obj, c_mean_d_check_Gy._obj.value, c_sd_d_check_Gy._obj.value, c_mean_zero_dose_fraction._obj.value, c_sd_zero_dose_fraction._obj.value, c_mean_dose_frequency_Gy._obj, c_sd_dose_frequency_Gy._obj


def AT_RDD_Katz_LinearER_Daverage_Gy ( r1_m, r2_m, max_electron_range_m, Katz_point_coeff_Gy):
	'''
	 * Calculates average dose for "old" Katz RDD (derived from linear (on wmax) ER model).
	 * Here averaging is done over a shell between radius r_1 and r_2
	 *
	 * @f[ Dav(r1,r2) = 1/(\pi r_2^2 - \pi r_1^2) * \int_{r_1}^{r_2} D(r) 2 \pi r dr @f]
	 *
	 * thus:
	 *
	 * @f[ Dav(r1,r2) = coeff / (\pi r_2^2 - \pi r_1^2)  *  \int_{r_1}^{r_2} rmax/r * (rmax/r - 1.) 2 \pi r dr @f]
	 * @f[ Dav(r1,r2) = 2 * coeff * rmax^2/ (r_2^2 - r_1^2)  *  \int_{r_1}^{r_2} (1/r - 1/rmax) dr @f]
	 * @f[ Dav(r1,r2) = 2 * coeff / ((r_2/rmax)^2 - (r_1/rmax)^2) * \int_{r_1}^{r_2} (1/r - 1/rmax) dr @f]
	 *
	 * Let us calculate integral:
	 *
	 * @f[ \int_{r_1}^{r_2} (1/r - 1/rmax) dr = log(r) - r/rmax |_{r_1}^{r_2} = log(r_2/r_1) - (r_2 - r_1)/rmax @f]
	 *
	 * in other words:
	 *
	 * @f[ Dav(r_1,r_2) = 2 * coeff * ( log(r_2/r_1) - (r_2 - r_1)/rmax ) / ((r_2/rmax)^2 - (r_1/rmax)^2) @f]
	 *
	 * @param[in] r1_m                     inner radius r1 (lower integration limit) [m]
	 * @param[in] r2_m                     outer radius r2 (upper integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return D(r) [Gy] average radial dose distribution between r1 and r2
	'''
	c_r2_m = ctypes.c_double(r2_m)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r1_m = ctypes.c_double(r1_m)
	c_function =  libamtrack.AT_RDD_Katz_LinearER_Daverage_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r1_m, c_r2_m, c_max_electron_range_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Katz_PowerLawER_DaverageKernel ( x1, x2, alpha):
	'''
	 * Calculates average dose kernel for "new" Katz RDD (derived from power-law (on wmax) ER model).
	 * Here averaging is done over a shell between radius @f$r_1@f$ and @f$r_2@f$
	 *
	 * @f[kernel = 2/(x_2^2 - x_1^2) * \int_{x_1}^{x_2} 1/x^2 * 1/\alpha * (1 - x)^{1/\alpha} x dx = @f]
	 * @f[       = 2/(x_2^2 - x_1^2) * \int_{x_1}^{x_2} 1/x * 1/\alpha * (1 - x)^{1/\alpha} dx @f]
	 *
	 * now we use the information that:
	 *
	 * @f[ \int 1/x * 1/\alpha * (1 - x)^{1/\alpha} dx = (1-x)^{1/\alpha} ((x-1)/x)^{-1/\alpha} _2F_1(-1/\alpha,-1/\alpha;(\alpha-1)/\alpha;1/x)+constant @f]
	 *
	 * thus:
	 *
	 * @f[ kernel =  2/(x_2^2 - x_1^2) * (F2 - F1) @f]
	 *
	 * where:
	 *
	 * @f[ F1 = (1-x_1)^{1/\alpha} ((x_1-1)/x_1)^{-1/\alpha} _2F_1(-1/\alpha,-1/\alpha;(\alpha-1)/\alpha;1/x_1) @f]
	 * @f[ F2 = (1-x_2)^{1/\alpha} ((x_2-1)/x_2)^{-1/\alpha} _2F_1(-1/\alpha,-1/\alpha;(\alpha-1)/\alpha;1/x_2) @f]
	 *
	 * here @f$_2F_1@f$ is the special hypergeometric function
	 *
	 * @param[in] x1                     inner radius x1 (lower integration limit)
	 * @param[in] x2                     outer radius x2 (upper integration limit)
	 * @param[in] alpha                  parameter of ER model
	 * @return                           calculated kernel
	'''
	c_x2 = ctypes.c_double(x2)
	c_alpha = ctypes.c_double(alpha)
	c_x1 = ctypes.c_double(x1)
	c_function =  libamtrack.AT_RDD_Katz_PowerLawER_DaverageKernel
	c_function.restype = ctypes.c_double
	c_output = c_function( c_x1, c_x2, c_alpha)
	return c_output


def AT_RDD_Katz_PowerLawER_DaverageKernel_approx ( x1, x2, alpha):
	'''
	 * Calculates approximate value of average dose kernel for "new" Katz RDD (derived from power-law (on wmax) ER model).
	 * Here averaging is done over a shell between radius r_1 and r_2
	 *
	 * @f[ kernel = 2/(x_2^2 - x_1^2) * \int_{x_1}^{x_2} 1/x^2 * 1/\alpha * (1 - x)^(1/\alpha) x dx = @f]
	 * @f[        = 2/(x_2^2 - x_1^2) * \int_{x_1}^{x_2} 1/x * 1/\alpha * (1 - x)^(1/\alpha) dx @f]
	 *
	 * now we use the series expansion:
	 *
	 * @f[ 1/x * 1/\alpha * (1 - x)^(1/\alpha) = 1 / (x \alpha) - 1 / \alpha^2  + (1/\alpha  - 1) x / (2 \alpha^2) + O(x^2) @f]
	 *
	 * to calculate the integral:
	 *
	 * @f[ \int 1/x * 1/\alpha * (1 - x)^(1/\alpha) dx \approx x / \alpha^2 ( (x / 4\alpha) * (1/\alpha - 1) - 1 ) + log(x) + C @f]
	 *
	 * thus:
	 *
	 * @f[ kernel =  2/(x_2^2 - x_1^2) * (F2 - F1) @f]
	 *
	 * where:
	 *
	 * @f[ F1 = x_1 / \alpha^2 ( (x_1 / 4\alpha) * (1/\alpha - 1) - 1 ) + log(x_1) @f]
	 * @f[ F2 = x_2 / \alpha^2 ( (x_2 / 4\alpha) * (1/\alpha - 1) - 1 ) + log(x_2) @f]
	 *
	 * @param[in] x1                     inner radius x1 (lower integration limit)
	 * @param[in] x2                     outer radius x2 (upper integration limit)
	 * @param[in] alpha                  parameter of ER model
	 * @return kernel                    calculated kernel
	'''
	c_x2 = ctypes.c_double(x2)
	c_alpha = ctypes.c_double(alpha)
	c_x1 = ctypes.c_double(x1)
	c_function =  libamtrack.AT_RDD_Katz_PowerLawER_DaverageKernel_approx
	c_function.restype = ctypes.c_double
	c_output = c_function( c_x1, c_x2, c_alpha)
	return c_output


def AT_RDD_Katz_PowerLawER_Daverage_Gy ( r1_m, r2_m, max_electron_range_m, alpha, Katz_point_coeff_Gy):
	'''
	 * Calculates average dose for "new" Katz RDD (derived from power-law (on wmax) ER model).
	 * Here averaging is done over a shell between radius r_1 and r_2
	 *
	 * @f[ Dav(r1,r2) = 1/ (\pi r2^2 - \pi r1^2) * \int_{r_1}^{r_2} D(r) 2 \pi r dr @f]
	 *
	 * thus:
	 *
	 * @f[ D(r) = coeff * kernel(r) @f]
	 *
	 * @f[ Dav(r1,r2) = coeff * 2 / (r2^2 - r1^2) * \int_{r_1}^{r_2} kernel(r) r dr @f]
	 *
	 * substituting x1 = r1/rmax , x2 = r2/rmax we will have:
	 *
	 * @f[ Dav(r1,r2) = coeff * 2 / (x2^2 - x1^2) * \int_x1^x2 kernel(x) x dx @f]
	 *
	 * in other words:
	 *
	 * @f[ Dav(r1,r2) = coeff * kernel_av( x1, x2 ) @f]
	 *
	 * @param[in] r1_m                     inner radius r1 (lower integration limit) [m]
	 * @param[in] r2_m                     outer radius r2 (upper integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return D(r) [Gy] average radial dose distribution between r1 and r2
	'''
	c_r2_m = ctypes.c_double(r2_m)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_alpha = ctypes.c_double(alpha)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r1_m = ctypes.c_double(r1_m)
	c_function =  libamtrack.AT_RDD_Katz_PowerLawER_Daverage_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r1_m, c_r2_m, c_max_electron_range_m, c_alpha, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Cucinotta_Ddelta_average_integrand_m ( r_m, params):
	'''
	 * Integrand in Cucinotta Ddelta calculation:
	 *
	 *  fS(r) * fL(r) /r;
	 * @param[in] r_m                      distance [m]
	 * @param[in] params                   vector of parameters
	 * @return integrand  fS(r) * fL(r) /r
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_RDD_Cucinotta_Ddelta_average_integrand_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_RDD_Cucinotta_Ddelta_average_Gy ( r1_m, r2_m, max_electron_range_m, beta, Katz_point_coeff_Gy):
	'''
	 * Calculates average dose for Cucinotta delta RDD.
	 * Here averaging is done over a shell between radius r_1 and r_2
	 *
	 * @f[ Dav(r1,r2) = 1/ (\pi r_2^2 - \pi r_1^2) * \int_{r_1}^{r_2} Ddelta(r) 2 \pi r dr @f]
	 *
	 * We calculate using pre-calculated constant in following manner:
	 *
	 * @f[ Ddelta(r) = coeff * fS(r) * fL(r) * rmax^2/r^2 @f]
	 *
	 * Thus
	 *
	 * @f[ Dav(r_1,r_2) = 2 * coeff/ ((r_2/rmax)^2 - (r_1/rmax)^2) * \int_{r_1}^{r_2} fS(r) * fL(r) * 1/r dr @f]
	 *
	 * where:
	 *
	 * @f[ coeff      =  (C / 2 \pi) * (Zeff/beta)^2 * 1/\rho * 1 /rmax^2 @f]
	 *
	 * @param[in] r1_m                     inner radius r1 (lower integration limit) [m]
	 * @param[in] r2_m                     outer radius r2 (upper integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return D(r) [Gy] average radial dose distribution between r1 and r2
	'''
	c_r2_m = ctypes.c_double(r2_m)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r1_m = ctypes.c_double(r1_m)
	c_function =  libamtrack.AT_RDD_Cucinotta_Ddelta_average_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r1_m, c_r2_m, c_max_electron_range_m, c_beta, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Cucinotta_Dexc_average_Gy ( r1_m, r2_m, max_electron_range_m, beta, Katz_point_coeff_Gy):
	'''
	 * Calculates average dose for Cucinotta excitation RDD with Cnorm = 1
	 * Here averaging is done over a shell between radius r_1 and r_2
	 *
	 * @f[ Dav(r_1,r_2) = 1/ (\pi r_2^2 - \pi r_1^2) * \int_{r_1}^{r_2} Dexc(r) 2 \pi r dr @f]
	 *
	 * We calculate using pre-calculated constant in following manner:
	 *
	 * @f[ Dexc(r) = Cnorm * coeff * exp( - r / 2d ) * (rmax/r)^2 @f]
	 *
	 * where:
	 *
	 * @f[ d = (beta/2) * (hbar * c / wr) @f]
	 * @f[ wr = 13eV @f]
	 * @f[ coeff      =  (C / 2 \pi) * (Zeff/beta)^2 * 1/\rho * 1 /rmax^2 @f]
	 * @f[ Cnorm      =  1 @f]
	 *
	 * Thus
	 *
	 * @f[ Dav(r_1,r_2) = 2 coeff/ ((r_2/rmax)^2 - (r_1/rmax)^2) * \int_{r_1}^{r_2} exp( - r / 2d ) * 1/r dr @f]
	 *
	 * where:
	 *
	 * @f[ coeff      =  (C / 2 \pi) * (Zeff/beta)^2 * 1/\rho * 1 /rmax^2 @f]
	 *
	 * @param[in] r1_m                     inner radius r1 (lower integration limit) [m]
	 * @param[in] r2_m                     outer radius r2 (upper integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return D(r) [Gy] average radial dose distribution between r1 and r2
	'''
	c_r2_m = ctypes.c_double(r2_m)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r1_m = ctypes.c_double(r1_m)
	c_function =  libamtrack.AT_RDD_Cucinotta_Dexc_average_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r1_m, c_r2_m, c_max_electron_range_m, c_beta, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Cucinotta_Cnorm ( r_min_m, max_electron_range_m, beta, material_density_kg_m3, LET_J_m, Katz_point_coeff_Gy):
	'''
	 * Calculates normalization constant
	 * for Cucinotta RDD
	 *
	 * We should have:
	 *
	 * @f[ LET = 2 \pi \rho \int_{rmin}^{rmax} D(r) r dr @f]
	 *
	 * Thus:
	 *
	 * @f[ LET = 2 \pi \rho \int_{rmin}^{rmax} Ddelta(r) r dr + 2 \pi \rho \int_{rmin}^{rmax} Dexc(r) r dr @f]
	 *
	 * and
	 *
	 * @f[ LET / (2 \pi \rho) = (\pi rmax^2 - \pi rmin^2) Ddelta_{average}(rmin,rmax) + (\pi rmax^2 - \pi rmin^2) * Cnorm * Dexc_{average}(rmin,rmax) @f]
	 *
	 * so
	 *
	 * @f[ LET / (2 \pi \rho * ((\pi rmax^2 - \pi rmin^2)) )  = Ddelta_{average}(rmin,rmax) + Cnorm * Dexc_{average}(rmin,rmax) @f]
	 *
	 * finally:
	 *
	 * @f[ Cnorm = (LET / (2 \pi \rho * ((\pi rmax^2 - \pi rmin^2)) ) - Ddelta_{average}(rmin,rmax) ) / Dexc_{average}(rmin,rmax) @f]
	 *
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] beta                     relative ion speed @f$\beta@f$ = v/c
	 * @param[in] material_density_kg_m3   material density @f$\rho@f$ [kg/m^3]
	 * @param[in] LET_J_m                  LET [J/m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return C norm
	'''
	c_material_density_kg_m3 = ctypes.c_double(material_density_kg_m3)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_LET_J_m = ctypes.c_double(LET_J_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_RDD_Cucinotta_Cnorm
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_min_m, c_max_electron_range_m, c_beta, c_material_density_kg_m3, c_LET_J_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Geiss_average_Gy ( r1_m, r2_m, a0_m, max_electron_range_m, norm_Gy):
	'''
	 * TODO
	 * @param[in] r1_m
	 * @param[in] r2_m
	 * @param[in] a0_m
	 * @param[in] max_electron_range_m
	 * @param[in] norm_Gy
	 * @return
	'''
	c_r2_m = ctypes.c_double(r2_m)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_norm_Gy = ctypes.c_double(norm_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_r1_m = ctypes.c_double(r1_m)
	c_function =  libamtrack.AT_RDD_Geiss_average_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r1_m, c_r2_m, c_a0_m, c_max_electron_range_m, c_norm_Gy)
	return c_output


def AT_RDD_Katz_LinearER_dEdx_J_m ( a0_m, max_electron_range_m, material_density_kg_m3, Katz_point_coeff_Gy):
	'''
	 * Calculates energy delivered to shell between radius a_0 and r_max
	 * for "old" Katz RDD (derived from linear (on wmax) ER model).
	 *
	 * @f[ dEdx = \rho \int_{a_0}^{rmax}  D(r) 2 \pi r dr = @f]
	 * @f[      = \rho * (\pi rmax^2 - \pi a_0^2) D_{av}(a_0,rmax) @f]
	 *
	 * because:
	 *
	 * @f[ Dav(r1,r2) = 1/ (\pi r_2^2 - \pi r_1^2) * \int_{r_1}^{r_2} D(r) 2 \pi r dr @f]
	 *
	 * @param[in] a0_m                     inner radius a0 (lower integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] material_density_kg_m3   material density @f$\rho@f$ [kg/m^3]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return dEdx [J/m] energy delivered to shell between radius a_0 and r_max
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_a0_m = ctypes.c_double(a0_m)
	c_material_density_kg_m3 = ctypes.c_double(material_density_kg_m3)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_function =  libamtrack.AT_RDD_Katz_LinearER_dEdx_J_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_a0_m, c_max_electron_range_m, c_material_density_kg_m3, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Katz_PowerLawER_dEdx_J_m ( a0_m, max_electron_range_m, material_density_kg_m3, alpha, Katz_point_coeff_Gy):
	'''
	 * Calculates energy delivered to shell between radius a_0 and r_max
	 * for "new" Katz RDD (derived from power-law (on wmax) ER model).
	 *
	 * @f[ dEdx = \rho \int_{a_0}^{rmax} D(r) 2 \pi r dr = @f]
	 * @f[      = \rho * (\pi rmax^2 - \pi a_0^2) D_{av}(a_0,rmax) @f]
	 *
	 * because:
	 *
	 * @f[ Dav(r1,r2) = 1/ (\pi r_2^2 - \pi r_1^2) * \int_{r_1}^{r_2} D(r) 2 \pi r dr @f]
	 *
	 * @param[in] a0_m                     inner radius a0 (lower integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] material_density_kg_m3   material density @f$\rho@f$ [kg/m^3]
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return dEdx [J/m] energy delivered to shell between radius a_0 and r_max
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_material_density_kg_m3 = ctypes.c_double(material_density_kg_m3)
	c_alpha = ctypes.c_double(alpha)
	c_function =  libamtrack.AT_RDD_Katz_PowerLawER_dEdx_J_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_a0_m, c_max_electron_range_m, c_material_density_kg_m3, c_alpha, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Katz_LinearER_DSite_Gy ( r_m, a0_m, max_electron_range_m, material_density_kg_m3, LET_J_m, dEdx_J_m, Katz_point_coeff_Gy):
	'''
	 * Calculates Site RDD, which is LET-normalized
	 * for "old" Katz RDD (derived from linear (on wmax) ER model).
	 *
	 * @f[ Dsite(r) = 1 / (\rho \pi a_0^2) * (LET - dEdx)   for r < a_0 @f]
	 * @f[ Dsite(r) = D(r)                                  for r >= a_0 @f]
	 *
	 * @param[in] r_m                      TODO
	 * @param[in] a0_m                     inner radius a0 (lower integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] material_density_kg_m3   material density @f$\rho@f$ [kg/m^3]
	 * @param[in] LET_J_m                  LET [J/m]
	 * @param[in] dEdx_J_m                 dEdx [J/m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return dEdx [J/m] energy delivered to shell between radius a_0 and r_max
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_LET_J_m = ctypes.c_double(LET_J_m)
	c_r_m = ctypes.c_double(r_m)
	c_dEdx_J_m = ctypes.c_double(dEdx_J_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_material_density_kg_m3 = ctypes.c_double(material_density_kg_m3)
	c_function =  libamtrack.AT_RDD_Katz_LinearER_DSite_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_max_electron_range_m, c_material_density_kg_m3, c_LET_J_m, c_dEdx_J_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Katz_PowerLawER_DSite_Gy ( r_m, a0_m, max_electron_range_m, material_density_kg_m3, alpha, LET_J_m, dEdx_J_m, Katz_point_coeff_Gy):
	'''
	 * Calculates Site RDD, which is LET-normalized
	 * for "new" Katz RDD (derived from power-law (on wmax) ER model).
	 *
	 * @f[ Dsite(r) = 1 / (\rho \pi a_0^2) * (LET - dEdx)   for r < a_0 @f]
	 * @f[ Dsite(r) = D(r)                                  for r >= a_0 @f]
	 *
	 * @param[in] r_m                      TODO
	 * @param[in] a0_m                     inner radius a0 (lower integration limit) [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] material_density_kg_m3   material density @f$\rho@f$ [kg/m^3]
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] LET_J_m                  LET [J/m]
	 * @param[in] dEdx_J_m                 dEdx [J/m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return dEdx [J/m] energy delivered to shell between radius a_0 and r_max
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_LET_J_m = ctypes.c_double(LET_J_m)
	c_r_m = ctypes.c_double(r_m)
	c_dEdx_J_m = ctypes.c_double(dEdx_J_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_material_density_kg_m3 = ctypes.c_double(material_density_kg_m3)
	c_function =  libamtrack.AT_RDD_Katz_PowerLawER_DSite_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_max_electron_range_m, c_material_density_kg_m3, c_alpha, c_LET_J_m, c_dEdx_J_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_KatzSite_Gy ( r_m, r_min_m, max_electron_range_m, a0_m, er_model, alpha, density_kg_m3, LET_J_m, dEdx_J_m, Katz_point_coeff_Gy):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] a0_m                     inner radius a0 (lower integration limit) [m]
	 * @param[in] er_model                 delta electron range model code number
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] density_kg_m3            material density @f$\rho@f$ [kg/m^3]
	 * @param[in] LET_J_m                  LET [J/m]
	 * @param[in] dEdx_J_m                 dEdx [J/m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return
	'''
	c_density_kg_m3 = ctypes.c_double(density_kg_m3)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_LET_J_m = ctypes.c_double(LET_J_m)
	c_r_m = ctypes.c_double(r_m)
	c_dEdx_J_m = ctypes.c_double(dEdx_J_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_RDD_KatzSite_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_r_min_m, c_max_electron_range_m, c_a0_m, c_er_model, c_alpha, c_density_kg_m3, c_LET_J_m, c_dEdx_J_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_inverse_RDD_KatzSite_m ( D_Gy, r_min_m, max_electron_range_m, a0_m, er_model, alpha, d_max_Gy, Katz_point_coeff_Gy):
	'''
	 * TODO
	 * @param[in] D_Gy
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] a0_m                     radius target [m]
	 * @param[in] er_model                 delta electron range model code number
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] d_max_Gy                 TODO
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return
	'''
	c_d_max_Gy = ctypes.c_double(d_max_Gy)
	c_D_Gy = ctypes.c_double(D_Gy)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_inverse_RDD_KatzSite_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_r_min_m, c_max_electron_range_m, c_a0_m, c_er_model, c_alpha, c_d_max_Gy, c_Katz_point_coeff_Gy)
	return c_output


def geometryFunctionPhi ( r_m, a0_m, t_m):
	'''
	 * Geometry function Phi \n
	 *
	 * Length of arc segment is given as  2 Phi(r,a0,t) r
	 *
	 * Phi(r,a0,t) = 2 arctan( sqrt( (a0^2 - (r-t)^2) / ((t + r)^2  - a0^2) ) )   for t > | r - a0 |
	 *
	 * Phi(r,a0,t) = pi                                                          for t <= | r - a0 |
	 *
	 * @param[in]        r_m      distance from the center of the ion to the center of the target [m]
	 * @param[in]        a0_m     radius of the target [m]
	 * @param[in]        t_m      distance at which segment length is calculated [m]
	 * @return   Phi(r,a0,t)
	'''
	c_a0_m = ctypes.c_double(a0_m)
	c_r_m = ctypes.c_double(r_m)
	c_t_m = ctypes.c_double(t_m)
	c_function =  libamtrack.geometryFunctionPhi
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_t_m)
	return c_output


def AT_RDD_ExtendedTarget_KatzPoint_integrand_Gy ( t_m, params):
	'''
	 * TODO
	 * @param[in] t_m
	 * @param[in] params
	 * @return
	'''
	c_params = (params)
	c_t_m = ctypes.c_double(t_m)
	c_function =  libamtrack.AT_RDD_ExtendedTarget_KatzPoint_integrand_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_t_m, c_params)
	return c_output


def AT_RDD_ExtendedTarget_KatzPoint_Gy_by_integration ( r_m, a0_m, er_model, KatzPoint_r_min_m, max_electron_range_m, alpha, Katz_point_coeff_Gy):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] a0_m
	 * @param[in] er_model
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] alpha
	 * @param[in] Katz_point_coeff_Gy
	 * @return
	'''
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_function =  libamtrack.AT_RDD_ExtendedTarget_KatzPoint_Gy_by_integration
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_er_model, c_KatzPoint_r_min_m, c_max_electron_range_m, c_alpha, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_ExtendedTarget_KatzPoint_Gy ( r_m, a0_m, er_model, KatzPoint_r_min_m, max_electron_range_m, alpha, Katz_plateau_Gy, Katz_point_coeff_Gy):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] a0_m
	 * @param[in] er_model
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] alpha
	 * @param[in] Katz_plateau_Gy
	 * @param[in] Katz_point_coeff_Gy
	 * @return
	'''
	c_Katz_plateau_Gy = ctypes.c_double(Katz_plateau_Gy)
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_function =  libamtrack.AT_RDD_ExtendedTarget_KatzPoint_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_er_model, c_KatzPoint_r_min_m, c_max_electron_range_m, c_alpha, c_Katz_plateau_Gy, c_Katz_point_coeff_Gy)
	return c_output


def AT_inverse_RDD_ExtendedTarget_KatzPoint_solver_function_Gy ( r_m, params):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] params
	 * @return
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_inverse_RDD_ExtendedTarget_KatzPoint_solver_function_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_inverse_RDD_ExtendedTarget_KatzPoint_m ( D_Gy, r_min_m, max_electron_range_m, a0_m, er_model, alpha, Katz_plateau_Gy, Katz_point_coeff_Gy):
	'''
	 * TODO
	 * @param[in] D_Gy
	 * @param[in] r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] a0_m
	 * @param[in] er_model
	 * @param[in] alpha
	 * @param[in] Katz_plateau_Gy
	 * @param[in] Katz_point_coeff_Gy
	 * @return
	'''
	c_Katz_plateau_Gy = ctypes.c_double(Katz_plateau_Gy)
	c_D_Gy = ctypes.c_double(D_Gy)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_inverse_RDD_ExtendedTarget_KatzPoint_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_r_min_m, c_max_electron_range_m, c_a0_m, c_er_model, c_alpha, c_Katz_plateau_Gy, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_ExtendedTarget_CucinottaPoint_integrand_Gy ( t_m, params):
	'''
	 * TODO
	 * @param[in] t_m
	 * @param[in] params
	 * @return
	'''
	c_params = (params)
	c_t_m = ctypes.c_double(t_m)
	c_function =  libamtrack.AT_RDD_ExtendedTarget_CucinottaPoint_integrand_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_t_m, c_params)
	return c_output


def AT_RDD_ExtendedTarget_CucinottaPoint_Gy_by_integration ( r_m, a0_m, KatzPoint_r_min_m, max_electron_range_m, beta, Katz_point_coeff_Gy, C_norm):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] a0_m
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] beta
	 * @param[in] Katz_point_coeff_Gy
	 * @param[in] C_norm
	 * @return
	'''
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_C_norm = ctypes.c_double(C_norm)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_function =  libamtrack.AT_RDD_ExtendedTarget_CucinottaPoint_Gy_by_integration
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_KatzPoint_r_min_m, c_max_electron_range_m, c_beta, c_Katz_point_coeff_Gy, c_C_norm)
	return c_output


def AT_RDD_ExtendedTarget_CucinottaPoint_Gy ( r_m, a0_m, KatzPoint_r_min_m, max_electron_range_m, beta, Katz_point_coeff_Gy, C_norm, Cucinotta_plateau_Gy):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] a0_m
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] beta
	 * @param[in] Katz_point_coeff_Gy
	 * @param[in] C_norm
	 * @param[in] Cucinotta_plateau_Gy
	 * @return
	'''
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_Cucinotta_plateau_Gy = ctypes.c_double(Cucinotta_plateau_Gy)
	c_C_norm = ctypes.c_double(C_norm)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_function =  libamtrack.AT_RDD_ExtendedTarget_CucinottaPoint_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_KatzPoint_r_min_m, c_max_electron_range_m, c_beta, c_Katz_point_coeff_Gy, c_C_norm, c_Cucinotta_plateau_Gy)
	return c_output


def AT_inverse_RDD_ExtendedTarget_CucinottaPoint_solver_function_Gy ( r_m, params):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] params
	 * @return
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_inverse_RDD_ExtendedTarget_CucinottaPoint_solver_function_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_inverse_RDD_ExtendedTarget_CucinottaPoint_m ( D_Gy, a0_m, KatzPoint_r_min_m, max_electron_range_m, beta, Katz_point_coeff_Gy, C_norm, Cucinotta_plateau_Gy):
	'''
	 * TODO
	 * @param[in] D_Gy
	 * @param[in] a0_m
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] beta
	 * @param[in] Katz_point_coeff_Gy
	 * @param[in] C_norm
	 * @param[in] Cucinotta_plateau_Gy
	 * @return
	'''
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_D_Gy = ctypes.c_double(D_Gy)
	c_Cucinotta_plateau_Gy = ctypes.c_double(Cucinotta_plateau_Gy)
	c_C_norm = ctypes.c_double(C_norm)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_function =  libamtrack.AT_inverse_RDD_ExtendedTarget_CucinottaPoint_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_a0_m, c_KatzPoint_r_min_m, c_max_electron_range_m, c_beta, c_Katz_point_coeff_Gy, c_C_norm, c_Cucinotta_plateau_Gy)
	return c_output


def AT_characteristic_single_scattering_angle_single ( E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym):
	'''
	 *  Returns characteristic single scattering angle chi_c
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  target_thickness_cm      thickness of the target material in cm
	 * @param[in]  element_acronym		    elemental symbol of target material (array of size PARTICLE_NAME_NCHAR)
	 * @return     chi_c in rad
	'''
	c_target_thickness_cm = ctypes.c_double(target_thickness_cm)
	c_element_acronym = ctypes.c_char_p(element_acronym)

	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_characteristic_single_scattering_angle_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym)
	return c_output


def AT_characteristic_single_scattering_angle ( n, E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym, chi_c):
	'''
	 *  Returns characteristic single scattering angles chi_c
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_charge_e    	vector of charge numbers of particle (array of size n)
	 * @param[in]  target_thickness_cm      vector of thicknesses of target material in cm (array of size n)
	 * @param[in]  element_acronym		    vector of elemental symbols of target material (array of size n)
	 * @param[out] chi_c                    vector of characteristic single scattering angles in rad (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(target_thickness_cm)
	c_target_thickness_cm = ctypes.byref(tmp_array(*target_thickness_cm))

	c_element_acronym = ctypes.c_char_p(element_acronym)

	tmp_array =ctypes.c_int* len(particle_charge_e)
	c_particle_charge_e = ctypes.byref(tmp_array(*particle_charge_e))

	tmp_array = (ctypes.c_double*n)()
	c_chi_c= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_characteristic_single_scattering_angle
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym, c_chi_c)
	return c_output,  c_chi_c._obj


def AT_screening_angle_single ( E_MeV_u, particle_charge_e, element_acronym):
	'''
	 *  Returns screening angle chi_a
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  element_acronym		    elemental symbol of target material (array of size PARTICLE_NAME_NCHAR)
	 * @return     chi_a in rad
	'''
	c_element_acronym = ctypes.c_char_p(element_acronym)

	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_screening_angle_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_charge_e, c_element_acronym)
	return c_output


def AT_screening_angle ( n, E_MeV_u, particle_charge_e, element_acronym, chi_a):
	'''
	 *  Returns screening angles chi_a
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_charge_e    	vector of charge numbers of particle (array of size n)
	 * @param[in]  element_acronym		    vector of elemental symbols of target material (array of size n)
	 * @param[out] chi_a                    vector of screening angles in rad (array of size n)
	 * @return     status code
	'''
	c_element_acronym = ctypes.c_char_p(element_acronym)

	tmp_array = (ctypes.c_double*n)()
	c_chi_a= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_int* len(particle_charge_e)
	c_particle_charge_e = ctypes.byref(tmp_array(*particle_charge_e))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_screening_angle
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_charge_e, c_element_acronym, c_chi_a)
	return c_output,  c_chi_a._obj


def AT_effective_collision_number_single ( E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym):
	'''
	 *  Returns effective collision number exp_b
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  target_thickness_cm      thickness of the target material in cm
	 * @param[in]  element_acronym		    elemental symbol of target material (array of size PARTICLE_NAME_NCHAR)
	 * @return     exp_b
	'''
	c_target_thickness_cm = ctypes.c_double(target_thickness_cm)
	c_element_acronym = ctypes.c_char_p(element_acronym)

	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_effective_collision_number_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym)
	return c_output


def AT_effective_collision_number ( n, E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym, exp_b):
	'''
	 *  Returns effective collision numbers exp_b
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_charge_e    	vector of charge numbers of particle (array of size n)
	 * @param[in]  target_thickness_cm      vector of thicknesses of target material in cm (array of size n)
	 * @param[in]  element_acronym		    vector of elemental symbols of target material (array of size n)
	 * @param[out] exp_b	                vector of effective collision numbers (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(target_thickness_cm)
	c_target_thickness_cm = ctypes.byref(tmp_array(*target_thickness_cm))

	c_element_acronym = ctypes.c_char_p(element_acronym)

	tmp_array =ctypes.c_int* len(particle_charge_e)
	c_particle_charge_e = ctypes.byref(tmp_array(*particle_charge_e))

	tmp_array = (ctypes.c_double*n)()
	c_exp_b= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_effective_collision_number
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym, c_exp_b)
	return c_output,  c_exp_b._obj


def AT_reduced_target_thickness_single ( E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym):
	'''
	 *  Returns reduced target thickness B
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  target_thickness_cm      thickness of the target material in cm
	 * @param[in]  element_acronym		    elemental symbol of target material (array of size PARTICLE_NAME_NCHAR)
	 * @return     B
	'''
	c_target_thickness_cm = ctypes.c_double(target_thickness_cm)
	c_element_acronym = ctypes.c_char_p(element_acronym)

	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_reduced_target_thickness_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym)
	return c_output


def AT_reduced_target_thickness ( n, E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym, B):
	'''
	 *  Returns reduced target thicknesses B
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_charge_e    	vector of charge numbers of particle (array of size n)
	 * @param[in]  target_thickness_cm      vector of thicknesses of target material in cm (array of size n)
	 * @param[in]  element_acronym		    vector of elemental symbols of target material (array of size n)
	 * @param[out] B		                vector of reduced target thicknesses (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(target_thickness_cm)
	c_target_thickness_cm = ctypes.byref(tmp_array(*target_thickness_cm))

	c_element_acronym = ctypes.c_char_p(element_acronym)

	tmp_array = (ctypes.c_double*n)()
	c_B= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_int* len(particle_charge_e)
	c_particle_charge_e = ctypes.byref(tmp_array(*particle_charge_e))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_reduced_target_thickness
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym, c_B)
	return c_output,  c_B._obj


def AT_characteristic_multiple_scattering_angle_single ( E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym):
	'''
	 *  Returns characteristic multiple scattering angle Theta_M
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  target_thickness_cm      thickness of the target material in cm
	 * @param[in]  element_acronym		    elemental symbol of target material (array of size PARTICLE_NAME_NCHAR)
	 * @return     Theta_M in rad
	'''
	c_target_thickness_cm = ctypes.c_double(target_thickness_cm)
	c_element_acronym = ctypes.c_char_p(element_acronym)

	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_characteristic_multiple_scattering_angle_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym)
	return c_output


def AT_characteristic_multiple_scattering_angle ( n, E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym, Theta_M):
	'''
	 *  Returns characteristic multiple scattering angles Theta_M
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_charge_e    	vector of charge numbers of particle (array of size n)
	 * @param[in]  target_thickness_cm      vector of thicknesses of target material in cm (array of size n)
	 * @param[in]  element_acronym		    vector of elemental symbols of target material (array of size n)
	 * @param[out] Theta_M		            vector of characteristic multiple scattering angles in rad (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(target_thickness_cm)
	c_target_thickness_cm = ctypes.byref(tmp_array(*target_thickness_cm))

	c_element_acronym = ctypes.c_char_p(element_acronym)

	tmp_array =ctypes.c_int* len(particle_charge_e)
	c_particle_charge_e = ctypes.byref(tmp_array(*particle_charge_e))

	tmp_array = (ctypes.c_double*n)()
	c_Theta_M= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_characteristic_multiple_scattering_angle
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym, c_Theta_M)
	return c_output,  c_Theta_M._obj


def AT_Moliere_function_f0 ( red_Theta):
	'''
	 *  Returns values f0(red_Theta) of the first Moliere function
	 *
	 * @param[in]  red_Theta                reduced angle variable
	 * @return     first Moliere function
	'''
	c_red_Theta = ctypes.c_double(red_Theta)
	c_function =  libamtrack.AT_Moliere_function_f0
	c_function.restype = ctypes.c_double
	c_output = c_function( c_red_Theta)
	return c_output


def AT_Moliere_function_f1 ( red_Theta):
	'''
	 *  Returns values f1(red_Theta) of the second Moliere function
	 *
	 * @param[in]  red_Theta                reduced angle variable
	 * @return     second Moliere function
	'''
	c_red_Theta = ctypes.c_double(red_Theta)
	c_function =  libamtrack.AT_Moliere_function_f1
	c_function.restype = ctypes.c_double
	c_output = c_function( c_red_Theta)
	return c_output


def AT_Moliere_function_f2 ( red_Theta):
	'''
	 *  Returns values f2(red_Theta) of the third Moliere function
	 *
	 * @param[in]  red_Theta                reduced angle variable
	 * @return     third Moliere function
	'''
	c_red_Theta = ctypes.c_double(red_Theta)
	c_function =  libamtrack.AT_Moliere_function_f2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_red_Theta)
	return c_output


def AT_scattering_angle_distribution_single ( E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym, Theta):
	'''
	 *  Returns scattering angle distribution f(Theta)
	 *  The distribution is not normalized because the energy loss in the target is not considered.
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  target_thickness_cm      thickness of the target material in cm
	 * @param[in]  element_acronym		    elemental symbol of target material (array of size PARTICLE_NAME_NCHAR)
	 * @param[in]  Theta				   	polar angle in rad
	 * @return     f(Theta)
	'''
	c_target_thickness_cm = ctypes.c_double(target_thickness_cm)
	c_element_acronym = ctypes.c_char_p(element_acronym)

	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_Theta = ctypes.c_double(Theta)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_scattering_angle_distribution_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym, c_Theta)
	return c_output


def AT_scattering_angle_distribution ( n, E_MeV_u, particle_charge_e, target_thickness_cm, element_acronym, Theta, distribution):
	'''
	 *  Returns scattering angle distribution f(Theta)
	 *  The distribution is not normalized because the energy loss in the target is not considered.
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  target_thickness_cm      thickness of the target material in cm
	 * @param[in]  element_acronym		    elemental symbol of target material (array of size PARTICLE_NAME_NCHAR)
	 * @param[in]  Theta				   	vector of polar angles in rad (array of size n)
	 * @param[out] distribution		        vector of scattering angle distribution values (array of size n)
	 * @return     status code
	'''
	c_target_thickness_cm = ctypes.c_double(target_thickness_cm)
	c_element_acronym = ctypes.c_char_p(element_acronym)

	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	tmp_array =ctypes.c_double* len(Theta)
	c_Theta = ctypes.byref(tmp_array(*Theta))

	tmp_array = (ctypes.c_double*n)()
	c_distribution= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_scattering_angle_distribution
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_charge_e, c_target_thickness_cm, c_element_acronym, c_Theta, c_distribution)
	return c_output,  c_distribution._obj


def AT_Highland_angle_single ( E_MeV_u, particle_charge_e, l_over_lR):
	'''
	 *  Returns Highland angle Theta0
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_charge_e    	charge number of particle
	 * @param[in]  l_over_lR     			thickness of the target material in radiation lengths
	 * @return     Theta0 in rad
	'''
	c_l_over_lR = ctypes.c_double(l_over_lR)
	c_particle_charge_e = ctypes.c_int(particle_charge_e)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Highland_angle_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_charge_e, c_l_over_lR)
	return c_output


def AT_Highland_angle ( n, E_MeV_u, particle_charge_e, l_over_lR, Theta0):
	'''
	 *  Returns Highland angles Theta0
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_charge_e    	vector of charge numbers of particle (array of size n)
	 * @param[in]  l_over_lR		        vector of thicknesses of target material in radiation lengths (array of size n)
	 * @param[out] Theta0		            vector of Highland angles in rad (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_Theta0= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_int* len(particle_charge_e)
	c_particle_charge_e = ctypes.byref(tmp_array(*particle_charge_e))

	tmp_array =ctypes.c_double* len(l_over_lR)
	c_l_over_lR = ctypes.byref(tmp_array(*l_over_lR))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_Highland_angle
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_charge_e, c_l_over_lR, c_Theta0)
	return c_output,  c_Theta0._obj


def AT_beta_from_E_single ( E_MeV_u):
	'''
	 *  Returns relativistic speed for single value of energy
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @return     beta                     relative particle speed beta = v/c
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_beta_from_E_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_beta_from_E ( n, E_MeV_u, beta):
	'''
	 *  Returns relativistic speed for many particles
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[out] beta                     vector of relative particle speed beta = v/c (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_beta= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_beta_from_E
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_beta)
	return c_output,  c_beta._obj


def AT_E_from_beta_single ( beta):
	'''
	 *  Returns energy per nucleon of particle with relative speed beta
	 *
	 * @param[in]  beta                     relative particle speed beta = v/c
	 * @return                              energy of particle per nucleon [MeV]
	'''
	c_beta = ctypes.c_double(beta)
	c_function =  libamtrack.AT_E_from_beta_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_beta)
	return c_output


def AT_E_from_beta ( n, beta, E_MeV_u):
	'''
	 *  Returns energy per nucleon of particle with relativistic speed beta
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  beta                     vector of relative particle speed beta = v/c (array of size n)
	 * @param[out] E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(beta)
	c_beta = ctypes.byref(tmp_array(*beta))

	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_E_from_beta
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_beta, c_E_MeV_u)
	return c_output,  c_E_MeV_u._obj


def AT_E_from_gamma_single ( gamma):
	'''
	 *  Returns energy for single value of relativistic gamma
	 *
	 * @param[in]  gamma
	 * @return     E_MeV_u                  energy of particle per nucleon [MeV]
	'''
	c_gamma = ctypes.c_double(gamma)
	c_function =  libamtrack.AT_E_from_gamma_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_gamma)
	return c_output


def AT_E_from_gamma ( n, gamma, E_MeV_u):
	'''
	 *  Returns energy from relativistic gamma
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  gamma                    vector of results (array of size n)
	 * @param[out] E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(gamma)
	c_gamma = ctypes.byref(tmp_array(*gamma))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_E_from_gamma
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_gamma, c_E_MeV_u)
	return c_output,  c_E_MeV_u._obj


def AT_E_MeV_u_from_momentum_single ( momentum_MeV_c_u):
	'''
	 *  Returns energy per nucleon of particle with given momentum per nucleon
	 *
	 * @param[in]  momentum_MeV_c_u         momentum per particle [MeV/c]
	 * @return                              energy of particle per nucleon [MeV]
	'''
	c_momentum_MeV_c_u = ctypes.c_double(momentum_MeV_c_u)
	c_function =  libamtrack.AT_E_MeV_u_from_momentum_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_momentum_MeV_c_u)
	return c_output


def AT_E_MeV_u_from_momentum_MeV_c_u ( n, momentum_MeV_c_u, E_MeV_u):
	'''
	 *  Returns energy per nucleon for particles with given momentum per nucleon
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  momentum_MeV_c_u         vector of particle momenta per nucleon [MeV/c], (array of size n)
	 * @param[out] E_MeV_u                  vector of energies of particle per nucleon [MeV], (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(momentum_MeV_c_u)
	c_momentum_MeV_c_u = ctypes.byref(tmp_array(*momentum_MeV_c_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_E_MeV_u_from_momentum_MeV_c_u
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_momentum_MeV_c_u, c_E_MeV_u)
	return c_output,  c_E_MeV_u._obj


def AT_gamma_from_E_single ( E_MeV_u):
	'''
	 *  Returns relativistic gamma for single value of energy
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @return     gamma
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_gamma_from_E_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_gamma_from_E ( n, E_MeV_u, gamma):
	'''
	 *  Returns relativistic gamma
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[out] gamma                    vector of results (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_gamma= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_gamma_from_E
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_gamma)
	return c_output,  c_gamma._obj


def AT_effective_charge_from_beta_single ( beta, Z):
	'''
	 * Effective charge according to Barkas-Bethe-approximation:
	 *
	 * Zeff = Z *[1- exp( -125 * beta / Z^(2/3) )]
	 *
	 * calculated for particle with given relative speed beta
	 *
	 * @param[in]  beta                     relative particle speed beta = v/c
	 * @param[in]  Z                        atomic number Z of ion
	 * @return     effective_charge of ion
	'''
	c_beta = ctypes.c_double(beta)
	c_Z = ctypes.c_long(Z)
	c_function =  libamtrack.AT_effective_charge_from_beta_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_beta, c_Z)
	return c_output


def AT_effective_charge_from_beta ( n, beta, Z, effective_charge):
	'''
	 * Effective charge according to Barkas-Bethe-approximation:
	 *
	 * Zeff = Z *[1-exp( -125 * beta / Z^(2/3) )]
	 *
	 * calculated for particle with given relative speed beta
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  beta                     vector of relative particle speed beta = v/c (array of size n)
	 * @param[in]  Z                        atomic number Z of ion (array of size n)
	 * @param[out] effective_charge of ion
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(beta)
	c_beta = ctypes.byref(tmp_array(*beta))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	tmp_array = (ctypes.c_double*1)()
	c_effective_charge= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_effective_charge_from_beta
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_beta, c_Z, c_effective_charge)
	return c_output,  c_effective_charge._obj


def AT_energy_straggling_MeV2_cm2_g ( n, E_MeV_u, particle_no, material_no, dsE2dz_MeV2_cm2_g):
	'''
	 * Get energy spread with depth according to Bohr\'s classical theory
	 * Bohr, N. (1915), Phil. Mag. 30, 581ff, see also Evans, R.D. (1955), The atomic nucleus, McGraw Hill, New York, p. 661
	 * In the literature dsE2dz is often given in units ergs2/cm. Here we report it mass-normalized MeV2*cm2/g
	 * Since the effective charge of the particle enters the equation, particle types and energies have to be given
	 * The equation is however limited to energies > 10 MeV/u and not too heavy ions
	 * TODO: add William extension for relativistic effects (Williams, E.J. (1945), Revs. Mod. Phys. 17, 217ff)
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_no              type of the particles in the mixed particle field (array of size n)
	 * @param[in]  material_no              index number for slab material
	 * @param[out] dsE2dz_MeV2_cm2_g        Increase of energy straggling variance sigma_E^2 per unit length of material (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*n)()
	c_dsE2dz_MeV2_cm2_g= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_energy_straggling_MeV2_cm2_g
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_dsE2dz_MeV2_cm2_g)
	return c_output,  c_dsE2dz_MeV2_cm2_g._obj


def AT_energy_straggling_after_slab_E_MeV_u ( n, E_MeV_u, particle_no, material_no, slab_thickness_m, initial_sigma_E_MeV_u, sigma_E_MeV_u):
	'''
	 * Get energy spread of an ion beam after traversing
	 * a material slab according to Bohr\'s classical theory.
	 * Bohr, N. (1915), Phil. Mag. 30, 581ff, see also Evans, R.D. (1955), The atomic nucleus, McGraw Hill, New York, p. 661
	 * Please note that the effective charge is assumed to be constant over the material slab
	 * If this is not the case you should apply this routine multiple times to subslices
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_no              type of the particles in the mixed particle field (array of size n)
	 * @param[in]  material_no              index number for slab material
	 * @param[in]  slab_thickness_m         thickness of slab in m
	 * @param[in]  initial_sigma_E_MeV_u    energy spread - 1 sigma - before traversing the slab - can be 0 (array of size n)
	 * @param[out] sigma_E_MeV_u            energy spread - 1 sigma - after traversing the slab (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(initial_sigma_E_MeV_u)
	c_initial_sigma_E_MeV_u = ctypes.byref(tmp_array(*initial_sigma_E_MeV_u))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_sigma_E_MeV_u= ctypes.byref(tmp_array)

	c_slab_thickness_m = ctypes.c_double(slab_thickness_m)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_energy_straggling_after_slab_E_MeV_u
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_slab_thickness_m, c_initial_sigma_E_MeV_u, c_sigma_E_MeV_u)
	return c_output,  c_sigma_E_MeV_u._obj


def AT_effective_charge_from_E_MeV_u_single ( E_MeV_u, particle_no):
	'''
	 * Effective charge according to Barkas-Bethe-approximation
	 * for particle with given energy per nucleon
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV]
	 * @param[in]  particle_no              type of the particles in the mixed particle field
	 * @return     effective_charge         Effective charge according to Barkas-Bethe-approximation
	'''
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_effective_charge_from_E_MeV_u_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no)
	return c_output


def AT_effective_charge_from_E_MeV_u ( n, E_MeV_u, particle_no, effective_charge):
	'''
	 * Effective charge according to Barkas-Bethe-approximation:
	 * for particles with given kinetic energy per nucleon
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_no              type of the particles in the mixed particle field (array of size n)
	 * @param[out] effective_charge         Effective charge according to Barkas-Bethe-approximation (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_effective_charge= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_effective_charge_from_E_MeV_u
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_effective_charge)
	return c_output,  c_effective_charge._obj


def AT_mean_excitation_energy_eV_from_Z_single ( Z):
	'''
	 * Returns mean excitation energy for elements (according to Sternheimer: Phys. Rev. 145, 247 in 1966)
	 *
	 * @param[in]  Z            		    atomic number
	 * @return I_eV
	'''
	c_Z = ctypes.c_long(Z)
	c_function =  libamtrack.AT_mean_excitation_energy_eV_from_Z_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_Z)
	return c_output


def AT_mean_excitation_energy_eV_from_Z ( n, Z, I_eV):
	'''
	 *  Returns mean excitation energies for elements
	 *
	 * @param[in]  n                        number of elements
	 * @param[in]  Z                   		vector of atomic numbers (array of size n)
	 * @param[out] I_eV        				vector of mean excitation energies (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_I_eV= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_mean_excitation_energy_eV_from_Z
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_Z, c_I_eV)
	return c_output,  c_I_eV._obj


def AT_mass_correction_terms ( E_MeV_u):
	'''
	  * Returns mass correction terms of max relativistic energy transfer for single particle
	  *
	  * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV/u]
	  * @return mass_correction_terms
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_mass_correction_terms
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_max_relativistic_E_transfer_MeV_single ( E_MeV_u):
	'''
	  * Max relativistic energy transfer with mass correction terms for single particle
	  *
	  * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV/u]
	  * @return max_rel_E_transfer_MeV
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_max_relativistic_E_transfer_MeV_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_max_classic_E_transfer_MeV_single ( E_MeV_u):
	'''
	 * Max classic energy transfer for single particle
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV/u]
	 * @return max_classic_E_transfer_MeV
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_max_classic_E_transfer_MeV_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_max_E_transfer_MeV_single ( E_MeV_u):
	'''
	 * Max energy transfer for single particle
	 *
	 * @param[in]  E_MeV_u                  energy of particle per nucleon [MeV/u]
	 * @return     max_E_transfer_MeV
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_max_E_transfer_MeV_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_max_E_transfer_MeV ( n, E_MeV_u, max_E_transfer_MeV):
	'''
	 * Kinetic energy maximally transferred from an ion to an electron
	 * in a collision - relativistic or non-relativistic
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  energies of particle per nucleon [MeV/u]; if positive, the computation will be relativistic; if negative, the classic formular will be used (array of size n)
	 * @param[out] max_E_transfer_MeV       maximal energies transferred (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_max_E_transfer_MeV= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_max_E_transfer_MeV
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_max_E_transfer_MeV)
	return c_output,  c_max_E_transfer_MeV._obj


def AT_momentum_from_E_MeV_c_u_single ( E_MeV_u):
	'''
	 *  Returns relativistic momentum (per nucleon) of particle
	 *
	 * @param[in]	  	E_MeV_u                 kinetic Energy per nucleon
	 * @return                              momentum [MeV/c]
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_momentum_from_E_MeV_c_u_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_momentum_MeV_c_u_from_E_MeV_u ( n, E_MeV_u, momentum_MeV_c):
	'''
	 *  Returns relativistic momenta per nucleon for particles with given kinetic energy
	 *
	 * @param[in]	n						number of particles
	 * @param[in]  	E_MeV_u                 kinetic energy per nucleon (array of size n)
	 * @param[out]	momentum_MeV_c  		momentum per nucleon (array of size n)
	 * @return                              return code
	'''
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_momentum_MeV_c= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_momentum_MeV_c_u_from_E_MeV_u
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_momentum_MeV_c)
	return c_output,  c_momentum_MeV_c._obj


def AT_dose_Gy_from_fluence_cm2_single ( E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Returns dose in Gy for particle with given fluence and energy
	 * @param[in]  E_MeV_u      energy per unit mass
	 * @param[in]  particle_no  type of the particle
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluence in 1/cm2
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  stopping power source index
	 * @return     D_Gy         dose in Gy
	'''
	c_material_no = ctypes.c_long(material_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_fluence_cm2 = ctypes.c_double(fluence_cm2)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_dose_Gy_from_fluence_cm2_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_dose_Gy_from_fluence_cm2 ( n, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no, dose_Gy):
	'''
	 * Returns dose in Gy for each given particle
	 * @param[in]  n            number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size n)
	 * @param[in]  particle_no  type of the particles in the mixed particle field (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluence for each particle type (array of size n)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  stopping power source index
	 * @param[out] dose_Gy          be allocated by the user which will be used to return the results (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*n)()
	c_dose_Gy= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_dose_Gy_from_fluence_cm2
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no, c_dose_Gy)
	return c_output,  c_dose_Gy._obj


def AT_fluence_cm2_from_dose_Gy_single ( E_MeV_u, particle_no, D_Gy, material_no, stopping_power_source_no):
	'''
	 * Returns fluence in 1/cm2 for particles with given dose and energy
	 * @param[in]  E_MeV_u      energy of particle
	 * @param[in]  particle_no  type of the particles
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  D_Gy         dose in Gy
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @return fluence in 1/cm2
	'''
	c_material_no = ctypes.c_long(material_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_D_Gy = ctypes.c_double(D_Gy)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_fluence_cm2_from_dose_Gy_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_D_Gy, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_fluence_cm2_from_dose_Gy ( n, E_MeV_u, particle_no, D_Gy, material_no, stopping_power_source_no, fluence_cm2):
	'''
	 * Returns fluence in 1/cm2 for each given particle
	 * @param[in]  n            number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size n)
	 * @param[in]  particle_no  type of the particles in the mixed particle field (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  D_Gy         dose / Gy for each particle type (array of size n)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @param[out] fluence_cm2         to be allocated by the user which will be used to return the results (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(D_Gy)
	c_D_Gy = ctypes.byref(tmp_array(*D_Gy))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_fluence_cm2_from_dose_Gy
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_D_Gy, c_material_no, c_stopping_power_source_no, c_fluence_cm2)
	return c_output,  c_fluence_cm2._obj


def AT_beam_par_physical_to_technical ( n, fluence_cm2, sigma_cm, N, FWHM_mm):
	'''
	 * Converts physical beam parameters of a symmetric, double lateral Gaussian shape beam, i.e.
	 * central (=peak) fluence and width (= 1 standard deviation)
	 * to technical, accelerator parameters, i.e.
	 * total number of particles and FWHM
	 *
	 * @param[in]      n             length of vectors for parameters
	 * @param[in]      fluence_cm2   fluence in beam center (array of size n)
	 * @param[in]      sigma_cm      beam width stdev (array of size n)
	 * @param[out]     N             resulting absolute particle numbers (array of size n)
	 * @param[out]     FWHM_mm       resulting FWHMs (in mm) (array of size n)
	'''
	tmp_array =ctypes.c_double* len(sigma_cm)
	c_sigma_cm = ctypes.byref(tmp_array(*sigma_cm))

	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array = (ctypes.c_double*n)()
	c_N= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_FWHM_mm= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_beam_par_physical_to_technical
	c_output = c_function( c_n, c_fluence_cm2, c_sigma_cm, c_N, c_FWHM_mm)
	return c_output,  c_N._obj, c_FWHM_mm._obj


def AT_beam_par_technical_to_physical ( n, N, FWHM_mm, fluence_cm2, sigma_cm):
	'''
	 * Converts technical, accelerator parameters of a symmetric, double lateral Gaussian shape beam, i.e.
	 * total number of particles and FWHM to
	 * physical beam parameters, i.e.
	 * central (=peak) fluence and width (= 1 standard deviation)
	 *
	 * @param[in]      n             length of vectors for parameters
	 * @param[in]      N             absolute particle numbers (array of size n)
	 * @param[in]      FWHM_mm       FWHMs (in mm) (array of size n)
	 * @param[out]     fluence_cm2   resulting fluence in beam center (array of size n)
	 * @param[out]     sigma_cm      resulting beam width stdev (array of size n)
	'''
	tmp_array = (ctypes.c_double*n)()
	c_sigma_cm= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(FWHM_mm)
	c_FWHM_mm = ctypes.byref(tmp_array(*FWHM_mm))

	tmp_array =ctypes.c_double* len(N)
	c_N = ctypes.byref(tmp_array(*N))

	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_beam_par_technical_to_physical
	c_output = c_function( c_n, c_N, c_FWHM_mm, c_fluence_cm2, c_sigma_cm)
	return c_output,  c_fluence_cm2._obj, c_sigma_cm._obj


def AT_interparticleDistance_m ( n, LET_MeV_cm2_g, fluence_cm2, results_m):
	'''
	 * Interparticle distance
	 *
	 * @param[in]      n               length of vectors for parameters
	 * @param[in]      LET_MeV_cm2_g   LET for each particle type (array of size n)
	 * @param[in]      fluence_cm2     fluence for each particle type (array of size n)
	 * @param[out]     results_m       interparticle distance for each particle type (array of size n)
	'''
	tmp_array =ctypes.c_double* len(LET_MeV_cm2_g)
	c_LET_MeV_cm2_g = ctypes.byref(tmp_array(*LET_MeV_cm2_g))

	tmp_array = (ctypes.c_double*n)()
	c_results_m= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_interparticleDistance_m
	c_output = c_function( c_n, c_LET_MeV_cm2_g, c_fluence_cm2, c_results_m)
	return c_output,  c_results_m._obj


def AT_inv_interparticleDistance_Gy ( n, LET_MeV_cm2_g, distance_m, results_Gy):
	'''
	 * Inverse interparticle distance
	 *
	 * @param[in]      n               length of vectors for parameters
	 * @param[in]      LET_MeV_cm2_g   LET for each particle type (array of size n)
	 * @param[in]      distance_m      interparticle distance for each particle type (array of size n)
	 * @param[out]     results_Gy
	'''
	tmp_array = (ctypes.c_double*1)()
	c_results_Gy= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(LET_MeV_cm2_g)
	c_LET_MeV_cm2_g = ctypes.byref(tmp_array(*LET_MeV_cm2_g))

	tmp_array =ctypes.c_double* len(distance_m)
	c_distance_m = ctypes.byref(tmp_array(*distance_m))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_inv_interparticleDistance_Gy
	c_output = c_function( c_n, c_LET_MeV_cm2_g, c_distance_m, c_results_Gy)
	return c_output,  c_results_Gy._obj


def AT_single_impact_fluence_cm2_single ( E_MeV_u, material_no, er_model):
	'''
	 * Computes the fluences at which (for a given material and electron-range model) every
	 * point of the detector lies within the area ONE track only
	 *
	 * Needed by SuccessiveConvolutions
	 *
	 * @param[in]  E_MeV_u      energy of particle
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  er_model     index of electron-range model
	 * @see          AT_ElectronRange.h for definition
	 * @return     single_impact_fluence_cm2  results (one for each entry in the parameter vectors)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_er_model = ctypes.c_long(er_model)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_single_impact_fluence_cm2_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_material_no, c_er_model)
	return c_output


def AT_single_impact_fluence_cm2 ( n, E_MeV_u, material_no, er_model, single_impact_fluence_cm2):
	'''
	 * Computes the fluences at which (for a given material and electron-range model) every
	 * point of the detector lies within the area ONE track only
	 *
	 * Needed by SuccessiveConvolutions
	 *
	 * @param[in]  n            length of vectors for parameters
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size n)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  er_model     index of electron-range model
	 * @see          AT_ElectronRange.h for definition
	 * @param[out] single_impact_fluence_cm2  results (one for each entry in the parameter vectors) (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*n)()
	c_single_impact_fluence_cm2= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_er_model = ctypes.c_long(er_model)
	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_single_impact_fluence_cm2
	c_output = c_function( c_n, c_E_MeV_u, c_material_no, c_er_model, c_single_impact_fluence_cm2)
	return c_output,  c_single_impact_fluence_cm2._obj


def AT_single_impact_dose_Gy_single ( LET_MeV_cm2_g, single_impact_fluence_cm2):
	'''
	 * Dose for the fluence at a single impact
	 *
	 * @param[in] LET_MeV_cm2_g              LET of particle
	 * @param[in] single_impact_fluence_cm2  the fluence corresponding to a single impact
	 * @return    single impact dose
	'''
	c_LET_MeV_cm2_g = ctypes.c_double(LET_MeV_cm2_g)
	c_single_impact_fluence_cm2 = ctypes.c_double(single_impact_fluence_cm2)
	c_function =  libamtrack.AT_single_impact_dose_Gy_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_LET_MeV_cm2_g, c_single_impact_fluence_cm2)
	return c_output


def AT_single_impact_dose_Gy ( n, E_MeV_u, particle_no, material_no, er_model, stopping_power_source_no, single_impact_dose_Gy):
	'''
	 * Doses for the fluences at a single impact
	 *
	 * @param[in]  n                          number of particles
	 * @param[in]  E_MeV_u                    Energy (array of size n)
	 * @param[in]  particle_no                particle type (array of size n)
	 * @param[in]  material_no                material
	 * @param[in]  er_model                   electron-range model
	 * @param[in]  stopping_power_source_no   TODO
	 * @param[out] single_impact_dose_Gy      resulting single impact doses (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*n)()
	c_single_impact_dose_Gy= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_er_model = ctypes.c_long(er_model)
	c_function =  libamtrack.AT_single_impact_dose_Gy
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_er_model, c_stopping_power_source_no, c_single_impact_dose_Gy)
	return c_output,  c_single_impact_dose_Gy._obj


def AT_total_D_Gy ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the total dose of a mixed particle field
	 *
	 * @param[in]  number_of_field_components            number of components in the mixed field
	 * @param[in]  E_MeV_u                               energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no                           particle index (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2                           fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no                           material index
	 * @see AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no              TODO
	 * @return     total_dose_Gy                         result
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_total_D_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_total_fluence_cm2 ( number_of_field_components, E_MeV_u, particle_no, D_Gy, material_no, stopping_power_source_no):
	'''
	 * Computes the total fluence of a mixed particle field
	 *
	 * @param[in]  number_of_field_components            number of components in the mixed field
	 * @param[in]  E_MeV_u                               energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no                           particle index (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]  D_Gy                                  doses of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no                           material index
	 * @param[in]  stopping_power_source_no              TODO
	 * @see AT_DataMaterial.h for definition
	 * @return     total_fluence_cm                      result
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(D_Gy)
	c_D_Gy = ctypes.byref(tmp_array(*D_Gy))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_function =  libamtrack.AT_total_fluence_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_D_Gy, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_fluence_weighted_E_MeV_u ( number_of_field_components, E_MeV_u, fluence_cm2):
	'''
	 * Computes the fluence-weighted average energy of a particle field
	 *
	 * Needed by SuccessiveConvolutions
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @return     average_E_MeV_u  fluence-weighted mean energy
	'''
	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_fluence_weighted_E_MeV_u
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_fluence_cm2)
	return c_output


def AT_dose_weighted_E_MeV_u ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the dose-weighted average energy of a particle field
	 *
	 * Needed by SuccessiveConvolutions
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     dose-weighted mean energy
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_dose_weighted_E_MeV_u
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_fluence_weighted_LET_MeV_cm2_g ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the fluence-weighted average LET of a particle field
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     fluence-weighted LET
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_fluence_weighted_LET_MeV_cm2_g
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_dose_weighted_LET_MeV_cm2_g ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the dose-weighted average LET of a particle field
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     dose-weighted LET
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_dose_weighted_LET_MeV_cm2_g
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_stopping_power_ratio ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, reference_material_no, stopping_power_source_no):
	'''
	 * Computes the stopping power ratio for a material and a reference material.
	 *
	 * In case of mixed particle fields, the stopping power ratios of individual components are
	 * weighted by their respective fluences. Thus, this routines computes the ration of fluence-weighted
	 * stopping powers, NOT of dose-weighted stopping powers.
	 *
	 * @param[in]  number_of_field_components            number of components in mixed field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  reference_material_no  material index of reference material
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     stopping power ratio
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_reference_material_no = ctypes.c_long(reference_material_no)
	c_function =  libamtrack.AT_stopping_power_ratio
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_reference_material_no, c_stopping_power_source_no)
	return c_output


def AT_mean_number_of_tracks_contrib ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, er_model, stopping_power_source_no):
	'''
	 * Computes the number of track contributing to a representative point in a mixed field
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  er_model     chosen electron-range-model
	 * @param[in]  stopping_power_source_no     TODO
	 * @return     resulting mean number of tracks contributing
	'''
	c_material_no = ctypes.c_long(material_no)
	c_er_model = ctypes.c_long(er_model)
	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_mean_number_of_tracks_contrib
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_er_model, c_stopping_power_source_no)
	return c_output


def AT_kinetic_variable_single ( E_MeV_u):
	'''
	 * Computes the kinetic variable needed for computation of
	 * density effect in Bethe formula for stopping power
	 * following the Sternheimer (1971) approach
	 *
	 * @param[in]  E_MeV_u      energy of particle
	 * @return     				kinetic variable
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_kinetic_variable_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_Rutherford_scatter_cross_section ( E_MeV_u, particle_no, material_no, n, scattering_angle, scatter_cross_section):
	'''
	 * Computes the cross section (in 1/m2) the a particle is scattered
	 * in the solid angle O = 2 * pi * theta * d_theta given the
	 * scatter angle theta
	 *
	 * @param[in]  E_MeV_u      			energy of incoming particle
	 * @param[in]  particle_no  			particle index
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  material_no  			material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  n						number of scattering angles given
	 * @param[in]  scattering_angle			scattering angles theta (array of size n)
	 * @param[out] scatter_cross_section	scatter cross section (array of size n)
	 * @return     status code
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*n)()
	c_scatter_cross_section= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_particle_no = ctypes.c_long(particle_no)
	tmp_array =ctypes.c_double* len(scattering_angle)
	c_scattering_angle = ctypes.byref(tmp_array(*scattering_angle))

	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Rutherford_scatter_cross_section
	c_function.restype = ctypes.c_long
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_n, c_scattering_angle, c_scatter_cross_section)
	return c_output,  c_scatter_cross_section._obj


def AT_gyroradius_m ( E_MeV_u, particle_no, B_T):
	'''
	 * Computes the gyroradius for a particle in a magnetic field. For this,
	 * the effective charge of the particle (as a function of the kinetic energy)
	 * is used.
	 *
	 * @param[in]  E_MeV_u      			energy of incoming particle
	 * @param[in]  particle_no  			particle index
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  B_T						magnetic B-field strength in Tesla
	 * @return     gyroradius in m
	'''
	c_particle_no = ctypes.c_long(particle_no)
	c_B_T = ctypes.c_double(B_T)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_gyroradius_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_B_T)
	return c_output


def AT_particle_no_from_Z_and_A_single ( Z, A):
	'''
	 * TODO
	 *
	 * @param[in]  Z            atomic number
	 * @param[in]  A            mass number
	 * @return particle_no
	'''
	c_A = ctypes.c_long(A)
	c_Z = ctypes.c_long(Z)
	c_function =  libamtrack.AT_particle_no_from_Z_and_A_single
	c_function.restype = ctypes.c_long
	c_output = c_function( c_Z, c_A)
	return c_output


def AT_particle_no_from_Z_and_A ( n, Z, A, particle_no):
	'''
	 * Returns particle index number from given A and Z
	 *
	 * @param[in]  n            array sizes
	 * @param[in]  Z            atomic numbers (array of size n)
	 * @param[in]  A            mass number (array of size n)
	 * @param[out] particle_no  corresponding particle index numbers (array of size n)
	 * @return status code
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	tmp_array = (ctypes.c_long*n)()
	c_particle_no= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_particle_no_from_Z_and_A
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_Z, c_A, c_particle_no)
	return c_output,  c_particle_no._obj


def AT_A_from_particle_no_single ( particle_no):
	'''
	 * Calculates mass number A for particle with given code number
	 * @param[in] particle_no
	 * @return A
	'''
	c_particle_no = ctypes.c_long(particle_no)
	c_function =  libamtrack.AT_A_from_particle_no_single
	c_function.restype = ctypes.c_long
	c_output = c_function( c_particle_no)
	return c_output


def AT_A_from_particle_no ( n, particle_no, A):
	'''
	 * Returns mass number for given particle number
	 * @param[in]  n                length of arrays
	 * @param[in]  particle_no      particle index number (array of size n)
	 * @param[out] A                mass number (array of size n)
	 * @return     return code
	'''
	tmp_array = (ctypes.c_long*n)()
	c_A= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_A_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_A)
	return c_output,  c_A._obj


def AT_atomic_weight_from_Z ( n, Z, atomic_weight):
	'''
	 * Returns atomic weight for given Z
	 * @param[in]  n                length of arrays
	 * @param[in]  Z                atomic number (array of size n)
	 * @param[out] atomic_weight    atomic weight (array of size n)
	 * @return     return code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_atomic_weight= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_atomic_weight_from_Z
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_Z, c_atomic_weight)
	return c_output,  c_atomic_weight._obj


def AT_Z_from_particle_no_single ( particle_no):
	'''
	 * Calculates atomic number Z for particle with given code number
	 * @param[in] particle_no
	 * @return Z
	'''
	c_particle_no = ctypes.c_long(particle_no)
	c_function =  libamtrack.AT_Z_from_particle_no_single
	c_function.restype = ctypes.c_long
	c_output = c_function( c_particle_no)
	return c_output


def AT_Z_from_particle_no ( n, particle_no, Z):
	'''
	 * Returns atomic number for given particle number
	 * @param[in]  n               length of arrays
	 * @param[in]  particle_no     particle index number (array of size n)
	 * @param[out] Z               atomic number (array of size n)
	 * @return     return code
	'''
	tmp_array = (ctypes.c_long*n)()
	c_Z= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_Z_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_Z)
	return c_output,  c_Z._obj


def AT_atomic_weight_from_particle_no ( n, particle_no, atomic_weight):
	'''
	 * Calculates atomic weight for particle with given code number
	 * @param[in]  n              length of arrays
	 * @param[in]  particle_no    particle index number (array of size n)
	 * @param[out] atomic_weight  atomic weight (array of size n)
	 * @return                    status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_atomic_weight= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_atomic_weight_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_atomic_weight)
	return c_output,  c_atomic_weight._obj


def AT_I_eV_from_particle_no ( n, particle_no, I_eV):
	'''
	 * Return I value for given elements
	 * @param[in]  n              number of elements
	 * @param[in]  particle_no    particle index number (array of size n)
	 * @param[out] I_eV           I value (array of size n)
	 * @return                    status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_I_eV= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_I_eV_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_I_eV)
	return c_output,  c_I_eV._obj


def AT_nuclear_spin_from_particle_no_multi ( n, particle_no, I):
	'''
	 * Returns nuclear spin from particle no
	 * @param[in]  n              number of elements
	 * @param[in]  particle_no    particle index number (array of size n)
	 * @param[out] I              nuclear spin (array of size n)
	 * @return                    status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_I= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_nuclear_spin_from_particle_no_multi
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_I)
	return c_output,  c_I._obj


def AT_nuclear_spin_from_particle_no_single ( particle_no):
	'''
	 * Returns nuclear spin from particle no
	 * @param[in]  particle_no    particle index number (array of size n)
	 * @return     nuclear spin
	'''
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_function =  libamtrack.AT_nuclear_spin_from_particle_no_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_particle_no)
	return c_output


def AT_nuclear_spin_from_Z_and_A ( Z, A):
	'''
	 * Returns nuclear spin from Z and A
	 * @param[in]  Z              atomic number
	 * @param[in]  A              mass number
	 * @return     nuclear spin
	'''
	c_A = ctypes.c_long(A)
	c_Z = ctypes.c_long(Z)
	c_function =  libamtrack.AT_nuclear_spin_from_Z_and_A
	c_function.restype = ctypes.c_double
	c_output = c_function( c_Z, c_A)
	return c_output


def AT_particle_name_from_particle_no_single ( particle_no, particle_name):
	'''
	 * Returns particle index name for given particle index number
	 * @param[in]  particle_no    particle index number
	 * @param[out] particle_name  corresponding particle name
	 * @return status
	'''
	c_particle_name =  ctypes.byref(ctypes.c_char(particle_name))

	c_particle_no = ctypes.c_long(particle_no)
	c_function =  libamtrack.AT_particle_name_from_particle_no_single
	c_function.restype = ctypes.c_int
	c_output = c_function( c_particle_no, c_particle_name)
	return c_output,  c_particle_name._obj.value


def AT_particle_no_from_particle_name_single ( particle_name):
	'''
	 * Returns particle index number for given particle name
	 * @param[in]  particle_name particle index name (array of size PARTICLE_NAME_NCHAR)
	 * @return corresponding particle number
	'''
	c_particle_name = ctypes.c_char_p(particle_name)

	c_function =  libamtrack.AT_particle_no_from_particle_name_single
	c_function.restype = ctypes.c_long
	c_output = c_function( c_particle_name)
	return c_output


def AT_particle_name_from_particle_no ( n, particle_no, particle_name):
	'''
	 * Returns particle index numbers for given particle names
	 * @param[in]  n             TODO
	 * @param[in]  particle_no   particle index numbers (array of size n)
	 * @param[out] particle_name corresponding particle names
	 * @return status
	'''
	c_particle_name =  ctypes.byref((particle_name))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_particle_name_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_particle_name)
	return c_output,  c_particle_name._obj.value


def AT_particle_no_from_particle_name ( n, particle_name, corresponding):
	'''
	 * Returns particle names for given particle numbers
	 * @param[in]  n              TODO
	 * @param[in]  particle_name  particle names
	 * @param[out] corresponding  particle numbers
	 * @return status
	'''
	c_particle_name = ctypes.c_char_p(particle_name)

	c_corresponding =  ctypes.byref((corresponding))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_particle_no_from_particle_name
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_name, c_corresponding)
	return c_output,  c_corresponding._obj.value


def AT_Z_from_element_acronym_single ( acronym):
	'''
	 * Returns Z for given elemental symbol
	 * @param[in]  acronym        elemental symbols (array of size PARTICLE_NAME_NCHAR)
	 * @return corresponding Z
	'''
	c_acronym = ctypes.c_char_p(acronym)

	c_function =  libamtrack.AT_Z_from_element_acronym_single
	c_function.restype = ctypes.c_int
	c_output = c_function( c_acronym)
	return c_output


def AT_Z_from_element_acronym ( n, acronym, Z):
	'''
	 * Returns Z for given elemental symbols
	 * @param[in]  n       number of elements
	 * @param[in]  acronym elemental symbols (array of size n)
	 * @param[out] Z       corresponding Z (array of size n)
	 * @return status
	'''
	c_acronym = ctypes.c_char_p(acronym)

	tmp_array = (ctypes.c_long*n)()
	c_Z= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_Z_from_element_acronym
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_acronym, c_Z)
	return c_output,  c_Z._obj


def AT_element_acronym_from_Z_single ( Z, acronym):
	'''
	 * Returns elemental symbol for given Z
	 * @param[in]  Z      atomic number
	 * @param[out] acronym  corresponding elemental symbol (array of size PARTICLE_NAME_NCHAR)
	 * return status
	'''
	tmp_array = (ctypes.c_char*PARTICLE_NAME_NCHAR)()
	c_acronym= ctypes.byref(tmp_array)

	c_Z = ctypes.c_long(Z)
	c_function =  libamtrack.AT_element_acronym_from_Z_single
	c_output = c_function( c_Z, c_acronym)
	return c_output,  c_acronym._obj


def AT_element_acronym_from_Z ( n, Z, acronym):
	'''
	 * Returns elemental symbols for given Z
	 * @param[in]  n       number of elements
	 * @param[in]  Z       atomic numbers (array of size n)
	 * @param[out] acronym corresponding elemental symbols (array of size n)
	 * @return status
	'''
	tmp_array = (ctypes.c_char*n)()
	c_acronym= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_element_acronym_from_Z
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_Z, c_acronym)
	return c_output,  c_acronym._obj


def AT_atomic_weight_from_element_acronym_single ( acronym):
	'''
	 * Returns atomic weight for given elemental symbol
	 * @param[in]  acronym   elemental symbols (array of size PARTICLE_NAME_NCHAR)
	 * @return corresponding atomic weight
	'''
	c_acronym = ctypes.c_char_p(acronym)

	c_function =  libamtrack.AT_atomic_weight_from_element_acronym_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_acronym)
	return c_output


def AT_atomic_weight_from_element_acronym ( n, acronym, atomic_weight):
	'''
	 * Returns atomic weight for given elemental symbols
	 * @param[in]  n               number of elements in array
	 * @param[in]  acronym         elemental symbols (array of size n)
	 * @param[out] atomic_weight   corresponding A (array of size n)
	 * @return status
	'''
	c_acronym = ctypes.c_char_p(acronym)

	tmp_array = (ctypes.c_double*n)()
	c_atomic_weight= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_atomic_weight_from_element_acronym
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_acronym, c_atomic_weight)
	return c_output,  c_atomic_weight._obj


def AT_density_g_cm3_from_element_acronym_single ( acronym):
	'''
	 * Returns the elemental density in g/cm3 for given elemental symbol
	 * @param[in]  acronym   elemental symbols (array of size PARTICLE_NAME_NCHAR)
	 * @return elemental density in g/cm3
	'''
	c_acronym = ctypes.c_char_p(acronym)

	c_function =  libamtrack.AT_density_g_cm3_from_element_acronym_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_acronym)
	return c_output


def AT_density_g_cm3_from_element_acronym ( n, acronym, density):
	'''
	 * Returns the elemental densities in g/cm3 for given elemental symbols
	 * @param[in]  n        number of elements in array
	 * @param[in]  acronym  elemental symbols (array of size n)
	 * @param[out] density  corresponding elemental densities in g/cm3 (array of size n)
	 * @return status
	'''
	c_acronym = ctypes.c_char_p(acronym)

	tmp_array = (ctypes.c_double*n)()
	c_density= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_density_g_cm3_from_element_acronym
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_acronym, c_density)
	return c_output,  c_density._obj


def AT_I_eV_from_element_acronym_single ( acronym):
	'''
	 * Returns the I value in eV for given elemental symbol
	 * @param[in]  acronym  elemental symbol (array of size PARTICLE_NAME_NCHAR)
	 * @return corresponding I value in eV
	'''
	c_acronym = ctypes.c_char_p(acronym)

	c_function =  libamtrack.AT_I_eV_from_element_acronym_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_acronym)
	return c_output


def AT_I_eV_from_element_acronym ( n, acronym, I):
	'''
	 * Returns the I values in eV for given elemental symbol
	 * @param[in]  n        number of elements in array
	 * @param[in]  acronym  elemental symbols (array of size n)
	 * @param[out] I        corresponding I values in eV (array of size n)
	 * @return status
	'''
	c_acronym = ctypes.c_char_p(acronym)

	tmp_array = (ctypes.c_double*n)()
	c_I= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_I_eV_from_element_acronym
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_acronym, c_I)
	return c_output,  c_I._obj


def AT_electron_density_cm3_from_element_acronym_single ( acronym):
	'''
	 * Returns the electron density per cm3 for given elemental symbol
	 * @param[in]   acronym  elemental symbol (array of size PARTICLE_NAME_NCHAR)
	 * @return      corresponding electron density per cm3
	'''
	c_acronym = ctypes.c_char_p(acronym)

	c_function =  libamtrack.AT_electron_density_cm3_from_element_acronym_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_acronym)
	return c_output


def AT_electron_density_cm3_from_element_acronym ( n, acronym, electron_density):
	'''
	 * Returns the electron densities per cm3 for given elemental symbols
	 * @param[in]  n                       array length
	 * @param[in]  acronym                 elemental symbols (array of size n)
	 * @param[out] electron_density        corresponding electron densities per cm3 (array of size n)
	 * @return status
	'''
	c_acronym = ctypes.c_char_p(acronym)

	tmp_array = (ctypes.c_double*n)()
	c_electron_density= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_electron_density_cm3_from_element_acronym
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_acronym, c_electron_density)
	return c_output,  c_electron_density._obj


def AT_get_error_msg ( error_no, error_message):
	'''
	 * TODO
	 * @param[in] error_no
	 * @param[out] error_message
	 * @return
	'''
	c_error_no = ctypes.c_int(error_no)
	c_error_message =  ctypes.byref(ctypes.c_char(error_message))

	c_function =  libamtrack.AT_get_error_msg
	c_function.restype = ctypes.c_int
	c_output = c_function( c_error_no, c_error_message)
	return c_output,  c_error_message._obj.value


def AT_check_energy_range_single_particle ( E_MeV_u, purpose_energy_range):
	'''
	 * TODO
	 * @param[in] E_MeV_u
	 * @param[in] purpose_energy_range
	 * @return
	'''
	c_purpose_energy_range = ctypes.c_int(purpose_energy_range)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_check_energy_range_single_particle
	c_function.restype = ctypes.c_int
	c_output = c_function( c_E_MeV_u, c_purpose_energy_range)
	return c_output


def AT_check_energy_range_single_field ( n, E_MeV_u, purpose_energy_range):
	'''
	 * TODO
	 * @param[in] n
	 * @param[in] E_MeV_u (array of size n)
	 * @param[in] purpose_energy_range
	 * @return
	'''
	c_purpose_energy_range = ctypes.c_int(purpose_energy_range)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_check_energy_range_single_field
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_purpose_energy_range)
	return c_output


def AT_check_particle_no_single_particle ( particle_no):
	'''
	 * TODO
	 * @param[in] particle_no
	 * @return
	'''
	c_particle_no = ctypes.c_long(particle_no)
	c_function =  libamtrack.AT_check_particle_no_single_particle
	c_function.restype = ctypes.c_int
	c_output = c_function( c_particle_no)
	return c_output


def AT_check_particle_no_single_field ( n, particle_no):
	'''
	 * TODO
	 * @param[in] n
	 * @param[in] particle_no (array of size n)
	 * @return
	'''
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_check_particle_no_single_field
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no)
	return c_output


def AT_histo_linear_left_limit ( number_of_bins, lowest_left_limit, step, bin_no, left_limit):
	'''
	 * Returns left limit of bin with given index number for linear histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] left_limit            left limit of bin
	 * @return     status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_left_limit =  ctypes.byref(ctypes.c_double(left_limit))

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_linear_left_limit
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_left_limit)
	return c_output,  c_left_limit._obj.value


def AT_histo_logarithmic_left_limit ( number_of_bins, lowest_left_limit, step, bin_no, left_limit):
	'''
	 * Returns left limit of bin with given index number for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] left_limit            left limit of bin
	 * @return     status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_left_limit =  ctypes.byref(ctypes.c_double(left_limit))

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_logarithmic_left_limit
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_left_limit)
	return c_output,  c_left_limit._obj.value


def AT_histo_left_limit ( number_of_bins, lowest_left_limit, step, bin_no, histo_type, left_limit):
	'''
	 * Returns left limit of bin with given index number
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[in]  histo_type            type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] left_limit            left limit of bin
	 * @return                      status code
	'''
	c_left_limit =  ctypes.byref(ctypes.c_double(left_limit))

	c_bin_no = ctypes.c_long(bin_no)
	c_step = ctypes.c_double(step)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_left_limit
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_histo_type, c_left_limit)
	return c_output,  c_left_limit._obj.value


def AT_histo_left_limits ( number_of_bins, lowest_left_limit, step, histo_type, left_limits):
	'''
	 * Returns vector with all left limits of a histogram
	 * @param[in] number_of_bins            number of bins in histogram
	 * @param[in] lowest_left_limit         left limit of first bin
	 * @param[in] step                      step between bin limits
	 * @param[in] histo_type                type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] left_limits              array of bin width
	 * length number_of_bins + 1
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array = (ctypes.c_double*1)()
	c_left_limits= ctypes.byref(tmp_array)

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_left_limits
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_left_limits)
	return c_output,  c_left_limits._obj


def AT_histo_linear_bin_width ( number_of_bins, lowest_left_limit, step, bin_no):
	'''
	 * Returns width of bin with given index number for linear histograms
	 * @param[in] number_of_bins        number of bins in histogram
	 * @param[in] lowest_left_limit     left limit of first bin
	 * @param[in] step                  step between bin limits
	 * @param[in] bin_no                index number of bin (zero-based)
	 * @return                      width of bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_linear_bin_width
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no)
	return c_output


def AT_histo_logarithmic_bin_width ( number_of_bins, lowest_left_limit, step, bin_no, bin_width):
	'''
	 * Returns width of bin with given index number for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] bin_width             width of bin
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_bin_width =  ctypes.byref(ctypes.c_double(bin_width))

	c_function =  libamtrack.AT_histo_logarithmic_bin_width
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_bin_width)
	return c_output,  c_bin_width._obj.value


def AT_histo_bin_width ( number_of_bins, lowest_left_limit, step, bin_no, histo_type, bin_width):
	'''
	 * Returns width of bin with given index number
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[in] histo_type             type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] bin_width             width of bin
	 * @return status code
	'''
	c_bin_no = ctypes.c_long(bin_no)
	c_step = ctypes.c_double(step)
	c_bin_width =  ctypes.byref(ctypes.c_double(bin_width))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_bin_width
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_histo_type, c_bin_width)
	return c_output,  c_bin_width._obj.value


def AT_histo_bin_widths ( number_of_bins, lowest_left_limit, step, histo_type, bin_widths):
	'''
	 * Returns vector with all bin widths of a histogram
	 * @param[in] number_of_bins            number of bins in histogram
	 * @param[in] lowest_left_limit         left limit of first bin
	 * @param[in] step                      step between bin limits
	 * @param[in] histo_type                type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] bin_widths              array of bin width
	 * length number_of_bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	tmp_array = (ctypes.c_double*1)()
	c_bin_widths= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_histo_bin_widths
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_bin_widths)
	return c_output,  c_bin_widths._obj


def AT_histo_linear_midpoint ( number_of_bins, lowest_left_limit, step, bin_no, midpoint):
	'''
	 * Returns midpoint of bin with given index number for linear histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] midpoint              midpoint of bin
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_midpoint =  ctypes.byref(ctypes.c_double(midpoint))

	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_linear_midpoint
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_midpoint)
	return c_output,  c_midpoint._obj.value


def AT_histo_logarithmic_midpoint ( number_of_bins, lowest_left_limit, step, bin_no, midpoint):
	'''
	 * Returns midpoint of bin with given index number for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] midpoint              midpoint of bin
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_midpoint =  ctypes.byref(ctypes.c_double(midpoint))

	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_logarithmic_midpoint
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_midpoint)
	return c_output,  c_midpoint._obj.value


def AT_histo_midpoint ( number_of_bins, lowest_left_limit, step, bin_no, histo_type, midpoint):
	'''
	 * Returns midpoint of bin with given index number
	 * @param[in]  number_of_bins       number of bins in histogram
	 * @param[in]  lowest_left_limit    left limit of first bin
	 * @param[in]  step                 step between bin limits
	 * @param[in]  bin_no               index number of bin (zero-based)
	 * @param[in] histo_type            type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] midpoint             midpoint of bin
	 * @return status code
	'''
	c_midpoint =  ctypes.byref(ctypes.c_double(midpoint))

	c_bin_no = ctypes.c_long(bin_no)
	c_step = ctypes.c_double(step)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_midpoint
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_histo_type, c_midpoint)
	return c_output,  c_midpoint._obj.value


def AT_histo_midpoints ( number_of_bins, lowest_left_limit, step, histo_type, midpoints):
	'''
	 * Returns vector with all midpoints of a histogram
	 * @param[in] number_of_bins            number of bins in histogram
	 * @param[in] lowest_left_limit         left limit of first bin
	 * @param[in] step                      step between bin limits
	 * @param[in] histo_type                type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] midpoints                array of midpoints
	 * length number_of_bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	tmp_array = (ctypes.c_double*1)()
	c_midpoints= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_histo_midpoints
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_midpoints)
	return c_output,  c_midpoints._obj


def AT_histo_linear_step ( number_of_bins, lowest_left_limit, highest_left_limit, step):
	'''
	 * Returns step for given range for linear histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[out] step                  step between bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step =  ctypes.byref(ctypes.c_double(step))

	c_function =  libamtrack.AT_histo_linear_step
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_highest_left_limit, c_step)
	return c_output,  c_step._obj.value


def AT_histo_logarithmic_step ( number_of_bins, lowest_left_limit, highest_left_limit, step):
	'''
	 * Returns step for given range for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[out] step                  step between bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step =  ctypes.byref(ctypes.c_double(step))

	c_function =  libamtrack.AT_histo_logarithmic_step
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_highest_left_limit, c_step)
	return c_output,  c_step._obj.value


def AT_histo_step ( number_of_bins, lowest_left_limit, highest_left_limit, histo_type, step):
	'''
	 * Returns step for given range
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in] histo_type             type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] step                  step between bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_step =  ctypes.byref(ctypes.c_double(step))

	c_function =  libamtrack.AT_histo_step
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_highest_left_limit, c_histo_type, c_step)
	return c_output,  c_step._obj.value


def AT_histo_linear_n_bins ( lowest_left_limit, highest_left_limit, step, number_of_bins):
	'''
	 * Returns number of bins for given range for linear histograms
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in]  step                  step between bins
	 * @param[out] number_of_bins        number of bins in histogram
	 * @return status code
	'''
	c_number_of_bins =  ctypes.byref(ctypes.c_long(number_of_bins))

	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_histo_linear_n_bins
	c_function.restype = ctypes.c_int
	c_output = c_function( c_lowest_left_limit, c_highest_left_limit, c_step, c_number_of_bins)
	return c_output,  c_number_of_bins._obj.value


def AT_histo_logarithmic_n_bins ( lowest_left_limit, highest_left_limit, step, number_of_bins):
	'''
	 * Returns number of bins for given range for logarithmic histograms
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in]  step                  step between bins
	 * @param[out] number_of_bins        number of bins in histogram
	 * @return status code
	'''
	c_number_of_bins =  ctypes.byref(ctypes.c_long(number_of_bins))

	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_histo_logarithmic_n_bins
	c_function.restype = ctypes.c_int
	c_output = c_function( c_lowest_left_limit, c_highest_left_limit, c_step, c_number_of_bins)
	return c_output,  c_number_of_bins._obj.value


def AT_histo_n_bins ( lowest_left_limit, highest_left_limit, step, histo_type, number_of_bins):
	'''
	 * Returns number of bins for given range for logarithmic histograms
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in]  step                  step between bins
	 * @param[in] histo_type             type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] number_of_bins        number of bins in histogram
	 * @return status code
	'''
	c_number_of_bins =  ctypes.byref(ctypes.c_long(number_of_bins))

	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_histo_n_bins
	c_function.restype = ctypes.c_int
	c_output = c_function( c_lowest_left_limit, c_highest_left_limit, c_step, c_histo_type, c_number_of_bins)
	return c_output,  c_number_of_bins._obj.value


def AT_histo_linear_bin_no ( number_of_bins, lowest_left_limit, step, value):
	'''
	 * Returns bin index number for a given value for linear histograms
	 * @param[in] number_of_bins        number of bins in histogram
	 * @param[in] lowest_left_limit     left limit of first bin
	 * @param[in] step                  step between bin limits
	 * @param[in] value                 value
	 * @return                      bin index number (zero-based, positive), -1 if value below first, -2 if value above last bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_value = ctypes.c_double(value)
	c_function =  libamtrack.AT_histo_linear_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_value)
	return c_output


def AT_histo_logarithmic_bin_no ( number_of_bins, lowest_left_limit, step, value):
	'''
	 * Returns bin index number for a given value for logarithmic histograms
	 * @param[in] number_of_bins        number of bins in histogram
	 * @param[in] lowest_left_limit     left limit of first bin
	 * @param[in] step                  step between bin limits
	 * @param[in] value                 value
	 * @return                      bin index number (zero-based, positive), -1 if value below first, -2 if value above last bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_value = ctypes.c_double(value)
	c_function =  libamtrack.AT_histo_logarithmic_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_value)
	return c_output


def AT_histo_bin_no ( number_of_bins, lowest_left_limit, step, histo_type, value):
	'''
	 * Returns bin index number for a given value for logarithmic histograms
	 * @param[in] number_of_bins      number of bins in histogram
	 * @param[in] lowest_left_limit   left limit of first bin
	 * @param[in] step                step between bin limits
	 * @param[in] histo_type          type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[in] value               value
	 * @return                        bin index number (zero-based, positive), -1 if value below first, -2 if value above last bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_value = ctypes.c_double(value)
	c_function =  libamtrack.AT_histo_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_value)
	return c_output


def AT_histo_add_single ( number_of_bins, lowest_left_limit, step, histo_type, value, weight, frequency):
	'''
	 * Increases bin frequency content by \'weight\' for a given value
	 * @param[in] number_of_bins       number of bins in histogram
	 * @param[in] lowest_left_limit    left limit of first bin
	 * @param[in] step                 step between bin limits
	 * @param[in] histo_type           type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[in] value                value
	 * @param[in] weight               weight by which the bin frequency content for \'value\' is increase (usually 1)
	 * @param[in,out] frequency        vector of frequencies for the histogram (array of number_of_bins)
	'''
	c_weight = ctypes.c_double(weight)
	c_value = ctypes.c_double(value)
	c_step = ctypes.c_double(step)
	tmp_array =ctypes.c_double* len(frequency)
	c_frequency = ctypes.byref(tmp_array(*frequency))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_add_single
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_value, c_weight, c_frequency)
	return c_output


def AT_histo_add_multi ( number_of_bins, lowest_left_limit, step, histo_type, n_values, value, weight, frequency):
	'''
	 * Add an array of values with individual weight to histogram
	 * TODO: optimize routine, now histotype is checked unnecessarily often
	 * @param[in] number_of_bins       number of bins in histogram
	 * @param[in] lowest_left_limit    left limit of first bin
	 * @param[in] step                 step between bin limits
	 * @param[in] histo_type           type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[in] n_values             number of values given
	 * @param[in] value                values (array of size number_of_values)
	 * @param[in] weight               weights by which the bin frequency content for \'value\' is increase (array of size number_of_values)
	 * @param[in,out] frequency        vector of frequencies for the histogram (array of size number_of_bins)
	'''
	tmp_array =ctypes.c_double* len(weight)
	c_weight = ctypes.byref(tmp_array(*weight))

	tmp_array =ctypes.c_double* len(value)
	c_value = ctypes.byref(tmp_array(*value))

	c_n_values = ctypes.c_long(n_values)
	c_step = ctypes.c_double(step)
	tmp_array =ctypes.c_double* len(frequency)
	c_frequency = ctypes.byref(tmp_array(*frequency))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_add_multi
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_n_values, c_value, c_weight, c_frequency)
	return c_output


def AT_histo_sum ( number_of_bins, lowest_left_limit, step, histo_type, frequency, sum):
	'''
	 * TODO
	 * @param[in] number_of_bins
	 * @param[in] lowest_left_limit
	 * @param[in] step
	 * @param[in] histo_type
	 * @param[in] frequency (array of size number_of_bins)
	 * @param[out] sum
	'''
	c_sum =  ctypes.byref(ctypes.c_double(sum))

	c_step = ctypes.c_double(step)
	tmp_array =ctypes.c_double* len(frequency)
	c_frequency = ctypes.byref(tmp_array(*frequency))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_sum
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_frequency, c_sum)
	return c_output,  c_sum._obj.value


def AT_histo_normalize ( number_of_bins, lowest_left_limit, step, histo_type, frequency):
	'''
	 * TODO
	 * @param[in] number_of_bins
	 * @param[in] lowest_left_limit
	 * @param[in] step
	 * @param[in] histo_type
	 * @param[out] frequency  (array of size number_of_bins)
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array = (ctypes.c_double*number_of_bins)()
	c_frequency= ctypes.byref(tmp_array)

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_normalize
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_frequency)
	return c_output,  c_frequency._obj


def AT_N2_to_step ( N2):
	'''
	 * TODO
	 * @param[in] N2
	 * @return step
	'''
	c_N2 = ctypes.c_double(N2)
	c_function =  libamtrack.AT_N2_to_step
	c_function.restype = ctypes.c_double
	c_output = c_function( c_N2)
	return c_output


def AT_step_to_N2 ( step):
	'''
	 * TODO
	 * @param[in] step
	 * @return N2
	'''
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_step_to_N2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_step)
	return c_output


def AT_histoOld_log_bin_width ( number_of_bins, bin_centers):
	'''
	 * Returns bin width
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @return bin_width
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_log_bin_width
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers)
	return c_output


def AT_histoOld_lower_bin_limit ( number_of_bins, bin_centers, bin_no):
	'''
	 * Returns lower bin limit for single bin
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] bin_no                       index of bin (zero based)
	 * @return lower_left_limit
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_bin_no = ctypes.c_long(bin_no)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_lower_bin_limit
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_no)
	return c_output


def AT_histoOld_upper_bin_limit ( number_of_bins, bin_centers, bin_no):
	'''
	 * Returns lower bin limit for single bin
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] bin_no                       index of bin (zero based)
	 * @return upper_left_limit
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_bin_no = ctypes.c_long(bin_no)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_upper_bin_limit
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_no)
	return c_output


def AT_histoOld_get_bin_width ( number_of_bins, bin_centers, bin_no):
	'''
	 * Returns bin width for single bin
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] bin_no                       index of bin (zero based)
	 * @return bin width
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_bin_no = ctypes.c_long(bin_no)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_get_bin_width
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_no)
	return c_output


def AT_histoOld_get_bin_widths ( number_of_bins, bin_centers, bin_widths):
	'''
	 * Returns bin widths
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[out] bin_widths                  resulting bin widths (array of size number_of_bins)
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array = (ctypes.c_double*number_of_bins)()
	c_bin_widths= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_get_bin_widths
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_widths)
	return c_output,  c_bin_widths._obj


def AT_histoOld_bin_no ( number_of_bins, bin_centers, value):
	'''
	 * Returns bin index number for a value
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] value                        value to put into histogram
	 * @return bin_no
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_value = ctypes.c_double(value)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_bin_centers, c_value)
	return c_output


def AT_histo_linear_left_limit ( number_of_bins, lowest_left_limit, step, bin_no, left_limit):
	'''
	 * Returns left limit of bin with given index number for linear histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] left_limit            left limit of bin
	 * @return     status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_left_limit =  ctypes.byref(ctypes.c_double(left_limit))

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_linear_left_limit
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_left_limit)
	return c_output,  c_left_limit._obj.value


def AT_histo_logarithmic_left_limit ( number_of_bins, lowest_left_limit, step, bin_no, left_limit):
	'''
	 * Returns left limit of bin with given index number for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] left_limit            left limit of bin
	 * @return     status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_left_limit =  ctypes.byref(ctypes.c_double(left_limit))

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_logarithmic_left_limit
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_left_limit)
	return c_output,  c_left_limit._obj.value


def AT_histo_left_limit ( number_of_bins, lowest_left_limit, step, bin_no, histo_type, left_limit):
	'''
	 * Returns left limit of bin with given index number
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[in]  histo_type            type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] left_limit            left limit of bin
	 * @return                      status code
	'''
	c_left_limit =  ctypes.byref(ctypes.c_double(left_limit))

	c_bin_no = ctypes.c_long(bin_no)
	c_step = ctypes.c_double(step)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_left_limit
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_histo_type, c_left_limit)
	return c_output,  c_left_limit._obj.value


def AT_histo_left_limits ( number_of_bins, lowest_left_limit, step, histo_type, left_limits):
	'''
	 * Returns vector with all left limits of a histogram
	 * @param[in] number_of_bins            number of bins in histogram
	 * @param[in] lowest_left_limit         left limit of first bin
	 * @param[in] step                      step between bin limits
	 * @param[in] histo_type                type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] left_limits              array of bin width
	 * length number_of_bins + 1
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array = (ctypes.c_double*1)()
	c_left_limits= ctypes.byref(tmp_array)

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_left_limits
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_left_limits)
	return c_output,  c_left_limits._obj


def AT_histo_linear_bin_width ( number_of_bins, lowest_left_limit, step, bin_no):
	'''
	 * Returns width of bin with given index number for linear histograms
	 * @param[in] number_of_bins        number of bins in histogram
	 * @param[in] lowest_left_limit     left limit of first bin
	 * @param[in] step                  step between bin limits
	 * @param[in] bin_no                index number of bin (zero-based)
	 * @return                      width of bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_linear_bin_width
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no)
	return c_output


def AT_histo_logarithmic_bin_width ( number_of_bins, lowest_left_limit, step, bin_no, bin_width):
	'''
	 * Returns width of bin with given index number for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] bin_width             width of bin
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_bin_no = ctypes.c_long(bin_no)
	c_bin_width =  ctypes.byref(ctypes.c_double(bin_width))

	c_function =  libamtrack.AT_histo_logarithmic_bin_width
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_bin_width)
	return c_output,  c_bin_width._obj.value


def AT_histo_bin_width ( number_of_bins, lowest_left_limit, step, bin_no, histo_type, bin_width):
	'''
	 * Returns width of bin with given index number
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[in] histo_type             type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] bin_width             width of bin
	 * @return status code
	'''
	c_bin_no = ctypes.c_long(bin_no)
	c_step = ctypes.c_double(step)
	c_bin_width =  ctypes.byref(ctypes.c_double(bin_width))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_bin_width
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_histo_type, c_bin_width)
	return c_output,  c_bin_width._obj.value


def AT_histo_bin_widths ( number_of_bins, lowest_left_limit, step, histo_type, bin_widths):
	'''
	 * Returns vector with all bin widths of a histogram
	 * @param[in] number_of_bins            number of bins in histogram
	 * @param[in] lowest_left_limit         left limit of first bin
	 * @param[in] step                      step between bin limits
	 * @param[in] histo_type                type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] bin_widths              array of bin width
	 * length number_of_bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	tmp_array = (ctypes.c_double*1)()
	c_bin_widths= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_histo_bin_widths
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_bin_widths)
	return c_output,  c_bin_widths._obj


def AT_histo_linear_midpoint ( number_of_bins, lowest_left_limit, step, bin_no, midpoint):
	'''
	 * Returns midpoint of bin with given index number for linear histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] midpoint              midpoint of bin
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_midpoint =  ctypes.byref(ctypes.c_double(midpoint))

	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_linear_midpoint
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_midpoint)
	return c_output,  c_midpoint._obj.value


def AT_histo_logarithmic_midpoint ( number_of_bins, lowest_left_limit, step, bin_no, midpoint):
	'''
	 * Returns midpoint of bin with given index number for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  step                  step between bin limits
	 * @param[in]  bin_no                index number of bin (zero-based)
	 * @param[out] midpoint              midpoint of bin
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_midpoint =  ctypes.byref(ctypes.c_double(midpoint))

	c_bin_no = ctypes.c_long(bin_no)
	c_function =  libamtrack.AT_histo_logarithmic_midpoint
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_midpoint)
	return c_output,  c_midpoint._obj.value


def AT_histo_midpoint ( number_of_bins, lowest_left_limit, step, bin_no, histo_type, midpoint):
	'''
	 * Returns midpoint of bin with given index number
	 * @param[in]  number_of_bins       number of bins in histogram
	 * @param[in]  lowest_left_limit    left limit of first bin
	 * @param[in]  step                 step between bin limits
	 * @param[in]  bin_no               index number of bin (zero-based)
	 * @param[in] histo_type            type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] midpoint             midpoint of bin
	 * @return status code
	'''
	c_midpoint =  ctypes.byref(ctypes.c_double(midpoint))

	c_bin_no = ctypes.c_long(bin_no)
	c_step = ctypes.c_double(step)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_midpoint
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_bin_no, c_histo_type, c_midpoint)
	return c_output,  c_midpoint._obj.value


def AT_histo_midpoints ( number_of_bins, lowest_left_limit, step, histo_type, midpoints):
	'''
	 * Returns vector with all midpoints of a histogram
	 * @param[in] number_of_bins            number of bins in histogram
	 * @param[in] lowest_left_limit         left limit of first bin
	 * @param[in] step                      step between bin limits
	 * @param[in] histo_type                type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] midpoints                array of midpoints
	 * length number_of_bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	tmp_array = (ctypes.c_double*1)()
	c_midpoints= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_histo_midpoints
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_midpoints)
	return c_output,  c_midpoints._obj


def AT_histo_linear_step ( number_of_bins, lowest_left_limit, highest_left_limit, step):
	'''
	 * Returns step for given range for linear histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[out] step                  step between bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step =  ctypes.byref(ctypes.c_double(step))

	c_function =  libamtrack.AT_histo_linear_step
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_highest_left_limit, c_step)
	return c_output,  c_step._obj.value


def AT_histo_logarithmic_step ( number_of_bins, lowest_left_limit, highest_left_limit, step):
	'''
	 * Returns step for given range for logarithmic histograms
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[out] step                  step between bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step =  ctypes.byref(ctypes.c_double(step))

	c_function =  libamtrack.AT_histo_logarithmic_step
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_highest_left_limit, c_step)
	return c_output,  c_step._obj.value


def AT_histo_step ( number_of_bins, lowest_left_limit, highest_left_limit, histo_type, step):
	'''
	 * Returns step for given range
	 * @param[in]  number_of_bins        number of bins in histogram
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in] histo_type             type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] step                  step between bins
	 * @return status code
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_step =  ctypes.byref(ctypes.c_double(step))

	c_function =  libamtrack.AT_histo_step
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_highest_left_limit, c_histo_type, c_step)
	return c_output,  c_step._obj.value


def AT_histo_linear_n_bins ( lowest_left_limit, highest_left_limit, step, number_of_bins):
	'''
	 * Returns number of bins for given range for linear histograms
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in]  step                  step between bins
	 * @param[out] number_of_bins        number of bins in histogram
	 * @return status code
	'''
	c_number_of_bins =  ctypes.byref(ctypes.c_long(number_of_bins))

	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_histo_linear_n_bins
	c_function.restype = ctypes.c_int
	c_output = c_function( c_lowest_left_limit, c_highest_left_limit, c_step, c_number_of_bins)
	return c_output,  c_number_of_bins._obj.value


def AT_histo_logarithmic_n_bins ( lowest_left_limit, highest_left_limit, step, number_of_bins):
	'''
	 * Returns number of bins for given range for logarithmic histograms
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in]  step                  step between bins
	 * @param[out] number_of_bins        number of bins in histogram
	 * @return status code
	'''
	c_number_of_bins =  ctypes.byref(ctypes.c_long(number_of_bins))

	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_histo_logarithmic_n_bins
	c_function.restype = ctypes.c_int
	c_output = c_function( c_lowest_left_limit, c_highest_left_limit, c_step, c_number_of_bins)
	return c_output,  c_number_of_bins._obj.value


def AT_histo_n_bins ( lowest_left_limit, highest_left_limit, step, histo_type, number_of_bins):
	'''
	 * Returns number of bins for given range for logarithmic histograms
	 * @param[in]  lowest_left_limit     left limit of first bin
	 * @param[in]  highest_left_limit    right (exclusive) limit of last bin
	 * @param[in]  step                  step between bins
	 * @param[in] histo_type             type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[out] number_of_bins        number of bins in histogram
	 * @return status code
	'''
	c_number_of_bins =  ctypes.byref(ctypes.c_long(number_of_bins))

	c_highest_left_limit = ctypes.c_double(highest_left_limit)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_histo_n_bins
	c_function.restype = ctypes.c_int
	c_output = c_function( c_lowest_left_limit, c_highest_left_limit, c_step, c_histo_type, c_number_of_bins)
	return c_output,  c_number_of_bins._obj.value


def AT_histo_linear_bin_no ( number_of_bins, lowest_left_limit, step, value):
	'''
	 * Returns bin index number for a given value for linear histograms
	 * @param[in] number_of_bins        number of bins in histogram
	 * @param[in] lowest_left_limit     left limit of first bin
	 * @param[in] step                  step between bin limits
	 * @param[in] value                 value
	 * @return                      bin index number (zero-based, positive), -1 if value below first, -2 if value above last bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_value = ctypes.c_double(value)
	c_function =  libamtrack.AT_histo_linear_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_value)
	return c_output


def AT_histo_logarithmic_bin_no ( number_of_bins, lowest_left_limit, step, value):
	'''
	 * Returns bin index number for a given value for logarithmic histograms
	 * @param[in] number_of_bins        number of bins in histogram
	 * @param[in] lowest_left_limit     left limit of first bin
	 * @param[in] step                  step between bin limits
	 * @param[in] value                 value
	 * @return                      bin index number (zero-based, positive), -1 if value below first, -2 if value above last bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_value = ctypes.c_double(value)
	c_function =  libamtrack.AT_histo_logarithmic_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_value)
	return c_output


def AT_histo_bin_no ( number_of_bins, lowest_left_limit, step, histo_type, value):
	'''
	 * Returns bin index number for a given value for logarithmic histograms
	 * @param[in] number_of_bins      number of bins in histogram
	 * @param[in] lowest_left_limit   left limit of first bin
	 * @param[in] step                step between bin limits
	 * @param[in] histo_type          type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[in] value               value
	 * @return                        bin index number (zero-based, positive), -1 if value below first, -2 if value above last bin
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_value = ctypes.c_double(value)
	c_function =  libamtrack.AT_histo_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_value)
	return c_output


def AT_histo_add_single ( number_of_bins, lowest_left_limit, step, histo_type, value, weight, frequency):
	'''
	 * Increases bin frequency content by \'weight\' for a given value
	 * @param[in] number_of_bins       number of bins in histogram
	 * @param[in] lowest_left_limit    left limit of first bin
	 * @param[in] step                 step between bin limits
	 * @param[in] histo_type           type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[in] value                value
	 * @param[in] weight               weight by which the bin frequency content for \'value\' is increase (usually 1)
	 * @param[in,out] frequency        vector of frequencies for the histogram (array of number_of_bins)
	'''
	c_weight = ctypes.c_double(weight)
	c_value = ctypes.c_double(value)
	c_step = ctypes.c_double(step)
	tmp_array =ctypes.c_double* len(frequency)
	c_frequency = ctypes.byref(tmp_array(*frequency))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_add_single
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_value, c_weight, c_frequency)
	return c_output


def AT_histo_add_multi ( number_of_bins, lowest_left_limit, step, histo_type, n_values, value, weight, frequency):
	'''
	 * Add an array of values with individual weight to histogram
	 * TODO: optimize routine, now histotype is checked unnecessarily often
	 * @param[in] number_of_bins       number of bins in histogram
	 * @param[in] lowest_left_limit    left limit of first bin
	 * @param[in] step                 step between bin limits
	 * @param[in] histo_type           type of histogram (linear or logarithmic)
	 * @see AT_histo_type
	 * @param[in] n_values             number of values given
	 * @param[in] value                values (array of size number_of_values)
	 * @param[in] weight               weights by which the bin frequency content for \'value\' is increase (array of size number_of_values)
	 * @param[in,out] frequency        vector of frequencies for the histogram (array of size number_of_bins)
	'''
	tmp_array =ctypes.c_double* len(weight)
	c_weight = ctypes.byref(tmp_array(*weight))

	tmp_array =ctypes.c_double* len(value)
	c_value = ctypes.byref(tmp_array(*value))

	c_n_values = ctypes.c_long(n_values)
	c_step = ctypes.c_double(step)
	tmp_array =ctypes.c_double* len(frequency)
	c_frequency = ctypes.byref(tmp_array(*frequency))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_add_multi
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_n_values, c_value, c_weight, c_frequency)
	return c_output


def AT_histo_sum ( number_of_bins, lowest_left_limit, step, histo_type, frequency, sum):
	'''
	 * TODO
	 * @param[in] number_of_bins
	 * @param[in] lowest_left_limit
	 * @param[in] step
	 * @param[in] histo_type
	 * @param[in] frequency (array of size number_of_bins)
	 * @param[out] sum
	'''
	c_sum =  ctypes.byref(ctypes.c_double(sum))

	c_step = ctypes.c_double(step)
	tmp_array =ctypes.c_double* len(frequency)
	c_frequency = ctypes.byref(tmp_array(*frequency))

	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_sum
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_frequency, c_sum)
	return c_output,  c_sum._obj.value


def AT_histo_normalize ( number_of_bins, lowest_left_limit, step, histo_type, frequency):
	'''
	 * TODO
	 * @param[in] number_of_bins
	 * @param[in] lowest_left_limit
	 * @param[in] step
	 * @param[in] histo_type
	 * @param[out] frequency  (array of size number_of_bins)
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array = (ctypes.c_double*number_of_bins)()
	c_frequency= ctypes.byref(tmp_array)

	c_step = ctypes.c_double(step)
	c_lowest_left_limit = ctypes.c_double(lowest_left_limit)
	c_histo_type = ctypes.c_long(histo_type)
	c_function =  libamtrack.AT_histo_normalize
	c_output = c_function( c_number_of_bins, c_lowest_left_limit, c_step, c_histo_type, c_frequency)
	return c_output,  c_frequency._obj


def AT_N2_to_step ( N2):
	'''
	 * TODO
	 * @param[in] N2
	 * @return step
	'''
	c_N2 = ctypes.c_double(N2)
	c_function =  libamtrack.AT_N2_to_step
	c_function.restype = ctypes.c_double
	c_output = c_function( c_N2)
	return c_output


def AT_step_to_N2 ( step):
	'''
	 * TODO
	 * @param[in] step
	 * @return N2
	'''
	c_step = ctypes.c_double(step)
	c_function =  libamtrack.AT_step_to_N2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_step)
	return c_output


def AT_histoOld_log_bin_width ( number_of_bins, bin_centers):
	'''
	 * Returns bin width
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @return bin_width
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_log_bin_width
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers)
	return c_output


def AT_histoOld_lower_bin_limit ( number_of_bins, bin_centers, bin_no):
	'''
	 * Returns lower bin limit for single bin
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] bin_no                       index of bin (zero based)
	 * @return lower_left_limit
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_bin_no = ctypes.c_long(bin_no)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_lower_bin_limit
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_no)
	return c_output


def AT_histoOld_upper_bin_limit ( number_of_bins, bin_centers, bin_no):
	'''
	 * Returns lower bin limit for single bin
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] bin_no                       index of bin (zero based)
	 * @return upper_left_limit
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_bin_no = ctypes.c_long(bin_no)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_upper_bin_limit
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_no)
	return c_output


def AT_histoOld_get_bin_width ( number_of_bins, bin_centers, bin_no):
	'''
	 * Returns bin width for single bin
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] bin_no                       index of bin (zero based)
	 * @return bin width
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_bin_no = ctypes.c_long(bin_no)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_get_bin_width
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_no)
	return c_output


def AT_histoOld_get_bin_widths ( number_of_bins, bin_centers, bin_widths):
	'''
	 * Returns bin widths
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[out] bin_widths                  resulting bin widths (array of size number_of_bins)
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array = (ctypes.c_double*number_of_bins)()
	c_bin_widths= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_get_bin_widths
	c_output = c_function( c_number_of_bins, c_bin_centers, c_bin_widths)
	return c_output,  c_bin_widths._obj


def AT_histoOld_bin_no ( number_of_bins, bin_centers, value):
	'''
	 * Returns bin index number for a value
	 *
	 * @param[in] number_of_bins               number of bin in histogram
	 * @param[in] bin_centers                  bin centers (array of size number_of_bins)
	 * @param[in] value                        value to put into histogram
	 * @return bin_no
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_value = ctypes.c_double(value)
	tmp_array =ctypes.c_double* len(bin_centers)
	c_bin_centers = ctypes.byref(tmp_array(*bin_centers))

	c_function =  libamtrack.AT_histoOld_bin_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_number_of_bins, c_bin_centers, c_value)
	return c_output


def get_table_value ( n, x, subset_no, x_table, y_table, y):
	'''
	 * TODO find better name for this function
	 * it just finds a vector of interpolated values
	 * and is not related only to PSTAR tables
	 *
	 * @param[in]  n             number of points to interpolate
	 * @param[in]  x             array of x values for which interpolation is done
	 * @param[in]  subset_no     TODO
	 * @param[in]  x_table       x part of data table
	 * @param[in]  y_table       y part of data table
	 * @param[out] y             array of interpolated y values
	'''
	tmp_array =ctypes.c_double* len(y_table)
	c_y_table = ctypes.byref(tmp_array(*y_table))

	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(x_table)
	c_x_table = ctypes.byref(tmp_array(*x_table))

	tmp_array = (ctypes.c_double*1)()
	c_y= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(x)
	c_x = ctypes.byref(tmp_array(*x))

	c_subset_no = ctypes.c_long(subset_no)
	c_function =  libamtrack.get_table_value
	c_output = c_function( c_n, c_x, c_subset_no, c_x_table, c_y_table, c_y)
	return c_output,  c_y._obj


def AT_CSDA_range_g_cm2_single ( E_MeV_u, particle_no, material_no):
	'''
	 * Returns CSDA range (in g/cm2) from pstar tables for given energy.
	 * In case of ions a simple scaling procedure (A/Z^2) will be used (even effective charge will be neglected)
	 * @param[in]   E_MeV_u                  energy of particle
	 * @param[in]   particle_no              type of the particle
	 * @see          AT_DataParticle.h for definition
	 * @param[in]   material_no              material index
	 * @see          AT_DataMaterial.h for definition
	 * @return      CSDA_range_g_cm2         CSDA range
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_CSDA_range_g_cm2_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_CSDA_range_g_cm2 ( number_of_particles, E_MeV_u, particle_no, material_no, CSDA_range_g_cm2):
	'''
	 * Returns CSDA range (in g/cm2) from pstar tables for given energy.
	 * In case of ions a simple scaling procedure (A/Z^2) will be used (even effective charge will be neglected)
	 * @param[in]   number_of_particles      number of particle types in the mixed particle field
	 * @param[in]   E_MeV_u                  energy of particles in the mixed particle field (array of size number_of_particles)
	 * @param[in]   particle_no              type of the particles in the mixed particle field (array of size number_of_particles)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]   material_no              material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[out]  CSDA_range_g_cm2         (array of size number_of_particles) to be allocated by the user which will be used to return the results
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*number_of_particles)()
	c_CSDA_range_g_cm2= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_number_of_particles = ctypes.c_long(number_of_particles)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_CSDA_range_g_cm2
	c_output = c_function( c_number_of_particles, c_E_MeV_u, c_particle_no, c_material_no, c_CSDA_range_g_cm2)
	return c_output,  c_CSDA_range_g_cm2._obj


def AT_CSDA_range_m_single ( E_MeV_u, particle_no, material_no):
	'''
	 * Returns CSDA range (in m) from pstar tables for given energy.
	 * In case of ions a simple scaling procedure (A/Z^2) will be used (even effective charge will be neglected)
	 * @param[in]   E_MeV_u                  energy of particle
	 * @param[in]   particle_no              type of the particle
	 * @see          AT_DataParticle.h for definition
	 * @param[in]   material_no              material index
	 * @see          AT_DataMaterial.h for definition
	 * @return      CSDA_range_m             CSDA range
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_CSDA_range_m_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_CSDA_range_m ( number_of_particles, E_MeV_u, particle_no, material_no, CSDA_range_m):
	'''
	 * Returns CSDA range (in m) from pstar tables for given energy.
	 * In case of ions a simple scaling procedure (A/Z^2) will be used (even effective charge will be neglected)
	 * @param[in]   number_of_particles      number of particle types in the mixed particle field
	 * @param[in]   E_MeV_u                  energy of particles in the mixed particle field (array of size number_of_particles)
	 * @param[in]   particle_no              type of the particles in the mixed particle field (array of size number_of_particles)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]   material_no              material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[out]  CSDA_range_m            (array of size number_of_particles) to be allocated by the user which will be used to return the results
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	tmp_array = (ctypes.c_double*number_of_particles)()
	c_CSDA_range_m= ctypes.byref(tmp_array)

	c_number_of_particles = ctypes.c_long(number_of_particles)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_CSDA_range_m
	c_output = c_function( c_number_of_particles, c_E_MeV_u, c_particle_no, c_material_no, c_CSDA_range_m)
	return c_output,  c_CSDA_range_m._obj


def AT_run_CPPSC_method ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, stopping_power_source_no, rdd_model, rdd_parameters, er_model, gamma_model, gamma_parameters, N2, fluence_factor, write_output, shrink_tails, shrink_tails_under, adjust_N2, lethal_events_mode, relative_efficiency, d_check, S_HCP, S_gamma, mean_number_of_tracks_contrib, start_number_of_tracks_contrib, n_convolutions, lower_Jensen_bound, upper_Jensen_bound):
	'''
	 * Computes HCP response and relative efficiency/RBE using compound Poison processes and
	 * successive convolutions (CPP_SC, the \'SPIFF\' algorithm)
	 *
	 * @param[in]      number_of_field_components     number of components in the mixed particle field
	 * @param[in]      E_MeV_u                        particle energy for each component in the mixed particle field [MeV/u] (array of size number_of_field_components)
	 * @param[in]      particle_no                    particle type for each component in the mixed particle field (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]      fluence_cm2_or_dose_Gy         if positive, particle fluence for each component in the mixed particle field [1/cm2]; if negative, particle dose for each component in the mixed particle field [Gy] (array of size number_of_field_components)
	 * @param[in]      material_no                    index number for detector material
	 * @see AT_DataMaterial.h for definition
	 * @param[in]      stopping_power_source_no       TODO
	 * @param[in]      rdd_model                      index number for chosen radial dose distribution
	 * @param[in]      rdd_parameters                 parameters for chosen radial dose distribution (array of size 4)
	 * @see AT_RDD.h for definition
	 * @param[in]      er_model                       index number for chosen electron-range model
	 * @see AT_ElectronRange.h for definition
	 * @param[in]      gamma_model                    index number for chosen gamma response
	 * @param[in]      gamma_parameters               parameters for chosen gamma response (array of size 9)
	 * @see AT_GammaResponse.h for definition
	 * @param[in,out]  N2                             number of bins per factor of two for the dose scale of local dose histogram
	 * @param[in]      fluence_factor                 factor to scale the fluences / doses given in "fluence_cm2_or_dose_Gy" with
	 * @param[in]      write_output                   if true, a log-file is written to "SuccessiveConvolutions.txt" in the working directory
	 * @param[in]      shrink_tails                   if true, tails of the local dose distribution, contributing less than "shrink_tails_under" are cut
	 * @param[in]      shrink_tails_under             limit for tail cutting in local dose distribution
	 * @param[in]      adjust_N2                      if true, "N2" will be increase if necessary at high fluence to ensure sufficient local dose histogram resolution
	 * @param[in]      lethal_events_mode             if true, computations are done for dependent subtargets
	 * @param[out]     relative_efficiency            particle response at dose D / gamma response at dose D
	 * @param[out]     d_check                        sanity check:  total dose (in Gy) as returned by the algorithm
	 * @param[out]     S_HCP                          absolute particle response
	 * @param[out]     S_gamma                        absolute gamma response
	 * @param[out]     mean_number_of_tracks_contrib  mean number of tracks contributing to representative point
	 * @param[out]     start_number_of_tracks_contrib low fluence approximation for mean number of tracks contributing to representative point (start value for successive convolutions)
	 * @param[out]     n_convolutions                 number of convolutions performed to reach requested dose/fluence
	 * @param[out]     lower_Jensen_bound             lower bound for Jensen\'s inequity
	 * @param[out]     upper_Jensen_bound             upper bound for Jensen\'s inequity
	'''
	c_n_convolutions =  ctypes.byref(ctypes.c_long(n_convolutions))

	c_er_model = ctypes.c_long(er_model)
	c_adjust_N2 = ctypes.c_bool(adjust_N2)
	c_S_HCP =  ctypes.byref(ctypes.c_double(S_HCP))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_lethal_events_mode = ctypes.c_bool(lethal_events_mode)
	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_upper_Jensen_bound =  ctypes.byref(ctypes.c_double(upper_Jensen_bound))

	c_shrink_tails_under = ctypes.c_double(shrink_tails_under)
	c_write_output = ctypes.c_bool(write_output)
	c_gamma_model = ctypes.c_long(gamma_model)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_S_gamma =  ctypes.byref(ctypes.c_double(S_gamma))

	c_start_number_of_tracks_contrib =  ctypes.byref(ctypes.c_double(start_number_of_tracks_contrib))

	c_relative_efficiency =  ctypes.byref(ctypes.c_double(relative_efficiency))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	c_lower_Jensen_bound =  ctypes.byref(ctypes.c_double(lower_Jensen_bound))

	c_N2 = ctypes.c_long(N2)
	c_mean_number_of_tracks_contrib =  ctypes.byref(ctypes.c_double(mean_number_of_tracks_contrib))

	c_fluence_factor = ctypes.c_double(fluence_factor)
	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	c_shrink_tails = ctypes.c_bool(shrink_tails)
	c_d_check =  ctypes.byref(ctypes.c_double(d_check))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_run_CPPSC_method
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_stopping_power_source_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_model, c_gamma_parameters, c_N2, c_fluence_factor, c_write_output, c_shrink_tails, c_shrink_tails_under, c_adjust_N2, c_lethal_events_mode, c_relative_efficiency, c_d_check, c_S_HCP, c_S_gamma, c_mean_number_of_tracks_contrib, c_start_number_of_tracks_contrib, c_n_convolutions, c_lower_Jensen_bound, c_upper_Jensen_bound)
	return c_output,  c_relative_efficiency._obj.value, c_d_check._obj.value, c_S_HCP._obj.value, c_S_gamma._obj.value, c_mean_number_of_tracks_contrib._obj.value, c_start_number_of_tracks_contrib._obj.value, c_n_convolutions._obj.value, c_lower_Jensen_bound._obj.value, c_upper_Jensen_bound._obj.value


def AT_run_CPPSS_method ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, stopping_power_source_no, RDD_model, RDD_parameters, ER_model, gamma_model, gamma_parameters, n_runs, N2, fluence_factor, write_output, importance_sampling, results):
	'''
	 * Computes HCP response and RE/RBE using compound Poison process and
	 * statistical sampling (CPP_SS, the \'SPISS\' algorithm)
	 *
	 * @param[in]  number_of_field_components  number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u             energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no         type of the particles in the mixed particle field (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2_or_dose_Gy         fluences for the given particles, doses in Gy if negative (array of size number_of_field_components)
	 * @param[in]  material_no         index number for detector material
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no         TODO
	 * @param[in]  RDD_model           index number for chosen radial dose distribution
	 * @param[in]  RDD_parameters      parameters for chosen radial dose distribution (array of size 4)
	 * @see          AT_RDD.h for definition
	 * @param[in]  ER_model            index number for chosen electron-range model
	 * @see          AT_ElectronRange.h for definition
	 * @param[in]  gamma_model         index number for chosen gamma response
	 * @param[in]  gamma_parameters    parameters for chosen gamma response (array of size 9)
	 * @see          AT_GammaResponse.h for definition
	 * @param[in] n_runs               (algorithm specific) number of points sampled for local dose distribution
	 * @param[in]  N2                  (algorithm specific) number of bins per factor of two in local dose array
	 * @param[in]  fluence_factor      factor to scale the fluences given as "fluence_cm2" with
	 * @param[in]  write_output        if true, a protocol is written to "SuccessiveConvolutions.txt" in the working directory
	 * @param[in]  importance_sampling if unequal zero importance sampling will be applied to the single impact local dose distribution
	 * @param[in]  results             array of size 10 to be allocated by the user which will be used to return the results\n
	 *    results[0]    efficiency      (algorithm independent)  main result:   particle response at dose D / gamma response at dose D\n
	 *    results[1]    d_check         (algorithm independent)  sanity check:  total dose (in Gy) as returned by the algorithm\n
	 *    results[2]    S_HCP           (algorithm independent)  absolute particle response\n
	 *    results[3]    S_gamma         (algorithm independent)  absolute gamma response\n
	 *    results[4]    not used        (algorithm independent)\n
	 *    results[5]    not_used        (algorithm specific)\n
	 *    results[6]    not used        (algorithm specific)\n
	 *    results[7]    not_used        (algorithm specific)\n
	 *    results[8]    not used        (algorithm specific)\n
	 *    results[9]    not used        (algorithm specific)\n
	'''
	c_material_no = ctypes.c_long(material_no)
	c_RDD_model = ctypes.c_long(RDD_model)
	c_importance_sampling = ctypes.c_long(importance_sampling)
	c_fluence_factor = ctypes.c_double(fluence_factor)
	tmp_array =ctypes.c_double* len(results)
	c_results = ctypes.byref(tmp_array(*results))

	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	c_write_output = ctypes.c_int(write_output)
	c_gamma_model = ctypes.c_long(gamma_model)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_N2 = ctypes.c_long(N2)
	c_ER_model = ctypes.c_long(ER_model)
	c_n_runs = ctypes.c_long(n_runs)
	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	tmp_array =ctypes.c_double* len(RDD_parameters)
	c_RDD_parameters = ctypes.byref(tmp_array(*RDD_parameters))

	c_function =  libamtrack.AT_run_CPPSS_method
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_stopping_power_source_no, c_RDD_model, c_RDD_parameters, c_ER_model, c_gamma_model, c_gamma_parameters, c_n_runs, c_N2, c_fluence_factor, c_write_output, c_importance_sampling, c_results)
	return c_output


def AT_range_straggling_convolution ( z, R0, sigma, ni):
	'''
	 * Computes the convolution of a term (R0 - z)^(ni - 1) with a Gaussian
	 * in z with variance sigma^2, i.e.
	 * F(z, R0) = 1/(2*pi*sigma) * int_{-inf}^{R0}[ (R0 - z)^(ni - 1) * exp(-(z - z\')^2/(2*sigma^2)) * dz\']
	 * that can be solved using the gamma function and the parabolic cylinder function:
	 * F(z, R0) = 1/(2*pi*sigma) * exp((R0 - z)/(4*sigma^2)) * sigma^ni * gamma(ni) * D[-ni](-(R0-z)/sigma)
	 * where D[-ni] is the parabolic cylinder function of order -ni
	 *
	 * The procedure is elucidated in Bortfeld, 1997, An analytical approximation of the Bragg curve for therapeutic
	 * proton beams, Med. Phys. 24(12), 2024ff., Appendix A, Eqs. A1, A6
	 *
	 * This function uses gamma_ and AT_Dyx.
	 *
	 * Cave: Be careful to give the correct ni (not ni - 1)!
	 *
	 * @param[in]   z
	 * @param[in]   R0
	 * @param[in]   sigma
	 * @param[in]   ni
	 * @return      funs
	'''
	c_sigma = ctypes.c_double(sigma)
	c_z = ctypes.c_double(z)
	c_R0 = ctypes.c_double(R0)
	c_ni = ctypes.c_double(ni)
	c_function =  libamtrack.AT_range_straggling_convolution
	c_function.restype = ctypes.c_double
	c_output = c_function( c_z, c_R0, c_sigma, c_ni)
	return c_output


def AT_Dyx ( x, y):
	'''
	 *  Computes parabolic cylinder function Dy(x)
	 *  using subroutine pbdv
	 *  Original FORTRAN code mpbdv.f by Jianming Jin, Department of Electrical and
	 *  Computer Engineering, University of Illinois at Urbana-Champaign
	 *  http://jin.ece.uiuc.edu/routines/mpbdv.for
	 *  Converted to C using f2c (version 20060506) by
	 *  S. Greilich, reworked as subroutine for libamtrack.dll, abandoning
	 *  f2c.h and libf2c.lib, as well as computation (returning) of derivatives
	 *
	 *  @param[in]   x       argument of Dy(x)
	 *  @param[in]   y       order of Dy(x)
	 *  return  Dyx
	'''
	c_y = ctypes.c_double(y)
	c_x = ctypes.c_double(x)
	c_function =  libamtrack.AT_Dyx
	c_output = c_function( c_x, c_y)
	return c_output


def pbdv_ ( v, x, dv, dp, pdf, pdd):
	'''
	 *  Computes parabolic cylinder function Dv(x) and its derivatives
	 *  see comments for AT_Dyx
	 *  The function calls dvsa for small |x| and dvla for large |x|
	 *
	 *  @param[in]   v       order of Dv(x)
	 *  @param[in]   x       argument of Dv(x)
	 *  @param[out]  dv      DV(na) = Dn+v0(x) with na = |n|, v0 = v-n, |v0| < 1, n = 0, +/-1, +/-2, ...
	 *  @param[out]  dp      DP(na) = Dn+v0\'(x) with na = |n|, v0 = v-n, |v0| < 1, n = 0, +/-1, +/-2, ...
	 *  @param[out]  pdf     Dv(x)
	 *  @param[out]  pdd     Dv\'(x)
	'''
	c_v = ctypes.c_double(v)
	c_pdf =  ctypes.byref(ctypes.c_double(pdf))

	c_dv =  ctypes.byref(ctypes.c_double(dv))

	c_x = ctypes.c_double(x)
	c_pdd =  ctypes.byref(ctypes.c_double(pdd))

	c_dp =  ctypes.byref(ctypes.c_double(dp))

	c_function =  libamtrack.pbdv_
	c_output = c_function( c_v, c_x, c_dv, c_dp, c_pdf, c_pdd)
	return c_output,  c_dv._obj.value, c_dp._obj.value, c_pdf._obj.value, c_pdd._obj.value


def dvsa_ ( va, x, pd):
	'''
	 * Compute parabolic cylinder function Dv(x) for small argument
	 * routines called: GAMMA
	 * @param[in]  va order
	 * @param[in]  x argument
	 * @param[out] pd output Dv(x)
	'''
	c_va = ctypes.c_double(va)
	c_pd =  ctypes.byref(ctypes.c_double(pd))

	c_x = ctypes.c_double(x)
	c_function =  libamtrack.dvsa_
	c_output = c_function( c_va, c_x, c_pd)
	return c_output,  c_pd._obj.value


def dvla_ ( va, x, pd):
	'''
	 * Compute parabolic cylinder function Dv(x) for large argument
	 * Routines called:
	 *             (1) VVLA for computing Vv(x) for large |x|
	 *             (2) GAMMA for computing Gamma(x)
	 * @param[in]  va order
	 * @param[in]  x argument
	 * @param[out] pd output Dv(x)
	'''
	c_va = ctypes.c_double(va)
	c_pd =  ctypes.byref(ctypes.c_double(pd))

	c_x = ctypes.c_double(x)
	c_function =  libamtrack.dvla_
	c_output = c_function( c_va, c_x, c_pd)
	return c_output,  c_pd._obj.value


def vvla_ ( va, x, pv):
	'''
	 * Compute parabolic cylinder function Vv(x) for large argument
	 * Routines called:
	 *             (1) DVLA for computing Dv(x) for large |x|
	 *             (2) GAMMA for computing Gamma(x)
	 * @param[in] va order
	 * @param[in] x argument
	 * @param[out] pv output Vv(x)
	'''
	c_va = ctypes.c_double(va)
	c_pv =  ctypes.byref(ctypes.c_double(pv))

	c_x = ctypes.c_double(x)
	c_function =  libamtrack.vvla_
	c_output = c_function( c_va, c_x, c_pv)
	return c_output,  c_pv._obj.value


def d_sign ( a, b):
	'''
	 * TODO
	 * @param[in] a
	 * @param[in] b
	 * @return
	'''
	c_a = ctypes.c_double(a)
	c_b = ctypes.c_double(b)
	c_function =  libamtrack.d_sign
	c_function.restype = ctypes.c_double
	c_output = c_function( c_a, c_b)
	return c_output


def gamma_ ( x, ga):
	'''
	 * Compute parabolic gamma function
	 * @param[in]  x argument (x is not equal to 0,-1,-2,...)
	 * @param[out] ga output
	'''
	c_x = ctypes.c_double(x)
	c_ga =  ctypes.byref(ctypes.c_double(ga))

	c_function =  libamtrack.gamma_
	c_output = c_function( c_x, c_ga)
	return c_output,  c_ga._obj.value


def gammln ( xx):
	'''
	 * Numerical Recipes: Logarithm of gamma function
	 * @param[in] xx argument for gamma function
	 * @return
	'''
	c_xx = ctypes.c_double(xx)
	c_function =  libamtrack.gammln
	c_function.restype = ctypes.c_double
	c_output = c_function( c_xx)
	return c_output


def nrerror ( error_text):
	'''
	 * Numerical Recipes: standard error handler
	 * @param[in] error_text
	'''
	c_error_text = ctypes.c_char_p(error_text)

	c_function =  libamtrack.nrerror
	c_output = c_function( c_error_text)
	return c_output


def nrerror ( func, params, x1, x2, xacc):
	'''
	 * From Numerical Recipes in C, 2nd ed., 1992:
	 * Using Ridders\' method, return the root of a function func known to lie between x1 and x2.
	 * The root, returned as zriddr, will be refined to an approximate accuracy xacc.
	 * @param[in] func
	 * @param[in] params
	 * @param[in] x1
	 * @param[in] x2
	 * @param[in] xacc
	 * @return
	'''
	c_x2 = (x2)
	c_x1 = (x1)
	c_params = (params)
	c_func = (func)
	c_xacc = (xacc)
	c_function =  libamtrack.nrerror
	c_output = c_function( c_func, c_params, c_x1, c_x2, c_xacc)
	return c_output


def are_elements_int ( elements, n_elements, set, n_set, matches):
	'''
	 * finds integer (32bit) elements in a set (n elements) and returns indices - only one (the first) match
	 * is reported per element a vector "matches" of length n_elements has to be provided
	 * @param[in] elements
	 * @param[in] n_elements
	 * @param[in] set
	 * @param[in] n_set
	 * @param[out] matches
	'''
	c_n_elements = ctypes.c_int(n_elements)
	tmp_array = (ctypes.c_int*1)()
	c_matches= ctypes.byref(tmp_array)

	c_n_set = ctypes.c_int(n_set)
	tmp_array =ctypes.c_int* len(elements)
	c_elements = ctypes.byref(tmp_array(*elements))

	tmp_array =ctypes.c_int* len(set)
	c_set = ctypes.byref(tmp_array(*set))

	c_function =  libamtrack.are_elements_int
	c_output = c_function( c_elements, c_n_elements, c_set, c_n_set, c_matches)
	return c_output,  c_matches._obj


def find_elements_int ( elements, n_elements, set, n_set, matches):
	'''
	 * finds integer (32bit) elements in a set (n elements) and returns indices - only one (the first) match
	 * is reported per element a vector "matches" of length n_elements has to be provided
	 * @param[in] elements
	 * @param[in] n_elements
	 * @param[in] set
	 * @param[in] n_set
	 * @param[out] matches
	'''
	c_n_elements = ctypes.c_long(n_elements)
	tmp_array = (ctypes.c_long*1)()
	c_matches= ctypes.byref(tmp_array)

	c_n_set = ctypes.c_long(n_set)
	tmp_array =ctypes.c_long* len(elements)
	c_elements = ctypes.byref(tmp_array(*elements))

	tmp_array =ctypes.c_long* len(set)
	c_set = ctypes.byref(tmp_array(*set))

	c_function =  libamtrack.find_elements_int
	c_output = c_function( c_elements, c_n_elements, c_set, c_n_set, c_matches)
	return c_output,  c_matches._obj

# problem with function find_elements_char
# problem with function is_element_char

def is_element_int ( element, set, n_set, matches):
	'''
	 * finds a integer element in a set and returns boolean match vector
	 * a vector "matches" of length n_set has to be provided
	 * @param[in] element
	 * @param[in] set
	 * @param[in] n_set
	 * @param[out] matches
	'''
	tmp_array = (ctypes.c_bool*1)()
	c_matches= ctypes.byref(tmp_array)

	c_n_set = ctypes.c_long(n_set)
	tmp_array =ctypes.c_long* len(set)
	c_set = ctypes.byref(tmp_array(*set))

	c_element = ctypes.c_long(element)
	c_function =  libamtrack.is_element_int
	c_output = c_function( c_element, c_set, c_n_set, c_matches)
	return c_output,  c_matches._obj


def AT_sum ( n, data):
	'''
	 * Sums all elements in a data array
	 * @param[in]  n                number of array elements
	 * @param[out]  data            data to sum (array of size n)
	 * @return  sum of all elements
	'''
	tmp_array = (ctypes.c_double*n)()
	c_data= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_sum
	c_function.restype = ctypes.c_double
	c_output = c_function( c_n, c_data)
	return c_output,  c_data._obj


def AT_normalize ( n, data, normalized_data):
	'''
	 * Normalizes a data array by dividing each element by the sum of all elements
	 * @param[in]  n                number of array elements
	 * @param[in]  data             data to normalize
	 * @param[out] normalized_data  results
	'''
	tmp_array =ctypes.c_double* len(data)
	c_data = ctypes.byref(tmp_array(*data))

	tmp_array = (ctypes.c_double*1)()
	c_normalized_data= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_normalize
	c_output = c_function( c_n, c_data, c_normalized_data)
	return c_output,  c_normalized_data._obj


def locate ( xx, n, x):
	'''
	 * interpolation on a table: code (w/ adapted indices) from Numerical Recipes, 2rd ed., chapter 3.1
	 * added wrapping function interp which allows to chose degree of interpolation polynomial
	 * (1 = linear, 2 = quadratic, etc.)
	 * @param[in] xx  TODO
	 * @param[in] n   TODO
	 * @param[in] x   TODO
	 * return j   result
	'''
	c_x = ctypes.c_double(x)
	tmp_array =ctypes.c_double* len(xx)
	c_xx = ctypes.byref(tmp_array(*xx))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.locate
	c_output = c_function( c_xx, c_n, c_x)
	return c_output


def locate_index_in_2d_table ( xx, lowest_index, highest_index, x, index_in_row):
	'''
	 * Locates such index i that following inequation holds:
	 * xx[i-1] <= x < x[i]
	 * @param[in] xx
	 * @param[in] lowest_index
	 * @param[in] highest_index
	 * @param[in] x
	 * @param[in] index_in_row
	 * @return
	'''
	c_highest_index = (highest_index)
	c_x = (x)
	c_xx = (xx)
	c_lowest_index = (lowest_index)
	c_index_in_row = (index_in_row)
	c_function =  libamtrack.locate_index_in_2d_table
	c_function.restype = ctypes.c_long
	c_output = c_function( c_xx, c_lowest_index, c_highest_index, c_x, c_index_in_row)
	return c_output


def AT_get_interpolated_y_from_input_table ( input_data_x, input_data_y, length_of_input_data, intermediate_x):
	'''
	 * TODO
	 * @param[in] input_data_x (array of size length_of_input_data)
	 * @param[in] input_data_y (array of size length_of_input_data)
	 * @param[in] length_of_input_data
	 * @param[in] intermediate_x
	 * @return
	'''
	c_intermediate_x = ctypes.c_double(intermediate_x)
	c_length_of_input_data = ctypes.c_long(length_of_input_data)
	tmp_array =ctypes.c_double* len(input_data_x)
	c_input_data_x = ctypes.byref(tmp_array(*input_data_x))

	tmp_array =ctypes.c_double* len(input_data_y)
	c_input_data_y = ctypes.byref(tmp_array(*input_data_y))

	c_function =  libamtrack.AT_get_interpolated_y_from_input_table
	c_function.restype = ctypes.c_double
	c_output = c_function( c_input_data_x, c_input_data_y, c_length_of_input_data, c_intermediate_x)
	return c_output


def AT_get_interpolated_y_from_input_2d_table ( input_data_xy, length_of_input_data, intermediate_x):
	'''
	 * TODO
	 * @param[in] input_data_xy
	 * @param[in] length_of_input_data
	 * @param[in] intermediate_x
	 * @return
	'''
	c_intermediate_x = (intermediate_x)
	c_input_data_xy = (input_data_xy)
	c_length_of_input_data = (length_of_input_data)
	c_function =  libamtrack.AT_get_interpolated_y_from_input_2d_table
	c_function.restype = ctypes.c_double
	c_output = c_function( c_input_data_xy, c_length_of_input_data, c_intermediate_x)
	return c_output


def AT_get_interpolated_x_from_input_2d_table ( input_data_xy, lowest_index, highest_index, intermediate_y):
	'''
	 *TODO
	 * @param[in] input_data_xy
	 * @param[in] lowest_index
	 * @param[in] highest_index
	 * @param[in] intermediate_y
	 * @return
	'''
	c_highest_index = (highest_index)
	c_intermediate_y = (intermediate_y)
	c_input_data_xy = (input_data_xy)
	c_lowest_index = (lowest_index)
	c_function =  libamtrack.AT_get_interpolated_x_from_input_2d_table
	c_function.restype = ctypes.c_double
	c_output = c_function( c_input_data_xy, c_lowest_index, c_highest_index, c_intermediate_y)
	return c_output


def AT_get_interpolated_y_from_interval ( left_x, left_y, right_x, right_y, intermediate_x):
	'''
	 * TODO
	 * @param[in] left_x
	 * @param[in] left_y
	 * @param[in] right_x
	 * @param[in] right_y
	 * @param[in] intermediate_x
	 * @return
	'''
	c_right_x = ctypes.c_double(right_x)
	c_right_y = ctypes.c_double(right_y)
	c_intermediate_x = ctypes.c_double(intermediate_x)
	c_left_x = ctypes.c_double(left_x)
	c_left_y = ctypes.c_double(left_y)
	c_function =  libamtrack.AT_get_interpolated_y_from_interval
	c_function.restype = ctypes.c_double
	c_output = c_function( c_left_x, c_left_y, c_right_x, c_right_y, c_intermediate_x)
	return c_output


def AT_SPC_get_number_of_bytes_in_file ( filename):
	'''
	 * TODO
	 * @param[in]	filename  	    	path and name for spc file, incl. extension (array of size FILE_NAME_NCHAR)
	 * @return	    number of bytes in file
	'''
	c_filename = ctypes.c_char_p(filename)

	c_function =  libamtrack.AT_SPC_get_number_of_bytes_in_file
	c_function.restype = ctypes.c_int
	c_output = c_function( c_filename)
	return c_output


def AT_SPC_fast_read_buffer ( filename, content_size, content):
	'''
	 * TODO
	 * @param[in]	filename  	    	path and name for spc file, incl. extension (array of size FILE_NAME_NCHAR)
	 * @param[in]	    content_size 	number of elements in content arrays
	 * @param[out]      content  	    binary content of SPC file (array of size content_size)
	 * @return			status code
	'''
	tmp_array = (ctypes.c_int32*content_size)()
	c_content= ctypes.byref(tmp_array)

	c_content_size = ctypes.c_int(content_size)
	c_filename = ctypes.c_char_p(filename)

	c_function =  libamtrack.AT_SPC_fast_read_buffer
	c_function.restype = ctypes.c_int
	c_output = c_function( c_filename, c_content_size, c_content)
	return c_output,  c_content._obj


def decomposeStructIntoString ( content, string, length):
	'''
	 * TODO
	 * @param[in]	    content  	    table of bytes containing binary content of SPC file
	 * @param[out]	    string 			string stored in first tag (item) of SPC content table
	 * @param[out]      length  	    length of string
	'''
	tmp_array =ctypes.c_int32* len(content)
	c_content = ctypes.byref(tmp_array(*content))

	c_length =  ctypes.byref(ctypes.c_int(length))

	c_string =  ctypes.byref(ctypes.c_char(string))

	c_function =  libamtrack.decomposeStructIntoString
	c_output = c_function( c_content, c_string, c_length)
	return c_output,  c_string._obj.value, c_length._obj.value


def decomposeStructIntoDouble ( content, value, length):
	'''
	 * TODO
	 * @param[in]	    content  	    table of bytes containing binary content of SPC file
	 * @param[out]	    value 			floating point value (single or pointer to beginning of table) stored in first tag (item) of SPC content table
	 * @param[out]      length  	    number of items under "value" pointer
	'''
	tmp_array =ctypes.c_int32* len(content)
	c_content = ctypes.byref(tmp_array(*content))

	c_length =  ctypes.byref(ctypes.c_int(length))

	c_value =  ctypes.byref(ctypes.c_double(value))

	c_function =  libamtrack.decomposeStructIntoDouble
	c_output = c_function( c_content, c_value, c_length)
	return c_output,  c_value._obj.value, c_length._obj.value


def decomposeStructIntoInteger ( content, value, length):
	'''
	 * TODO
	 * @param[in]	    content  	    table of bytes containing binary content of SPC file
	 * @param[out]	    value 			integer value (single or pointer to beginning of table) stored in first tag (item) of SPC content table
	 * @param[out]      length  	    number of items under "value" pointer
	'''
	tmp_array =ctypes.c_int32* len(content)
	c_content = ctypes.byref(tmp_array(*content))

	c_length =  ctypes.byref(ctypes.c_int(length))

	c_value =  ctypes.byref(ctypes.c_uint64(value))

	c_function =  libamtrack.decomposeStructIntoInteger
	c_output = c_function( c_content, c_value, c_length)
	return c_output,  c_value._obj.value, c_length._obj.value

# problem with function skipStruct

def decomposeTag ( content):
	'''
	 * TODO
	 * @param[in]	content  	    table of bytes containing binary content of SPC file
	 * @return
	'''
	tmp_array =ctypes.c_int32* len(content)
	c_content = ctypes.byref(tmp_array(*content))

	c_function =  libamtrack.decomposeTag
	c_function.restype = ctypes.c_int
	c_output = c_function( c_content)
	return c_output


def decomposeLength ( content):
	'''
	 * TODO
	 * @param[in]	content  	    table of bytes containing binary content of SPC file
	 * @return
	'''
	tmp_array =ctypes.c_int32* len(content)
	c_content = ctypes.byref(tmp_array(*content))

	c_function =  libamtrack.decomposeLength
	c_function.restype = ctypes.c_int
	c_output = c_function( c_content)
	return c_output


def AT_SPC_decompose_size ( content_size, content_orig):
	'''
	 * TODO
	 * @param[in]	content_size  	    size of table content_orig
	 * @param[in]	content_orig  	    table of bytes containing binary content of SPC file (array of size content_size)
	 * @return      number of bins
	'''
	c_content_size = ctypes.c_int(content_size)
	tmp_array =ctypes.c_int32* len(content_orig)
	c_content_orig = ctypes.byref(tmp_array(*content_orig))

	c_function =  libamtrack.AT_SPC_decompose_size
	c_function.restype = ctypes.c_int
	c_output = c_function( c_content_size, c_content_orig)
	return c_output


def AT_SPC_decompose_header ( content_size, content_orig, E_MeV_u, peak_position_g_cm2, particle_no, material_no, normalisation, depth_steps_no):
	'''
	 * TODO
	 * @param[in]	content_size  	    size of table content_orig
	 * @param[in]	content_orig  	    table of bytes containing binary content of SPC file (array of size content_size)
	 * @param[out]	E_MeV_u  	        beam energy [MeV]
	 * @param[out]	peak_position_g_cm2 peak position
	 * @param[out]	particle_no         projectile - particle no
	 * @param[out]	material_no         target - material no
	 * @param[out]	normalisation  	    normalisation
	 * @param[out]  depth_steps_no      number of depth steps
	 * return       status code
	'''
	c_material_no =  ctypes.byref(ctypes.c_int(material_no))

	tmp_array =ctypes.c_int32* len(content_orig)
	c_content_orig = ctypes.byref(tmp_array(*content_orig))

	c_content_size = ctypes.c_int(content_size)
	c_particle_no =  ctypes.byref(ctypes.c_long(particle_no))

	c_E_MeV_u =  ctypes.byref(ctypes.c_double(E_MeV_u))

	c_peak_position_g_cm2 =  ctypes.byref(ctypes.c_double(peak_position_g_cm2))

	c_normalisation =  ctypes.byref(ctypes.c_double(normalisation))

	c_depth_steps_no =  ctypes.byref(ctypes.c_int(depth_steps_no))

	c_function =  libamtrack.AT_SPC_decompose_header
	c_output = c_function( c_content_size, c_content_orig, c_E_MeV_u, c_peak_position_g_cm2, c_particle_no, c_material_no, c_normalisation, c_depth_steps_no)
	return c_output,  c_E_MeV_u._obj.value, c_peak_position_g_cm2._obj.value, c_particle_no._obj.value, c_material_no._obj.value, c_normalisation._obj.value, c_depth_steps_no._obj.value


def AT_SPC_decompose_data ( content_size, content_orig, depth_step, depth_g_cm2, E_MeV_u, DE_MeV_u, particle_no, fluence_cm2):
	'''
	 * TODO
	 * @param[in]	content_size  	    size of table content_orig
	 * @param[in]	content_orig  	    table of bytes containing binary content of SPC file (array of size content_size)
	 * @param[out]  depth_step          depth step index, zero-based
	 * @param[out]  depth_g_cm2         depth in g/cm2
	 * @param[out]	E_MeV_u  	        midpoints of energy bins
	 * @param[out]	DE_MeV_u  	        widths of energy bins
	 * @param[out]	particle_no         particle index numbers
	 * @param[out]	fluence_cm2  	    fluence values differential in energy and particle number
	 * return       status code
	'''
	tmp_array = (ctypes.c_double*1)()
	c_DE_MeV_u= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_int32* len(content_orig)
	c_content_orig = ctypes.byref(tmp_array(*content_orig))

	c_content_size = ctypes.c_int(content_size)
	tmp_array = (ctypes.c_double*1)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_long*1)()
	c_particle_no= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*1)()
	c_depth_g_cm2= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*1)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_int*1)()
	c_depth_step= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_SPC_decompose_data
	c_output = c_function( c_content_size, c_content_orig, c_depth_step, c_depth_g_cm2, c_E_MeV_u, c_DE_MeV_u, c_particle_no, c_fluence_cm2)
	return c_output,  c_depth_step._obj, c_depth_g_cm2._obj, c_E_MeV_u._obj, c_DE_MeV_u._obj, c_particle_no._obj, c_fluence_cm2._obj


def AT_SPC_get_number_of_bins_from_filename_fast ( filename):
	'''
	 * TODO
	 * @param[in]	filename  	    	path and name for spc file, incl. extension (array of size FILE_NAME_NCHAR)
	 * @return               number of bins
	'''
	c_filename = ctypes.c_char_p(filename)

	c_function =  libamtrack.AT_SPC_get_number_of_bins_from_filename_fast
	c_function.restype = ctypes.c_long
	c_output = c_function( c_filename)
	return c_output


def AT_SPC_read_header_from_filename_fast ( filename, E_MeV_u, peak_position_g_cm2, particle_no, material_no, normalisation, depth_steps_no):
	'''
	 * Reads data from spc file into pre-allocated arrays. It will be converted
	 * for direct use in libamtrack, i.e. to an R-style array of six columns
	 * (each presented by a single pointer) and all of same length. That of course
	 * results in redundancy in depth_step, depth_g_cm2, particle_no but enables
	 * easy division into cells (i.e. passing all spectra of a specific depth and
	 * particle number to another routine such as total dose). Please note that
	 * the fluence IS NOT normalized to bin width but given in absolute fluence!
	 *
	 * @param[in]	filename  	    	path and name for spc file, incl. extension (array of size FILE_NAME_NCHAR)
	 * @param[out]	E_MeV_u				primary beam energy in MeV/u
	 * @param[out]	peak_position_g_cm2	position of peak in g/cm2
	 * @param[out]	particle_no         projectile - particle no
	 * @param[out]	material_no         target - material no
	 * @param[out]	normalisation		normalisation
	 * @param[out]  depth_steps_no      number of depth steps
	 * @return               status code
	'''
	c_material_no =  ctypes.byref(ctypes.c_int(material_no))

	c_depth_steps_no =  ctypes.byref(ctypes.c_int(depth_steps_no))

	c_peak_position_g_cm2 =  ctypes.byref(ctypes.c_double(peak_position_g_cm2))

	c_E_MeV_u =  ctypes.byref(ctypes.c_double(E_MeV_u))

	c_particle_no =  ctypes.byref(ctypes.c_long(particle_no))

	c_normalisation =  ctypes.byref(ctypes.c_double(normalisation))

	c_filename = ctypes.c_char_p(filename)

	c_function =  libamtrack.AT_SPC_read_header_from_filename_fast
	c_function.restype = ctypes.c_int
	c_output = c_function( c_filename, c_E_MeV_u, c_peak_position_g_cm2, c_particle_no, c_material_no, c_normalisation, c_depth_steps_no)
	return c_output,  c_E_MeV_u._obj.value, c_peak_position_g_cm2._obj.value, c_particle_no._obj.value, c_material_no._obj.value, c_normalisation._obj.value, c_depth_steps_no._obj.value


def AT_SPC_read_data_from_filename_fast ( filename, n, depth_step, depth_g_cm2, E_MeV_u, DE_MeV_u, particle_no, fluence_cm2):
	'''
	 * Reads data from spc file into pre-allocated arrays. It will be converted
	 * for direct use in libamtrack, i.e. to an R-style array of six columns
	 * (each presented by a single pointer) and all of same length. That of course
	 * results in redundancy in depth_step, depth_g_cm2, particle_no but enables
	 * easy division into cells (i.e. passing all spectra of a specific depth and
	 * particle number to another routine such as total dose). Please note that
	 * the fluence IS NOT normalized to bin width but given in absolute fluence!
	 *
	 * @param[in]	    filename  	    path and name for spc file, incl. extension (array of size FILE_NAME_NCHAR)
	 * @param[in]       n               array size, total number of bins expected
	 * @see AT_SPC_get_size
	 * @param[out]		depth_step		depth step index, zero-based (array of size n)
	 * @param[out]		depth_g_cm2		depth in g/cm2 (array of size n)
	 * @param[out]		E_MeV_u			midpoints of energy bins (array of size n)
	 * @param[out]		DE_MeV_u		widths of energy bins (array of size n)
	 * @param[out]		particle_no		particle index numbers (array of size n)
	 * @param[out]      fluence_cm2		fluence values differential in energy and particle number (array of size n)
	 * @return                          number of bins read. Must match the array size n
	'''
	tmp_array = (ctypes.c_double*n)()
	c_DE_MeV_u= ctypes.byref(tmp_array)

	c_filename = ctypes.c_char_p(filename)

	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_long*n)()
	c_particle_no= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_depth_g_cm2= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_n = ctypes.c_int(n)
	tmp_array = (ctypes.c_int*n)()
	c_depth_step= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_SPC_read_data_from_filename_fast
	c_function.restype = ctypes.c_int
	c_output = c_function( c_filename, c_n, c_depth_step, c_depth_g_cm2, c_E_MeV_u, c_DE_MeV_u, c_particle_no, c_fluence_cm2)
	return c_output,  c_depth_step._obj, c_depth_g_cm2._obj, c_E_MeV_u._obj, c_DE_MeV_u._obj, c_particle_no._obj, c_fluence_cm2._obj


def AT_SPC_read_from_filename_fast ( filename, n, E_MeV_u_initial, peak_position_g_cm2, particle_no_initial, material_no, normalisation, depth_steps_no, depth_step, depth_g_cm2, E_MeV_u, DE_MeV_u, particle_no, fluence_cm2):
	'''
	 * Reads data from spc file into pre-allocated arrays. It will be converted
	 * for direct use in libamtrack, i.e. to an R-style array of six columns
	 * (each presented by a single pointer) and all of same length. That of course
	 * results in redundancy in depth_step, depth_g_cm2, particle_no but enables
	 * easy division into cells (i.e. passing all spectra of a specific depth and
	 * particle number to another routine such as total dose). Please note that
	 * the fluence IS NOT normalized to bin width but given in absolute fluence!
	 *
	 * @param[in]	filename  	    	path and name for spc file, incl. extension (array of size FILE_NAME_NCHAR)
	 * @param[in]   n                   array size, total number of bins expected
	 * @see AT_SPC_get_size
	 * @param[out]	E_MeV_u_initial		primary beam energy in MeV/u
	 * @param[out]	peak_position_g_cm2	position of peak in g/cm2
	 * @param[out]	particle_no_initial projectile - particle no
	 * @param[out]	material_no         target - material no
	 * @param[out]	normalisation		normalisation
	 * @param[out]  depth_steps_no      number of depth steps
	 * @param[out]	depth_step		    depth step index, zero-based (array of size n)
	 * @param[out]	depth_g_cm2		    depth in g/cm2 (array of size n)
	 * @param[out]	E_MeV_u			    midpoints of energy bins (array of size n)
	 * @param[out]	DE_MeV_u		    widths of energy bins (array of size n)
	 * @param[out]	particle_no		    particle index numbers (array of size n)
	 * @param[out]  fluence_cm2		    fluence values differential in energy and particle number (array of size n)
	 * @return                          number of bins read. Must match the array size n
	'''
	c_material_no =  ctypes.byref(ctypes.c_int(material_no))

	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_DE_MeV_u= ctypes.byref(tmp_array)

	c_depth_steps_no =  ctypes.byref(ctypes.c_int(depth_steps_no))

	tmp_array = (ctypes.c_long*n)()
	c_particle_no= ctypes.byref(tmp_array)

	c_n = ctypes.c_int(n)
	tmp_array = (ctypes.c_int*n)()
	c_depth_step= ctypes.byref(tmp_array)

	c_particle_no_initial =  ctypes.byref(ctypes.c_long(particle_no_initial))

	c_peak_position_g_cm2 =  ctypes.byref(ctypes.c_double(peak_position_g_cm2))

	c_normalisation =  ctypes.byref(ctypes.c_double(normalisation))

	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_filename = ctypes.c_char_p(filename)

	tmp_array = (ctypes.c_double*n)()
	c_depth_g_cm2= ctypes.byref(tmp_array)

	c_E_MeV_u_initial =  ctypes.byref(ctypes.c_double(E_MeV_u_initial))

	c_function =  libamtrack.AT_SPC_read_from_filename_fast
	c_function.restype = ctypes.c_int
	c_output = c_function( c_filename, c_n, c_E_MeV_u_initial, c_peak_position_g_cm2, c_particle_no_initial, c_material_no, c_normalisation, c_depth_steps_no, c_depth_step, c_depth_g_cm2, c_E_MeV_u, c_DE_MeV_u, c_particle_no, c_fluence_cm2)
	return c_output,  c_depth_g_cm2._obj, c_E_MeV_u._obj, c_DE_MeV_u._obj, c_particle_no._obj, c_fluence_cm2._obj, c_E_MeV_u_initial._obj.value, c_peak_position_g_cm2._obj.value, c_particle_no_initial._obj.value, c_material_no._obj.value, c_normalisation._obj.value, c_depth_steps_no._obj.value, c_depth_step._obj


def compare_SPC_Pairs ( a, b):
	'''
	 * TODO
	 * @param[in]   a  TODO
	 * @param[in]   b  TODO
	 * @return  TODO
	'''
	c_a = (a)
	c_b = (b)
	c_function =  libamtrack.compare_SPC_Pairs
	c_function.restype = ctypes.c_int
	c_output = c_function( c_a, c_b)
	return c_output


def AT_SPC_number_of_bins_at_range ( path, range_g_cm2):
	'''
	 * TODO
	 *
	 * @param[in]   path            	path to spc file dir (array of size 2048)
	 * @param[in]   range_g_cm2         range in g/cm2
	 * @return                          number of bins for given range
	'''
	c_path = ctypes.c_char_p(path)

	c_range_g_cm2 = ctypes.c_double(range_g_cm2)
	c_function =  libamtrack.AT_SPC_number_of_bins_at_range
	c_function.restype = ctypes.c_long
	c_output = c_function( c_path, c_range_g_cm2)
	return c_output


def AT_SPC_spectrum_at_range ( path, range_g_cm2, n, depth_step, depth_g_cm2, E_MeV_u, DE_MeV_u, particle_no, fluence_cm2):
	'''
	 * TODO
	 *
	 * @param[in]   path            	path to spc file dir (array of size 2048)
	 * @param[in]   range_g_cm2         range in g/cm2
	 * @param[in]   n                   array size, total number of bins expected
	 * @param[out]	depth_step		    depth step index, zero-based (array of size n)
	 * @param[out]	depth_g_cm2		    depth in g/cm2 (array of size n)
	 * @param[out]	E_MeV_u			    midpoints of energy bins (array of size n)
	 * @param[out]	DE_MeV_u		    widths of energy bins (array of size n)
	 * @param[out]	particle_no		    particle index numbers (array of size n)
	 * @param[out]  fluence_cm2		    fluence values differential in energy and particle number (array of size n)
	 * @return                          status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_DE_MeV_u= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_long*n)()
	c_particle_no= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	c_range_g_cm2 = ctypes.c_double(range_g_cm2)
	tmp_array = (ctypes.c_double*n)()
	c_depth_g_cm2= ctypes.byref(tmp_array)

	c_path = ctypes.c_char_p(path)

	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_n = ctypes.c_int(n)
	tmp_array = (ctypes.c_int*n)()
	c_depth_step= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_SPC_spectrum_at_range
	c_function.restype = ctypes.c_int
	c_output = c_function( c_path, c_range_g_cm2, c_n, c_depth_step, c_depth_g_cm2, c_E_MeV_u, c_DE_MeV_u, c_particle_no, c_fluence_cm2)
	return c_output,  c_depth_step._obj, c_depth_g_cm2._obj, c_E_MeV_u._obj, c_DE_MeV_u._obj, c_particle_no._obj, c_fluence_cm2._obj


def AT_Gamma_index_from_material_number ( Gamma_no):
	'''
	 * Get index of gamma response model in AT_GR_Data for given Gamma_no
	 * (currently for example gamma response model with number 2 has index 1)
	 *
	 * @param[in] Gamma_no  gamma response model number
	 * @return          gamma response model index in AT_GR_Data table
	'''
	c_Gamma_no = ctypes.c_long(Gamma_no)
	c_function =  libamtrack.AT_Gamma_index_from_material_number
	c_function.restype = ctypes.c_long
	c_output = c_function( c_Gamma_no)
	return c_output


def AT_Gamma_name_from_number ( Gamma_no, Gamma_name):
	'''
	 * Returns name of the gamma response model from model number
	 *
	 * @param[in]  Gamma_no    gamma response model number
	 * @param[out] Gamma_name  string containing gamma response model name
	'''
	c_Gamma_name =  ctypes.byref(ctypes.c_char(Gamma_name))

	c_Gamma_no = ctypes.c_long(Gamma_no)
	c_function =  libamtrack.AT_Gamma_name_from_number
	c_output = c_function( c_Gamma_no, c_Gamma_name)
	return c_output,  c_Gamma_name._obj.value


def AT_Gamma_number_of_parameters ( Gamma_no):
	'''
	 * Returns number of parameters of the gamma response model from model number
	 *
	 * @param[in]   Gamma_no   gamma response model number
	 * return                  number of GR parameters
	'''
	c_Gamma_no = ctypes.c_long(Gamma_no)
	c_function =  libamtrack.AT_Gamma_number_of_parameters
	c_output = c_function( c_Gamma_no)
	return c_output


def AT_gamma_response ( number_of_doses, d_Gy, gamma_model, gamma_parameter, lethal_event_mode, S):
	'''
	 * Returns a system (detector or cells) response for given doses
	 * according to the chosen gamma response model
	 *
	 * @param[in]  number_of_doses  number of doses given in vector d_Gy
	 * @param[in]  d_Gy             doses in Gy (array of size number_of_doses)
	 * @param[in]  gamma_model      gamma response model index
	 * @param[in]  gamma_parameter  vector holding necessary parameters for the chose gamma response model (array of size 9)
	 * @param[in]  lethal_event_mode  if true computation is done in lethal event mode
	 * @param[out] S                gamma responses (array of size number_of_doses)
	'''
	tmp_array =ctypes.c_double* len(gamma_parameter)
	c_gamma_parameter = ctypes.byref(tmp_array(*gamma_parameter))

	tmp_array =ctypes.c_double* len(d_Gy)
	c_d_Gy = ctypes.byref(tmp_array(*d_Gy))

	tmp_array = (ctypes.c_double*number_of_doses)()
	c_S= ctypes.byref(tmp_array)

	c_gamma_model = ctypes.c_long(gamma_model)
	c_number_of_doses = ctypes.c_long(number_of_doses)
	c_lethal_event_mode = ctypes.c_bool(lethal_event_mode)
	c_function =  libamtrack.AT_gamma_response
	c_output = c_function( c_number_of_doses, c_d_Gy, c_gamma_model, c_gamma_parameter, c_lethal_event_mode, c_S)
	return c_output,  c_S._obj


def AT_get_gamma_response_for_average_dose ( number_of_bins, dose_Gy_bin_position, dose_Gy_bin_width, dose_bin_frequency, gamma_model, gamma_parameter, lethal_events_mode):
	'''
	 * Returns the detector / cell gamma response for dose distribution
	 *
	 * @param[in]  number_of_bins            number of bins in the dose histogram
	 * @param[in]  dose_Gy_bin_position      midpoint doses for histogram in Gy (array of size number_of_bins)
	 * @param[in]  dose_Gy_bin_width         bin widths for histogram in Gy (array of size number_of_bins)
	 * @param[in]  dose_bin_frequency        dose frequencies for histogram (array of size number_of_bins)
	 * @param[in]  gamma_model               gamma response model index
	 * @param[in]  gamma_parameter           vector holding necessary parameters for the chose gamma response model (array of size GR_MAX_NUMBER_OF_PARAMETERS)
	 * @param[in]  lethal_events_mode        if true computation is done in lethal event mode
	 * @return     response
	'''
	tmp_array =ctypes.c_double* len(gamma_parameter)
	c_gamma_parameter = ctypes.byref(tmp_array(*gamma_parameter))

	tmp_array =ctypes.c_double* len(dose_bin_frequency)
	c_dose_bin_frequency = ctypes.byref(tmp_array(*dose_bin_frequency))

	tmp_array =ctypes.c_double* len(dose_Gy_bin_position)
	c_dose_Gy_bin_position = ctypes.byref(tmp_array(*dose_Gy_bin_position))

	tmp_array =ctypes.c_double* len(dose_Gy_bin_width)
	c_dose_Gy_bin_width = ctypes.byref(tmp_array(*dose_Gy_bin_width))

	c_gamma_model = ctypes.c_long(gamma_model)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lethal_events_mode = ctypes.c_bool(lethal_events_mode)
	c_function =  libamtrack.AT_get_gamma_response_for_average_dose
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_dose_Gy_bin_position, c_dose_Gy_bin_width, c_dose_bin_frequency, c_gamma_model, c_gamma_parameter, c_lethal_events_mode)
	return c_output


def AT_get_response_distribution_from_dose_distribution ( number_of_bins, dose_Gy_bin_position, dose_bin_frequency, gamma_model, gamma_parameter, lethal_events_mode, response_bin_frequency):
	'''
	 * Returns the detector / cell gamma response for dose distribution
	 *
	 * @param[in]  number_of_bins            number of bins in the dose histogram
	 * @param[in]  dose_Gy_bin_position      midpoint doses for histogram in Gy (array of size number_of_bins)
	 * @param[in]  dose_bin_frequency        dose frequencies for histogram (array of size number_of_bins)
	 * @param[in]  gamma_model               gamma response model index
	 * @param[in]  gamma_parameter           vector holding necessary parameters for the chose gamma response model (array of size GR_MAX_NUMBER_OF_PARAMETERS)
	 * @param[in]  lethal_events_mode        if true computation is done in lethal event mode
	 * @param[out] response_bin_frequency    resulting response frequencies (array of size number_of_bins)
	'''
	tmp_array =ctypes.c_double* len(gamma_parameter)
	c_gamma_parameter = ctypes.byref(tmp_array(*gamma_parameter))

	tmp_array =ctypes.c_double* len(dose_Gy_bin_position)
	c_dose_Gy_bin_position = ctypes.byref(tmp_array(*dose_Gy_bin_position))

	tmp_array =ctypes.c_double* len(dose_bin_frequency)
	c_dose_bin_frequency = ctypes.byref(tmp_array(*dose_bin_frequency))

	c_gamma_model = ctypes.c_long(gamma_model)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lethal_events_mode = ctypes.c_bool(lethal_events_mode)
	tmp_array = (ctypes.c_double*number_of_bins)()
	c_response_bin_frequency= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_get_response_distribution_from_dose_distribution
	c_output = c_function( c_number_of_bins, c_dose_Gy_bin_position, c_dose_bin_frequency, c_gamma_model, c_gamma_parameter, c_lethal_events_mode, c_response_bin_frequency)
	return c_output,  c_response_bin_frequency._obj


def AT_get_ion_response_from_response_distribution ( number_of_bins, dose_Gy_bin_width, dose_bin_frequency, ion_response_bin_frequency):
	'''
	 * Returns the ion response from an ion response distribution
	 *
	 * @param[in]  number_of_bins                number of bins in the dose histogram
	 * @param[in]  dose_Gy_bin_width             bin widths for histogram in Gy (array of size number_of_bins)
	 * @param[in]  dose_bin_frequency            dose frequencies for histogram (array of size number_of_bins)
	 * @param[in]  ion_response_bin_frequency    ion response frequencies (array of size number_of_bins)
	 * @return     response
	'''
	c_number_of_bins = ctypes.c_long(number_of_bins)
	tmp_array =ctypes.c_double* len(dose_Gy_bin_width)
	c_dose_Gy_bin_width = ctypes.byref(tmp_array(*dose_Gy_bin_width))

	tmp_array =ctypes.c_double* len(ion_response_bin_frequency)
	c_ion_response_bin_frequency = ctypes.byref(tmp_array(*ion_response_bin_frequency))

	tmp_array =ctypes.c_double* len(dose_bin_frequency)
	c_dose_bin_frequency = ctypes.byref(tmp_array(*dose_bin_frequency))

	c_function =  libamtrack.AT_get_ion_response_from_response_distribution
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_dose_Gy_bin_width, c_dose_bin_frequency, c_ion_response_bin_frequency)
	return c_output


def AT_get_ion_response_from_dose_distribution ( number_of_bins, dose_Gy_bin_position, dose_bin_frequency, gamma_model, gamma_parameter, lethal_events_mode):
	'''
	 * Returns ion response for dose distribution
	 *
	 * @param[in]  number_of_bins            number of bins in the dose histogram
	 * @param[in]  dose_Gy_bin_position      midpoint doses for histogram in Gy (array of size number_of_bins)
	 * @param[in]  dose_bin_frequency        dose frequencies for histogram (array of size number_of_bins)
	 * @param[in]  gamma_model               gamma response model index
	 * @param[in]  gamma_parameter           vector holding necessary parameters for the chose gamma response model (array of size GR_MAX_NUMBER_OF_PARAMETERS)
	 * @param[in]  lethal_events_mode        if true computation is done in lethal event mode
	 * @return     resulting ion response
	'''
	c_gamma_parameter = ctypes.c_void_p(gamma_parameter)

	tmp_array =ctypes.c_double* len(dose_Gy_bin_position)
	c_dose_Gy_bin_position = ctypes.byref(tmp_array(*dose_Gy_bin_position))

	c_dose_bin_frequency = ctypes.c_void_p(dose_bin_frequency)

	c_gamma_model = (gamma_model)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lethal_events_mode = (lethal_events_mode)
	c_function =  libamtrack.AT_get_ion_response_from_dose_distribution
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_dose_Gy_bin_position, c_dose_bin_frequency, c_gamma_model, c_gamma_parameter, c_lethal_events_mode)
	return c_output


def AT_get_ion_efficiency_from_dose_distribution ( number_of_bins, dose_Gy_bin_position, dose_bin_frequency, gamma_model, gamma_parameter, lethal_events_mode):
	'''
	 * Returns relative efficiency for dose distribution
	 *
	 * @param[in]  number_of_bins            number of bins in the dose histogram
	 * @param[in]  dose_Gy_bin_position      midpoint doses for histogram in Gy (array of size number_of_bins)
	 * @param[in]  dose_bin_frequency        dose frequencies for histogram (array of size number_of_bins)
	 * @param[in]  gamma_model               gamma response model index
	 * @param[in]  gamma_parameter           vector holding necessary parameters for the chose gamma response model (array of size GR_MAX_NUMBER_OF_PARAMETERS)
	 * @param[in]  lethal_events_mode        if true computation is done in lethal event mode
	 * @return     relative efficiency
	'''
	c_gamma_parameter = ctypes.c_void_p(gamma_parameter)

	tmp_array =ctypes.c_double* len(dose_Gy_bin_position)
	c_dose_Gy_bin_position = ctypes.byref(tmp_array(*dose_Gy_bin_position))

	c_dose_bin_frequency = ctypes.c_void_p(dose_bin_frequency)

	c_gamma_model = (gamma_model)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lethal_events_mode = (lethal_events_mode)
	c_function =  libamtrack.AT_get_ion_efficiency_from_dose_distribution
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_bins, c_dose_Gy_bin_position, c_dose_bin_frequency, c_gamma_model, c_gamma_parameter, c_lethal_events_mode)
	return c_output


def AT_get_ion_efficiency_from_response_distribution ( number_of_bins, dose_Gy_bin_position, dose_bin_frequency, ion_response_bin_frequency, gamma_model, gamma_parameter, lethal_events_mode):
	'''
	 * Returns relative efficiency from ion response distribution
	 *
	 * @param[in]  number_of_bins            number of bins in the dose histogram
	 * @param[in]  dose_Gy_bin_position      midpoint doses for histogram in Gy (array of size number_of_bins)
	 * @param[in]  dose_bin_frequency        dose frequencies for histogram (array of size number_of_bins)
	 * @param[in]  ion_response_bin_frequency    ion response frequencies (array of size number_of_bins)
	 * @param[in]  gamma_model               gamma response model index
	 * @param[in]  gamma_parameter           vector holding necessary parameters for the chose gamma response model (array of size GR_MAX_NUMBER_OF_PARAMETERS)
	 * @param[in]  lethal_events_mode        if true computation is done in lethal event mode
	'''
	c_gamma_parameter = ctypes.c_void_p(gamma_parameter)

	tmp_array =ctypes.c_double* len(dose_Gy_bin_position)
	c_dose_Gy_bin_position = ctypes.byref(tmp_array(*dose_Gy_bin_position))

	c_dose_bin_frequency = ctypes.c_void_p(dose_bin_frequency)

	c_ion_response_bin_frequency = ctypes.c_void_p(ion_response_bin_frequency)

	c_gamma_model = (gamma_model)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lethal_events_mode = (lethal_events_mode)
	c_function =  libamtrack.AT_get_ion_efficiency_from_response_distribution
	c_output = c_function( c_number_of_bins, c_dose_Gy_bin_position, c_dose_bin_frequency, c_ion_response_bin_frequency, c_gamma_model, c_gamma_parameter, c_lethal_events_mode)
	return c_output


def AT_get_gamma_response ( number_of_bins, d_Gy, dd_Gy, f, f0, gamma_model, gamma_parameter, lethal_events_mode, S, S_HCP, S_gamma, efficiency):
	'''
	 * Returns the detector / cell gamma response for a local dose distribution
	 * according to the chosen gamma response model, used by response model
	 * routines in AmTrack.c
	 *
	 * @param[in]  number_of_bins      number of bins in given local dose distribution
	 * @param[in]  d_Gy                local dose bin position in Gy (array of size number_of_bins)
	 * @param[in]  dd_Gy               local dose bin width in Gy (array of size number_of_bins)
	 * @param[in]  f                   local dose frequency (array of size number_of_bins)
	 * @param[in]  f0                  frequency of zero local dose
	 * @param[in]  gamma_model         gamma response model index
	 * @param[in]  gamma_parameter     vector holding necessary parameters for the chose gamma response model (array of size GR_MAX_NUMBER_OF_PARAMETERS)
	 * @param[in]  lethal_events_mode  if true, allows to do calculations for cell survival
	 *    @see  AmTrack.c/AT_IGK
	 * @param[out] S                   gamma responses for given bins (array of size number_of_bins)
	 * @param[out] S_HCP               HCP response for given local dose distribution (expectation value of S distribution)
	 * @param[out] S_gamma             gamma response for given local dose distribution (gamma response of expectation value of d distribution)
	 * @param[out] efficiency          RE = S_HCP/S_gamma for given local dose distribution
	'''
	c_f0 = ctypes.c_double(f0)
	tmp_array =ctypes.c_double* len(gamma_parameter)
	c_gamma_parameter = ctypes.byref(tmp_array(*gamma_parameter))

	tmp_array =ctypes.c_double* len(f)
	c_f = ctypes.byref(tmp_array(*f))

	tmp_array =ctypes.c_double* len(dd_Gy)
	c_dd_Gy = ctypes.byref(tmp_array(*dd_Gy))

	tmp_array =ctypes.c_double* len(d_Gy)
	c_d_Gy = ctypes.byref(tmp_array(*d_Gy))

	c_S_HCP =  ctypes.byref(ctypes.c_double(S_HCP))

	c_efficiency =  ctypes.byref(ctypes.c_double(efficiency))

	tmp_array = (ctypes.c_double*number_of_bins)()
	c_S= ctypes.byref(tmp_array)

	c_gamma_model = ctypes.c_long(gamma_model)
	c_number_of_bins = ctypes.c_long(number_of_bins)
	c_lethal_events_mode = ctypes.c_bool(lethal_events_mode)
	c_S_gamma =  ctypes.byref(ctypes.c_double(S_gamma))

	c_function =  libamtrack.AT_get_gamma_response
	c_output = c_function( c_number_of_bins, c_d_Gy, c_dd_Gy, c_f, c_f0, c_gamma_model, c_gamma_parameter, c_lethal_events_mode, c_S, c_S_HCP, c_S_gamma, c_efficiency)
	return c_output,  c_S_HCP._obj.value, c_S_gamma._obj.value, c_efficiency._obj.value, c_S._obj


def AT_n_bins_for_single_impact_local_dose_distrib ( n, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, N2, stopping_power_source_no):
	'''
	 * Computes the size of the array to hold the f1 (single impact) local dose distribution for a given field, rdd, er
	 * @param[in]  n                   number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u             energy of particles in the mixed particle field (array of size n)
	 * @param[in]  particle_no         type of the particles in the mixed particle field (array of size n)
	 * @param[in]  material_no         index number for detector material
	 * @param[in]  rdd_model           index number for chosen radial dose distribution
	 * @param[in]  rdd_parameter       parameters for chosen radial dose distribution (array of size 4)
	 * @param[in]  er_model            index number for chosen electron-range model
	 * @param[in]  N2                  number of bins per factor of two in local dose array
	 * @param[in]  stopping_power_source_no  TODO
	 * @return number of bins to hold the f1 distribution
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_er_model = ctypes.c_long(er_model)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_N2 = ctypes.c_long(N2)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_function =  libamtrack.AT_n_bins_for_single_impact_local_dose_distrib
	c_function.restype = ctypes.c_long
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_N2, c_stopping_power_source_no)
	return c_output


def AT_single_impact_local_dose_distrib ( n, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, rdd_model, rdd_parameter, er_model, N2, f1_parameters, n_bins_f1, stopping_power_source_no, f1_d_Gy, f1_dd_Gy, f1):
	'''
	 * Computes the f1 (single impact) local dose distribution for a given field,
	 * radial dose distribution and electron-range model. The routine can handle
	 * mixed fields by adding the single contributions according to their respective
	 * fluence.
	 * This routine can handle all monotonously falling RDDs which should be the case
	 * for every realistic approach.
	 * Usually step 2 of the CPP-SC method
	 * @param[in]  n                     number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u               energy of particles in the mixed particle field (array of size n)
	 * @param[in]  particle_no           type of the particles in the mixed particle field (array of size n)
	 * @param[in]  fluence_cm2_or_dose_Gy           fluences for the given particles, doses in Gy if negative (array of size n)
	 * @param[in]  material_no           index number for detector material
	 * @param[in]  rdd_model             index number for chosen radial dose distribution
	 * @param[in]  rdd_parameter         parameters for chosen radial dose distribution (array of size 4)
	 * @param[in]  er_model              index number for chosen electron-range model
	 * @param[in]  N2                    number of bins per factor of two in local dose array
	 * @param[in]  f1_parameters         n field component characteristics (array of size 8) // TODO in R package should also work for 8*n, but is not working
	 * @param[in]  n_bins_f1             number of bins holding the f1 distribution
	 * @param[in]  stopping_power_source_no     TODO
	 * @param[out] f1_d_Gy               bin midpoints for f1 (array of size n_bins_f1)
	 * @param[out] f1_dd_Gy              bin widths for f1 (array of size n_bins_f1)
	 * @param[out] f1                    f1 values (array of size n_bins_f1)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	tmp_array =ctypes.c_double* len(f1_parameters)
	c_f1_parameters = ctypes.byref(tmp_array(*f1_parameters))

	tmp_array = (ctypes.c_double*n_bins_f1)()
	c_f1_dd_Gy= ctypes.byref(tmp_array)

	c_n_bins_f1 = ctypes.c_long(n_bins_f1)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n_bins_f1)()
	c_f1= ctypes.byref(tmp_array)

	c_er_model = ctypes.c_long(er_model)
	tmp_array = (ctypes.c_double*n_bins_f1)()
	c_f1_d_Gy= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_N2 = ctypes.c_long(N2)
	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	c_function =  libamtrack.AT_single_impact_local_dose_distrib
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_N2, c_f1_parameters, c_n_bins_f1, c_stopping_power_source_no, c_f1_d_Gy, c_f1_dd_Gy, c_f1)
	return c_output,  c_f1_d_Gy._obj, c_f1_dd_Gy._obj, c_f1._obj


def AT_n_bins_for_low_fluence_local_dose_distribution ( u, fluence_factor, N2, n_bins_f1, f1_d_Gy, f1_dd_Gy, f1, n_bins_f, u_start, n_convolutions):
	'''
	 * Estimates the size of the array to hold the resulting f local dose distribution for a given field, rdd, er
	 * Usually step 3 of the CPP-SC method
	 * @param[in]  u                   mean number of tracks contributing to the representative point
	 * @param[in]  fluence_factor      variable to tweak the total dose from the mixed field (rather than change the single components fluences)
	 * @param[in]  N2                  number of bins per factor of two in local dose array
	 * @param[in]  n_bins_f1           number of bins holding the f1 distribution (from AT_SC_get_f1_array_size)
	 * @param[in]  f1_d_Gy             bin midpoints for f1 (array of size n_bins_f1)
	 * @param[in]  f1_dd_Gy            bin width for f1 (array of size n_bins_f1)
	 * @param[in]  f1                  f1 values (array of size n_bins_f1)
	 * @param[out] n_bins_f            number of bins holding the resulting f local dose distribution
	 * @param[out] u_start             value for u to start convolutions with, between 0.001 and 0.002 where linearization of f into no and one impact is valid
	 * @param[out] n_convolutions      number of convolutions necessary to get from u_start to u (u = 2^n_convolutions * u_start)
	'''
	tmp_array =ctypes.c_double* len(f1_dd_Gy)
	c_f1_dd_Gy = ctypes.byref(tmp_array(*f1_dd_Gy))

	c_fluence_factor = ctypes.c_double(fluence_factor)
	tmp_array =ctypes.c_double* len(f1)
	c_f1 = ctypes.byref(tmp_array(*f1))

	c_n_bins_f1 = ctypes.c_long(n_bins_f1)
	c_n_convolutions =  ctypes.byref(ctypes.c_long(n_convolutions))

	c_u_start =  ctypes.byref(ctypes.c_double(u_start))

	c_u = ctypes.c_double(u)
	c_n_bins_f =  ctypes.byref(ctypes.c_long(n_bins_f))

	c_N2 = ctypes.c_long(N2)
	tmp_array =ctypes.c_double* len(f1_d_Gy)
	c_f1_d_Gy = ctypes.byref(tmp_array(*f1_d_Gy))

	c_function =  libamtrack.AT_n_bins_for_low_fluence_local_dose_distribution
	c_output = c_function( c_u, c_fluence_factor, c_N2, c_n_bins_f1, c_f1_d_Gy, c_f1_dd_Gy, c_f1, c_n_bins_f, c_u_start, c_n_convolutions)
	return c_output,  c_n_convolutions._obj.value, c_n_bins_f._obj.value, c_u_start._obj.value


def AT_low_fluence_local_dose_distribution ( n_bins_f1, N2, f1_d_Gy, f1_dd_Gy, f1, n_bins_f, f_d_Gy, f_dd_Gy, f_start):
	'''
	 * Computes the (linearized) local dose distribution to start convolutions with, i.e. f at u_start
	 * TODO why is it f at u_start ? u_start is not used in function body
	 * Usually step 4 of the CPP-SC method
	 * @param[in]  n_bins_f1           number of bins holding the f1 distribution (from AT_SC_get_f1_array_size)
	 * @param[in]  N2                  number of bins per factor of two in local dose array
	 * @param[in]  f1_d_Gy             bin midpoints for f1 (array of size n_bins_f1)
	 * @param[in]  f1_dd_Gy            bin width for f1 (array of size n_bins_f1)
	 * @param[in]  f1                  f1 values (array of size n_bins_f1)
	 * @param[in]  n_bins_f            number of bins holding the resulting f local dose distribution (from AT_SC_get_f_array_size)
	 * @param[out] f_d_Gy              bin midpoints for f (array of size n_bins_f)
	 * @param[out] f_dd_Gy             bin widths for f (array of size n_bins_f)
	 * @param[out] f_start             f values to start with (array of size n_bins_f)
	'''
	tmp_array =ctypes.c_double* len(f1_dd_Gy)
	c_f1_dd_Gy = ctypes.byref(tmp_array(*f1_dd_Gy))

	tmp_array =ctypes.c_double* len(f1)
	c_f1 = ctypes.byref(tmp_array(*f1))

	c_n_bins_f1 = ctypes.c_long(n_bins_f1)
	tmp_array = (ctypes.c_double*n_bins_f)()
	c_f_d_Gy= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n_bins_f)()
	c_f_start= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n_bins_f)()
	c_f_dd_Gy= ctypes.byref(tmp_array)

	c_n_bins_f = ctypes.c_long(n_bins_f)
	c_N2 = ctypes.c_long(N2)
	tmp_array =ctypes.c_double* len(f1_d_Gy)
	c_f1_d_Gy = ctypes.byref(tmp_array(*f1_d_Gy))

	c_function =  libamtrack.AT_low_fluence_local_dose_distribution
	c_output = c_function( c_n_bins_f1, c_N2, c_f1_d_Gy, c_f1_dd_Gy, c_f1, c_n_bins_f, c_f_d_Gy, c_f_dd_Gy, c_f_start)
	return c_output,  c_f_d_Gy._obj, c_f_dd_Gy._obj, c_f_start._obj


def AT_SuccessiveConvolutions ( final_mean_number_of_tracks_contrib, n_bins, N2, n_bins_f_used, f_d_Gy, f_dd_Gy, f, f0, fdd, dfdd, d, write_output, shrink_tails, shrink_tails_under, adjust_N2):
	'''
	 * Routine to perform the convolutions from initial linearized local dose distribution f_start to resulting f
	 * as described by Kellerer, 1969. This is a to most extend a reimplementation of Kellerer\'s original FORTRAN IV code.
	 * Usually step 5 of the CPP-SC method
	 *
	 * @param[in]      final_mean_number_of_tracks_contrib                   value for u to start convolutions with, between 0.001 and 0.002 where linearization of f into no and one impact is valid (from AT_SC_get_f_array_size)
	 * @param[in]      n_bins              Size of arrays convolutions are performed on
	 * @param[in,out]  N2                  number of bins per factor of two in local dose array f_start, will return new value in case it was adjusted by the routine (higher resolution in case of high fluences)
	 * @param[in,out]  n_bins_f_used       in number of bins used for f_start, out number of bins used for resulting. As tails can be cut and N2 adjusted this is usually not the array size for f_d_Gy, f_dd_Gy, f but smaller (so entries 0 to n_bins_f_used-1 are used)
	 * @param[in,out]  f_d_Gy              bin midpoints for f (array of size n_bins)
	 * @param[in,out]  f_dd_Gy             bin widths for f (array of size n_bins)
	 * @param[in,out]  f                   in low fluence approx values to start with, out resulting values after convolutions (array of size n_bins)
	 * @param[out]     f0                  zero-dose f value (as bins are log this has to be separated)
	 * @param[out]     fdd                 frequency f x f_dd_Gy precomputed for comfort (array of size n_bins)
	 * @param[out]     dfdd                dose contribution f x f_dd_Gy precomputed for comfort (array of size n_bins)
	 * @param[out]     d                   first moment of distribution f - should coincide with given dose and provides check on convolution quality
	 * @param[in]      write_output        if true, a very verbose log file will be written ("SuccessiveConvolutions.log") with results from each convolution
	 * @param[in]      shrink_tails        if true, the upper and lower tail of f will be cut after every convolution (bins that contribute less than "shrink_tails_under" to the first moment @<d@>)
	 * @param[in]      shrink_tails_under  cut threshold for tails
	 * @param[in]      adjust_N2           if true, N2 (i.e. the bin density) can be adjusted. This can be necessary esp. for high doses or fluences where f gets very narrow
	'''
	c_f0 =  ctypes.byref(ctypes.c_double(f0))

	tmp_array = (ctypes.c_double*n_bins)()
	c_fdd= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(f)
	c_f = ctypes.byref(tmp_array(*f))

	c_n_bins = ctypes.c_long(n_bins)
	tmp_array = (ctypes.c_double*n_bins)()
	c_dfdd= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(f_d_Gy)
	c_f_d_Gy = ctypes.byref(tmp_array(*f_d_Gy))

	c_adjust_N2 = ctypes.c_bool(adjust_N2)
	c_shrink_tails_under = ctypes.c_double(shrink_tails_under)
	tmp_array =ctypes.c_double* len(f_dd_Gy)
	c_f_dd_Gy = ctypes.byref(tmp_array(*f_dd_Gy))

	c_n_bins_f_used = ctypes.c_long(n_bins_f_used)
	c_final_mean_number_of_tracks_contrib = ctypes.c_double(final_mean_number_of_tracks_contrib)
	c_write_output = ctypes.c_bool(write_output)
	c_N2 = ctypes.c_long(N2)
	c_shrink_tails = ctypes.c_bool(shrink_tails)
	c_d =  ctypes.byref(ctypes.c_double(d))

	c_function =  libamtrack.AT_SuccessiveConvolutions
	c_output = c_function( c_final_mean_number_of_tracks_contrib, c_n_bins, c_N2, c_n_bins_f_used, c_f_d_Gy, c_f_dd_Gy, c_f, c_f0, c_fdd, c_dfdd, c_d, c_write_output, c_shrink_tails, c_shrink_tails_under, c_adjust_N2)
	return c_output,  c_dfdd._obj, c_d._obj.value, c_f0._obj.value, c_fdd._obj


def AT_Kellerer_normalize ( values_first_bin, value_midpoints, value_bin_widths, frequency_n_bins, frequency_zero_bin, frequency_first_bin, frequency):
	'''
	 * Normalized the distribution resulting from last convolution
	 *
	 * @param[in]      values_first_bin    TODO
	 * @param[in]      value_midpoints    TODO (array of size frequency_n_bins)
	 * @param[in]      value_bin_widths    TODO (array of size frequency_n_bins)
	 * @param[in]      frequency_n_bins    TODO
	 * @param[in]      frequency_zero_bin    TODO
	 * @param[in]      frequency_first_bin    TODO
	 * @param[out]     frequency               TODO (array of size frequency_n_bins)
	'''
	c_frequency_first_bin = ctypes.c_long(frequency_first_bin)
	c_frequency_n_bins = ctypes.c_long(frequency_n_bins)
	c_values_first_bin = ctypes.c_long(values_first_bin)
	tmp_array = (ctypes.c_double*frequency_n_bins)()
	c_frequency= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(value_bin_widths)
	c_value_bin_widths = ctypes.byref(tmp_array(*value_bin_widths))

	tmp_array =ctypes.c_double* len(value_midpoints)
	c_value_midpoints = ctypes.byref(tmp_array(*value_midpoints))

	c_frequency_zero_bin = ctypes.c_double(frequency_zero_bin)
	c_function =  libamtrack.AT_Kellerer_normalize
	c_output = c_function( c_values_first_bin, c_value_midpoints, c_value_bin_widths, c_frequency_n_bins, c_frequency_zero_bin, c_frequency_first_bin, c_frequency)
	return c_output,  c_frequency._obj


def AT_Kellerer_interpolation ( N2, LEF, array_size, F, A, BI):
	'''
	 * Calculates arrays A and B to be used in quadratic extrapolation of F in AT_SC_FOLD
	 *
	 * @param[in]       N2             TODO
	 * @param[in]       LEF             TODO
	 * @param[in]       array_size             TODO
	 * @param[in]       F             TODO (array of size array_size)
	 * @param[out]       A             TODO (array of size array_size)
	 * @param[out]       BI             TODO (array of size array_size)
	'''
	tmp_array = (ctypes.c_double*array_size)()
	c_A= ctypes.byref(tmp_array)

	c_LEF = ctypes.c_long(LEF)
	tmp_array =ctypes.c_double* len(F)
	c_F = ctypes.byref(tmp_array(*F))

	c_array_size = ctypes.c_long(array_size)
	tmp_array = (ctypes.c_double*array_size)()
	c_BI= ctypes.byref(tmp_array)

	c_N2 = ctypes.c_long(N2)
	c_function =  libamtrack.AT_Kellerer_interpolation
	c_output = c_function( c_N2, c_LEF, c_array_size, c_F, c_A, c_BI)
	return c_output,  c_A._obj, c_BI._obj


def AT_Kellerer_reset ( N2, array_size, LEF, MIE, MIF, E0, E, DE, F, DI):
	'''
	 * Selects a new coordinate system if F has become to narrow
	 *
	 * @param[in]       N2             TODO
	 * @param[in]       array_size             TODO
	 * @param[in,out]       LEF             TODO
	 * @param[in,out]       MIE             TODO
	 * @param[in,out]       MIF             TODO
	 * @param[in]       E0             TODO
	 * @param[in,out]       E             TODO (array of size array_size)
	 * @param[in,out]       DE             TODO (array of size array_size)
	 * @param[in,out]       F             TODO (array of size array_size)
	 * @param[in,out]       DI             TODO (array of size array_size)
	'''
	tmp_array =ctypes.c_double* len(F)
	c_F = ctypes.byref(tmp_array(*F))

	tmp_array =ctypes.c_double* len(E)
	c_E = ctypes.byref(tmp_array(*E))

	c_LEF = ctypes.c_long(LEF)
	c_array_size = ctypes.c_long(array_size)
	tmp_array =ctypes.c_double* len(DE)
	c_DE = ctypes.byref(tmp_array(*DE))

	c_MIE = ctypes.c_long(MIE)
	c_MIF = ctypes.c_long(MIF)
	tmp_array =ctypes.c_double* len(DI)
	c_DI = ctypes.byref(tmp_array(*DI))

	c_N2 = ctypes.c_long(N2)
	c_E0 = ctypes.c_double(E0)
	c_function =  libamtrack.AT_Kellerer_reset
	c_output = c_function( c_N2, c_array_size, c_LEF, c_MIE, c_MIF, c_E0, c_E, c_DE, c_F, c_DI)
	return c_output


def AT_Kellerer_zero ( MIF, array_size, MIE, LEF, F0, F, DE, MIH, LEH, H):
	'''
	 * Adds the term 2*F0*F(L) to H(L)
	 *
	 * @param[in]       MIF             TODO
	 * @param[in]       array_size             TODO
	 * @param[in]       MIE             TODO
	 * @param[in]       LEF             TODO
	 * @param[in]       F0             TODO
	 * @param[in]       F             TODO (array of size array_size)
	 * @param[in]       DE             TODO (array of size array_size)
	 * @param[in,out]       MIH             TODO
	 * @param[in,out]       LEH             TODO
	 * @param[in,out]       H             TODO (array of size array_size)
	'''
	c_F0 = ctypes.c_double(F0)
	c_MIH = ctypes.c_long(MIH)
	tmp_array =ctypes.c_double* len(DE)
	c_DE = ctypes.byref(tmp_array(*DE))

	c_LEF = ctypes.c_long(LEF)
	tmp_array =ctypes.c_double* len(F)
	c_F = ctypes.byref(tmp_array(*F))

	c_LEH = ctypes.c_long(LEH)
	tmp_array =ctypes.c_double* len(H)
	c_H = ctypes.byref(tmp_array(*H))

	c_array_size = ctypes.c_long(array_size)
	c_MIE = ctypes.c_long(MIE)
	c_MIF = ctypes.c_long(MIF)
	c_function =  libamtrack.AT_Kellerer_zero
	c_output = c_function( c_MIF, c_array_size, c_MIE, c_LEF, c_F0, c_F, c_DE, c_MIH, c_LEH, c_H)
	return c_output


def AT_Kellerer_shrink ( array_size, MIE, shrink_tails_under, DE, MIH, LEH, H):
	'''
	 * Cuts tails of distribution that contribute less that shrink_tails_under to @<f@>
	 *
	 * @param[in]       array_size             TODO
	 * @param[in]       MIE             TODO
	 * @param[in]       shrink_tails_under             TODO
	 * @param[in]       DE             TODO (array of size array_size)
	 * @param[in,out]       MIH             TODO
	 * @param[in,out]       LEH             TODO
	 * @param[in,out]       H             TODO (array of size array_size)
	'''
	c_MIH = ctypes.c_long(MIH)
	c_array_size = ctypes.c_long(array_size)
	c_LEH = ctypes.c_long(LEH)
	tmp_array =ctypes.c_double* len(H)
	c_H = ctypes.byref(tmp_array(*H))

	tmp_array =ctypes.c_double* len(DE)
	c_DE = ctypes.byref(tmp_array(*DE))

	c_MIE = ctypes.c_long(MIE)
	c_shrink_tails_under = ctypes.c_double(shrink_tails_under)
	c_function =  libamtrack.AT_Kellerer_shrink
	c_output = c_function( c_array_size, c_MIE, c_shrink_tails_under, c_DE, c_MIH, c_LEH, c_H)
	return c_output


def AT_Kellerer_folding ( n_bins, bins_per_factor_2, delta_i, values_first_bin, values_bin_widths, frequency_n_bins_last, frequency_first_bin_last, frequency_zero_bin_last, frequency_last, frequency_n_bins, frequency_first_bin, frequency_zero_bin, frequency):
	'''
	 * Does actual convolution, makes use of the symmetry
	 *
	 * @param[in]       n_bins             TODO
	 * @param[in]       bins_per_factor_2             TODO
	 * @param[in]       delta_i             TODO (array of size array_size)
	 * @param[in]       values_first_bin             TODO
	 * @param[in]       values_bin_widths             TODO (array of size array_size)
	 * @param[in]       frequency_n_bins_last             TODO
	 * @param[in]       frequency_first_bin_last             TODO
	 * @param[in]       frequency_zero_bin_last             TODO
	 * @param[in,out]   frequency_last             TODO (array of size array_size)
	 * @param[in,out]   frequency_n_bins             TODO
	 * @param[in,out]   frequency_first_bin             TODO
	 * @param[in,out]   frequency_zero_bin             TODO
	 * @param[in,out]   frequency             TODO (array of size array_size)
	'''
	c_frequency_n_bins = ctypes.c_long(frequency_n_bins)
	c_frequency_zero_bin = ctypes.c_double(frequency_zero_bin)
	c_bins_per_factor_2 = ctypes.c_long(bins_per_factor_2)
	c_frequency_first_bin = ctypes.c_long(frequency_first_bin)
	c_n_bins = ctypes.c_long(n_bins)
	c_frequency_n_bins_last = ctypes.c_long(frequency_n_bins_last)
	tmp_array =ctypes.c_double* len(values_bin_widths)
	c_values_bin_widths = ctypes.byref(tmp_array(*values_bin_widths))

	c_frequency_zero_bin_last = ctypes.c_double(frequency_zero_bin_last)
	c_frequency_first_bin_last = ctypes.c_long(frequency_first_bin_last)
	c_values_first_bin = ctypes.c_long(values_first_bin)
	tmp_array =ctypes.c_double* len(frequency)
	c_frequency = ctypes.byref(tmp_array(*frequency))

	tmp_array =ctypes.c_double* len(delta_i)
	c_delta_i = ctypes.byref(tmp_array(*delta_i))

	tmp_array =ctypes.c_double* len(frequency_last)
	c_frequency_last = ctypes.byref(tmp_array(*frequency_last))

	c_function =  libamtrack.AT_Kellerer_folding
	c_output = c_function( c_n_bins, c_bins_per_factor_2, c_delta_i, c_values_first_bin, c_values_bin_widths, c_frequency_n_bins_last, c_frequency_first_bin_last, c_frequency_zero_bin_last, c_frequency_last, c_frequency_n_bins, c_frequency_first_bin, c_frequency_zero_bin, c_frequency)
	return c_output


def AT_test_fun ( a, b):
	'''
	 * Simple test function (sum) to check for availability and functionality of
	 * libamtrack during configure-process
	 *
	 * @param[in]      a     			first number to add
	 * @param[in]      b                second number to add
	 * @return                          sum of a and b
	'''
	c_a = ctypes.c_double(a)
	c_b = (b)
	c_function =  libamtrack.AT_test_fun
	c_function.restype = ctypes.c_double
	c_output = c_function( c_a, c_b)
	return c_output

# problem with function This (zero parameters)
# comment [' * @struct AT_stopping_power_tabulated_source_group_struct\n', ' * TODO\n', ' */\n', 'typedef struct {\n']

def AT_stopping_power_source_model_name_from_number ( source_no, source_name):
	'''
	 * TODO
	 * @param[in]  source_no
	 * @param[out] source_name
	 * @return statuc code
	'''
	c_source_name =  ctypes.byref(ctypes.c_char(source_name))

	c_source_no = ctypes.c_long(source_no)
	c_function =  libamtrack.AT_stopping_power_source_model_name_from_number
	c_function.restype = ctypes.c_int
	c_output = c_function( c_source_no, c_source_name)
	return c_output,  c_source_name._obj.value


def AT_stopping_power_source_model_number_from_name ( source_name):
	'''
	 * TODO
	 * @param[in] source_name
	 * @return    source number
	'''
	c_source_name = ctypes.c_char(source_name)
	c_function =  libamtrack.AT_stopping_power_source_model_number_from_name
	c_function.restype = ctypes.c_long
	c_output = c_function( c_source_name)
	return c_output


def AT_Bethe_wrapper ( E_MeV_u, particle_no, material_no):
	'''
	 * Wrapper for Bethe analytical function
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @return
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Bethe_wrapper
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_ShieldHit_wrapper ( E_MeV_u, particle_no, material_no):
	'''
	 * Wrapper for ShieldHit stopping powers
	 * momentarily read from hardwired struct for water
	 * TODO: augment by routine to read data file into
	 * TODO: struct and look-up value
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @return stopping power (MeV cm2 per g)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_ShieldHit_wrapper
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_ICRU_wrapper ( E_MeV_u, particle_no, material_no):
	'''
	 * Wrapper for ICRU stopping powers
	 * momentarily read from hardwired struct for water
	 * TODO: augment by routine to read data file into
	 * TODO: struct and look-up value
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @return stopping power (MeV cm2 per g)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_ICRU_wrapper
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no)
	return c_output

# problem with function _AT_Stopping_Power_get_data (zero parameters)
# comment [' * TODO\n']

def AT_Stopping_Power_data_interpolation ( stopping_power_source_no, E_MeV_u, particle_no, material_no):
	'''
	 * Interpolation over tabulated Stopping Power data
	 * @param[in] stopping_power_source_no
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @return    gives stopping power for given energy
	'''
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Stopping_Power_data_interpolation
	c_function.restype = ctypes.c_double
	c_output = c_function( c_stopping_power_source_no, c_E_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_Stopping_Power_MeV_cm2_g_single ( stopping_power_source_no, E_MeV_u, particle_no, material_no):
	'''
	 * Main access method to stopping power data
	 * @param[in] stopping_power_source_no
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @return stopping power
	'''
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Stopping_Power_MeV_cm2_g_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_stopping_power_source_no, c_E_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_Stopping_Power_MeV_cm2_g_multi ( stopping_power_source_no, number_of_particles, E_MeV_u, particle_no, material_no, Stopping_Power_MeV_cm2_g):
	'''
	 * Main access method to stopping power data - multiple field
	 * @param[in] stopping_power_source_no
	 * @param[in] number_of_particles
	 * @param[in] E_MeV_u (array of size number_of_particles)
	 * @param[in] particle_no (array of size number_of_particles)
	 * @param[in] material_no
	 * @param[out] Stopping_Power_MeV_cm2_g (array of size number_of_particles)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*number_of_particles)()
	c_Stopping_Power_MeV_cm2_g= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_number_of_particles = ctypes.c_long(number_of_particles)
	c_function =  libamtrack.AT_Stopping_Power_MeV_cm2_g_multi
	c_output = c_function( c_stopping_power_source_no, c_number_of_particles, c_E_MeV_u, c_particle_no, c_material_no, c_Stopping_Power_MeV_cm2_g)
	return c_output,  c_Stopping_Power_MeV_cm2_g._obj


def AT_Stopping_Power_keV_um_single ( stopping_power_source_no, E_MeV_u, particle_no, material_no):
	'''
	 * Main access method to stopping power data
	 * @param[in] stopping_power_source_no
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @return stopping power
	'''
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Stopping_Power_keV_um_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_stopping_power_source_no, c_E_MeV_u, c_particle_no, c_material_no)
	return c_output


def AT_Stopping_Power_keV_um_multi ( stopping_power_source_no, number_of_particles, E_MeV_u, particle_no, material_no, Stopping_Power_keV_um):
	'''
	 * Main access method to stopping power data - multiple field
	 * @param[in] stopping_power_source_no
	 * @param[in] number_of_particles
	 * @param[in] E_MeV_u (array of size number_of_particles)
	 * @param[in] particle_no (array of size number_of_particles)
	 * @param[in] material_no
	 * @param[out] Stopping_Power_keV_um (array of size number_of_particles)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*number_of_particles)()
	c_Stopping_Power_keV_um= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_number_of_particles = ctypes.c_long(number_of_particles)
	c_function =  libamtrack.AT_Stopping_Power_keV_um_multi
	c_output = c_function( c_stopping_power_source_no, c_number_of_particles, c_E_MeV_u, c_particle_no, c_material_no, c_Stopping_Power_keV_um)
	return c_output,  c_Stopping_Power_keV_um._obj


def AT_Energy_MeV_u_from_Stopping_Power_single ( stopping_power_source_no, Stopping_Power_MeV_cm2_g, particle_no, material_no):
	'''
	 * TODO
	 * @param[in] stopping_power_source_no
	 * @param[in] Stopping_Power_MeV_cm2_g
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @return range [m]
	'''
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_material_no = ctypes.c_long(material_no)
	c_Stopping_Power_MeV_cm2_g = ctypes.c_double(Stopping_Power_MeV_cm2_g)
	c_particle_no = ctypes.c_long(particle_no)
	c_function =  libamtrack.AT_Energy_MeV_u_from_Stopping_Power_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_stopping_power_source_no, c_Stopping_Power_MeV_cm2_g, c_particle_no, c_material_no)
	return c_output


def AT_Stopping_Power_Bethe_Number ( E_MeV_u, particle_no, material_no, E_restricted_keV):
	'''
	 * Computes the stopping number to be used with the Bethe formula
	 * according to ICRU49, p.6, Eq. 2.3
	 * BUT WITHOUT shell or density correction!
	 * @param[in]  	   E_MeV_u      energy of particle per nucleon
	 * @param[in]  	   particle_no  particle index
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]      E_restricted_keV 	if positive and smaller than maximally transferable energy, the restricted stopping number will be computed
	 * @return     result
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_restricted_keV = ctypes.c_double(E_restricted_keV)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Stopping_Power_Bethe_Number
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_E_restricted_keV)
	return c_output


def AT_Stopping_Power_Mass_Bethe_MeV_cm2_g_single ( E_MeV_u, particle_no, material_no, E_restricted_keV):
	'''
	 * Computes the mass stopping power using the Bethe formula
	 * according to ICRU49, p.6, Eq. 2.1
	 * BUT WITHOUT shell or density, Bloch or Barkas correction!
	 * @param[in]  	   E_MeV_u      energy of particle per nucleon
	 * @param[in]  	   particle_no  particle index
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]      E_restricted_keV 	if positive and smaller than maximally transferable energy, the restricted stopping power will be computed
	 * @return     result
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_E_restricted_keV = ctypes.c_double(E_restricted_keV)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Stopping_Power_Mass_Bethe_MeV_cm2_g_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_E_restricted_keV)
	return c_output


def AT_Stopping_Power_Mass_Bethe_MeV_cm2_g_multi ( n, E_MeV_u, particle_no, material_no, E_restricted_keV, Mass_Stopping_Power_MeV_cm2_g):
	'''
	 * Computes the mass stopping power using the Bethe formula
	 * for many particles according to ICRU49, p.6, Eq. 2.1
	 * BUT WITHOUT shell or density, Bloch or Barkas correction!
	 * @param[in]  	   n      		number of particles
	 * @param[in]  	   E_MeV_u      energies of particle per nucleon (array of size n)
	 * @param[in]  	   particle_no  particle indices (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no  material index (single value)
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]      E_restricted_keV 	if positive and smaller than maximally transferable energy, the restricted stopping power will be computed (single value)
	 * @param[out]     Mass_Stopping_Power_MeV_cm2_g (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_E_restricted_keV = ctypes.c_double(E_restricted_keV)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_Mass_Stopping_Power_MeV_cm2_g= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_Stopping_Power_Mass_Bethe_MeV_cm2_g_multi
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_E_restricted_keV, c_Mass_Stopping_Power_MeV_cm2_g)
	return c_output,  c_Mass_Stopping_Power_MeV_cm2_g._obj


def AT_Rutherford_SDCS ( E_MeV_u, particle_no, material_no, n, T_MeV, dsdT_m2_MeV):
	'''
	 * Computes the Rutherford single differential cross section
	 * for the energy spectrum of secondary electrons produced by
	 * an HCP
	 * @param[in]  	   E_MeV_u      energy of particle per nucleon
	 * @param[in]  	   particle_no  particle index
	 * @param[in]      material_no  material index
	 * @param[in]  	   n      		number of secondary electron energies
	 * @param[in]      T_MeV 	    electron energies (array of size n)
	 * @param[out]     dsdT_m2_MeV  Rutherford SDCS for given electron energies (array of size n)
	 * @return         status code
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(T_MeV)
	c_T_MeV = ctypes.byref(tmp_array(*T_MeV))

	c_n = ctypes.c_long(n)
	tmp_array = (ctypes.c_double*n)()
	c_dsdT_m2_MeV= ctypes.byref(tmp_array)

	c_particle_no = ctypes.c_long(particle_no)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_Rutherford_SDCS
	c_function.restype = ctypes.c_int
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_n, c_T_MeV, c_dsdT_m2_MeV)
	return c_output,  c_dsdT_m2_MeV._obj


def AT_RDD_index_from_RDD_number ( RDD_number):
	'''
	 * Get index of RDD in AT_RDD_Data for given RDD_number
	 * (currently for example RDD with number 2 has index 1)
	 *
	 * @param[in] RDD_number  RDD number
	 * @return            RDD index in AT_RDD_Data table
	'''
	c_RDD_number = ctypes.c_long(RDD_number)
	c_function =  libamtrack.AT_RDD_index_from_RDD_number
	c_function.restype = ctypes.c_long
	c_output = c_function( c_RDD_number)
	return c_output


def AT_RDD_name_from_number ( RDD_no, RDD_name):
	'''
	 * Returns name of the radial dose distribution model from model number
	 *
	 * @param[in]   RDD_no   radial dose distribution model number
	 * @param[out]  RDD_name string containing radial dose distribution model name
	 * @return      status code
	'''
	c_RDD_name =  ctypes.byref(ctypes.c_char(RDD_name))

	c_RDD_no = ctypes.c_long(RDD_no)
	c_function =  libamtrack.AT_RDD_name_from_number
	c_function.restype = ctypes.c_int
	c_output = c_function( c_RDD_no, c_RDD_name)
	return c_output,  c_RDD_name._obj.value


def AT_RDD_number_from_name ( RDD_name):
	'''
	 * Returns number of the radial dose distribution model from its name
	 *
	 * @param[in]   RDD_name  string containing radial dose distribution model name
	 * @return      RDD_no    radial dose distribution model index
	'''
	c_RDD_name = ctypes.c_char(RDD_name)
	c_function =  libamtrack.AT_RDD_number_from_name
	c_function.restype = ctypes.c_long
	c_output = c_function( c_RDD_name)
	return c_output


def AT_RDD_number_of_parameters ( RDD_model):
	'''
	 * Returns number of parameters of the radial dose distribution model from model number
	 *
	 * @param[in]   RDD_model   radial dose distribution model number
	 * return                   number of RDD parameters
	'''
	c_RDD_model = ctypes.c_long(RDD_model)
	c_function =  libamtrack.AT_RDD_number_of_parameters
	c_output = c_function( c_RDD_model)
	return c_output


def AT_D_RDD_Gy ( n, r_m, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no, D_RDD_Gy):
	'''
	 * Returns local dose as a function of distance r_m for a given radial dose distribution model
	 *
	 * @param[in]   n              number of particles (length of r_m vector)
	 * @param[in]   r_m            distance [m] (array of size n)
	 * @param[in]   E_MeV_u        particle (ion) energy per nucleon [MeV/u] (single number, no mixed fields)
	 * @param[in]   particle_no    particle code number (single number, no mixed fields)
	 * @param[in]   material_no    material code number (single number, no mixed fields)
	 * @param[in]   rdd_model      radial dose distribution model index
	 * @param[in]   rdd_parameter  radial dose distribution model parameters (array of size 4)
	 * @param[in]   er_model       electron range / track with model index
	 * @param[in]   stopping_power_source_no  TODO
	 * @param[out]  D_RDD_Gy       dose [Gy] (array of size n)
	 * @return status code
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	tmp_array = (ctypes.c_double*n)()
	c_D_RDD_Gy= ctypes.byref(tmp_array)

	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_er_model = ctypes.c_long(er_model)
	tmp_array =ctypes.c_double* len(r_m)
	c_r_m = ctypes.byref(tmp_array(*r_m))

	c_particle_no = ctypes.c_long(particle_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_D_RDD_Gy
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_r_m, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no, c_D_RDD_Gy)
	return c_output,  c_D_RDD_Gy._obj


def AT_r_RDD_m ( n, D_RDD_Gy, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no, r_RDD_m):
	'''
	 * Returns distance as a function of dose
	 *
	 * @param[in]   n                   number of particles (length of D_RDD_Gy vector)
	 * @param[in]   D_RDD_Gy            dose [Gy] (array of size n)
	 * @param[in]   E_MeV_u             particle (ion) energy per nucleon [MeV/u]
	 * @param[in]   particle_no         particle code number
	 * @param[in]   material_no         material code number
	 * @param[in]   rdd_model           Radial Dose Distribution model code number
	 * @param[in]   rdd_parameter       Radial Dose Distribution model parameters vector (array of size 4)
	 * @param[in]   er_model            delta electron range model code number
	 * @param[in]   stopping_power_source_no   TODO
	 * @param[out]  r_RDD_m             distance [m] (array of size n)
	 * @return status code
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	tmp_array =ctypes.c_double* len(D_RDD_Gy)
	c_D_RDD_Gy = ctypes.byref(tmp_array(*D_RDD_Gy))

	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_er_model = ctypes.c_long(er_model)
	tmp_array = (ctypes.c_double*n)()
	c_r_RDD_m= ctypes.byref(tmp_array)

	c_particle_no = ctypes.c_long(particle_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_r_RDD_m
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_D_RDD_Gy, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no, c_r_RDD_m)
	return c_output,  c_r_RDD_m._obj


def AT_RDD_r_min_m ( max_electron_range_m, rdd_model, rdd_parameter):
	'''
	 * Returns lower integration limit for given RDD (or 0.0 if not used).
	 * @param[in] max_electron_range_m           delta electron maximum range [m]
	 * @param[in] rdd_model                      Radial Dose Distribution model code number
	 * @param[in] rdd_parameter                  Radial Dose Distribution model parameters vector  (array of size 3)
	 * @return rmin - lower integration limit for given RDD [m]
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_rdd_model = ctypes.c_long(rdd_model)
	c_function =  libamtrack.AT_RDD_r_min_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_max_electron_range_m, c_rdd_model, c_rdd_parameter)
	return c_output


def AT_RDD_a0_m ( max_electron_range_m, rdd_model, rdd_parameter):
	'''
	 * Returns target size (core size) for given RDD (or 0.0 if not used).
	 * @param[in] max_electron_range_m           delta electron maximum range [m]
	 * @param[in] rdd_model                      Radial Dose Distribution model code number
	 * @param[in] rdd_parameter                  Radial Dose Distribution model parameters vector  (array of size 3)
	 * @return a0 - target size (core size) for given RDD [m]
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_rdd_model = ctypes.c_long(rdd_model)
	c_function =  libamtrack.AT_RDD_a0_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_max_electron_range_m, c_rdd_model, c_rdd_parameter)
	return c_output


def AT_RDD_precalculated_constant_Gy ( max_electron_range_m, LET_MeV_cm2_g, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model):
	'''
	 * Returns precalculated constant for given RDD: normalization factor or some coefficient
	 * @param[in] max_electron_range_m           delta electron maximum range [m]
	 * @param[in] LET_MeV_cm2_g
	 * @param[in] E_MeV_u                        particle (ion) energy per nucleon [MeV/u]
	 * @param[in] particle_no                    particle code number
	 * @param[in] material_no                    material code number
	 * @param[in] rdd_model                      Radial Dose Distribution model code number
	 * @param[in] rdd_parameter                  Radial Dose Distribution model parameters vector  (array of size 3)
	 * @param[in] er_model                       delta electron range model code number
	 * @return precalculated constant for given RDD [Gy]
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_LET_MeV_cm2_g = ctypes.c_double(LET_MeV_cm2_g)
	c_er_model = ctypes.c_long(er_model)
	c_particle_no = ctypes.c_long(particle_no)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_function =  libamtrack.AT_RDD_precalculated_constant_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_max_electron_range_m, c_LET_MeV_cm2_g, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model)
	return c_output


def AT_RDD_d_min_Gy ( E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, precalculated_constant_Gy):
	'''
	 * Returns minimal dose for given RDD: either value given by user is taken
	 * (in case of RDDs which gives zero-dose at maximum range (rmax))
	 * or value of RDD is calculated at rmax and it is taken as Dmax (if higher than user
	 * provided value).
	 * @param[in] E_MeV_u                         particle (ion) energy per nucleon [MeV/u]
	 * @param[in] particle_no                     particle code number
	 * @param[in] material_no                     material code number
	 * @param[in] rdd_model                       Radial Dose Distribution model code number
	 * @param[in] rdd_parameter                   Radial Dose Distribution model parameters vector  (array of size 3)
	 * @param[in] er_model                        delta electron range model code number
	 * @param[in] precalculated_constant_Gy
	 * @return minimal dose for given RDD [Gy]
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_er_model = ctypes.c_long(er_model)
	c_precalculated_constant_Gy = ctypes.c_double(precalculated_constant_Gy)
	c_particle_no = ctypes.c_long(particle_no)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_function =  libamtrack.AT_RDD_d_min_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_precalculated_constant_Gy)
	return c_output


def AT_RDD_d_max_Gy ( E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no):
	'''
	 * Returns maximum value of the dose that it is possible to obtain with given RDD.
	 * It is calculated at r = r_min, as most of the RDDs explode to infinity at r = 0
	 * @param[in] E_MeV_u                    particle (ion) energy per nucleon [MeV/u]
	 * @param[in] particle_no                particle code number
	 * @param[in] material_no                material code number
	 * @param[in] rdd_model                  Radial Dose Distribution model code number
	 * @param[in] rdd_parameter              Radial Dose Distribution model parameters vector  (array of size 3)
	 * @param[in] er_model                   delta electron range model code number
	 * @param[in] stopping_power_source_no   TODO
	 * @return  Maximum dose [Gy]
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_er_model = ctypes.c_long(er_model)
	c_particle_no = ctypes.c_long(particle_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_function =  libamtrack.AT_RDD_d_max_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no)
	return c_output


def AT_RDD_f1_parameters_single_field ( E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no, f1_parameters):
	'''
	 * Pre-calculated many useful parameters characterizing RDD.
	 * @param[in]  E_MeV_u               particle (ion) energy per nucleon [MeV/u]
	 * @param[in]  particle_no           particle code number
	 * @param[in]  material_no           material code number
	 * @param[in]  rdd_model             Radial Dose Distribution model code number
	 * @param[in]  rdd_parameter         Radial Dose Distribution model parameters vector  (array of size 3)
	 * @param[in]  er_model              delta electron range model code number
	 * @param[in]  stopping_power_source_no     TODO
	 * @param[out] f1_parameters <br>
	 *     0 - LET_MeV_cm2_g <br>
	 *     1 - r_min_m <br>
	 *     2 - r_max_m <br>
	 *     3 - d_min_Gy <br>
	 *     4 - d_max_Gy <br>
	 *     5 - normalization constant [Gy] <br>
	 *     6 - single_impact_fluence_cm2 <br>
	 *     7 - single_impact_dose_Gy
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	tmp_array = (ctypes.c_double*1)()
	c_f1_parameters= ctypes.byref(tmp_array)

	c_er_model = ctypes.c_long(er_model)
	c_particle_no = ctypes.c_long(particle_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_function =  libamtrack.AT_RDD_f1_parameters_single_field
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no, c_f1_parameters)
	return c_output,  c_f1_parameters._obj


def AT_RDD_f1_parameters_mixed_field ( n, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no, f1_parameters):
	'''
	 * Pre-calculated many useful parameters characterizing RDD.
	 * @param[in]  n                     number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u               energy of particles in the mixed particle field (array of size n)
	 * @param[in]  particle_no           type of the particles in the mixed particle field (array of size n)
	 * @param[in]  material_no           material code number
	 * @param[in]  rdd_model             Radial Dose Distribution model code number
	 * @param[in]  rdd_parameter         Radial Dose Distribution model parameters vector  (array of size 3)
	 * @param[in]  er_model              delta electron range model code number
	 * @param[in]  stopping_power_source_no  TODO
	 * @param[out] f1_parameters  (array of size 8)
	 *     0 - LET_MeV_cm2_g \n
	 *     1 - r_min_m \n
	 *     2 - r_max_m \n
	 *     3 - d_min_Gy \n
	 *     4 - d_max_Gy \n
	 *     5 - normalization constant [Gy] \n
	 *     6 - single_impact_fluence_cm2 \n
	 *     7 - single_impact_dose_Gy
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	tmp_array = (ctypes.c_double*8)()
	c_f1_parameters= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_er_model = ctypes.c_long(er_model)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	c_function =  libamtrack.AT_RDD_f1_parameters_mixed_field
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no, c_f1_parameters)
	return c_output,  c_f1_parameters._obj


def AT_RDD_Test_Gy ( r_m, r_min_m, r_max_m, norm_constant_Gy):
	'''
	 * Test RDD, flat for given range of r.
	 * @param[in] r_m
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] r_max_m
	 * @param[in] norm_constant_Gy
	 * @return
	'''
	c_norm_constant_Gy = ctypes.c_double(norm_constant_Gy)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_r_m = ctypes.c_double(r_m)
	c_r_max_m = ctypes.c_double(r_max_m)
	c_function =  libamtrack.AT_RDD_Test_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_r_min_m, c_r_max_m, c_norm_constant_Gy)
	return c_output


def AT_inverse_RDD_Test_m ( D_Gy, r_max_m):
	'''
	 * TODO
	 * @param[in] D_Gy
	 * @param[in] r_max_m                  delta electron maximum range rmax [m]
	 * @return
	'''
	c_r_max_m = ctypes.c_double(r_max_m)
	c_D_Gy = ctypes.c_double(D_Gy)
	c_function =  libamtrack.AT_inverse_RDD_Test_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_r_max_m)
	return c_output


def AT_RDD_Geiss_Gy ( r_m, r_min_m, max_electron_range_m, a0_m, norm_constant_Gy):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] max_electron_range_m
	 * @param[in] a0_m
	 * @param[in] norm_constant_Gy
	 * @return
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_norm_constant_Gy = ctypes.c_double(norm_constant_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_RDD_Geiss_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_r_min_m, c_max_electron_range_m, c_a0_m, c_norm_constant_Gy)
	return c_output


def AT_inverse_RDD_Geiss_m ( D_Gy, d_min_Gy, d_max_Gy, a0_m, norm_constant_Gy):
	'''
	 * TODO
	 * @param[in] D_Gy
	 * @param[in] d_min_Gy
	 * @param[in] d_max_Gy
	 * @param[in] a0_m
	 * @param[in] norm_constant_Gy
	 * @return
	'''
	c_d_min_Gy = ctypes.c_double(d_min_Gy)
	c_d_max_Gy = ctypes.c_double(d_max_Gy)
	c_a0_m = ctypes.c_double(a0_m)
	c_norm_constant_Gy = ctypes.c_double(norm_constant_Gy)
	c_D_Gy = ctypes.c_double(D_Gy)
	c_function =  libamtrack.AT_inverse_RDD_Geiss_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_d_min_Gy, c_d_max_Gy, c_a0_m, c_norm_constant_Gy)
	return c_output

# problem with function * (zero parameters)
# comment [' * Katz C constant given by equation:\n', ' *\n', ' * C = 2 pi N e^4 / ( m c^2 (4 pi eps_0)^2)\n', ' *\n', ' * In other form:\n', ' *\n', ' * C = N * C1 , where C1 = e^4 / ( 8 m pi (c * eps_0)^2)\n', ' *\n', ' * For water: C = 1.36662e-12 [J/m] = 8.53 [MeV/m]\n']

def AT_RDD_Katz_coeff_Gy ( Z_eff, beta, density_kg_m3, electron_density_m3, max_electron_range_m):
	'''
	 * Calculates coefficient
	 *
	 * coeff      =  (C / 2 pi) * (Zeff/beta)^2 * 1/rho * 1 /rmax^2
	 *
	 * @param[in] Z_eff                    effective ion charge Zeff
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @param[in] density_kg_m3   material density rho [kg/m^3]
	 * @param[in] electron_density_m3      electron density of given material [1/m^3]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @return coeff [Gy]                  calculated coefficient
	'''
	c_electron_density_m3 = ctypes.c_double(electron_density_m3)
	c_density_kg_m3 = ctypes.c_double(density_kg_m3)
	c_beta = ctypes.c_double(beta)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Z_eff = ctypes.c_double(Z_eff)
	c_function =  libamtrack.AT_RDD_Katz_coeff_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_Z_eff, c_beta, c_density_kg_m3, c_electron_density_m3, c_max_electron_range_m)
	return c_output


def AT_RDD_Katz_coeff_Gy_general ( E_MeV_u, particle_no, material_no, er_model):
	'''
	 * TODO
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @param[in] er_model
	 * @return
	'''
	c_material_no = ctypes.c_long(material_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_er_model = ctypes.c_long(er_model)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_RDD_Katz_coeff_Gy_general
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_particle_no, c_material_no, c_er_model)
	return c_output


def AT_RDD_Katz_LinearER_Dpoint_Gy ( r_m, max_electron_range_m, Katz_point_coeff_Gy):
	'''
	 * Calculates "old" Katz RDD (derived from linear (on wmax) ER model):
	 *
	 * D(r) = (C / 2 pi) * (Zeff/beta)^2 * 1/rho *  1/r * (1/r - 1/rmax)
	 *
	 * or:
	 *
	 * D(r) = (C / 2 pi) * (Zeff/beta)^2 * 1/rho * 1/rmax^2 * rmax/r * (rmax/r - 1.)
	 *
	 * thus:
	 *
	 * D(r) = coeff * rmax/r * (rmax/r - 1.)
	 *
	 * where:
	 *
	 * coeff      =  (C / 2 pi) * (Zeff/beta)^2 * 1/rho * 1 /rmax^2
	 *
	 * @param[in] r_m                      distance r [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return D(r) [Gy] radial dose distribution at distance r
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_function =  libamtrack.AT_RDD_Katz_LinearER_Dpoint_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_max_electron_range_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Katz_PowerLawER_Dpoint_Gy ( r_m, alpha, max_electron_range_m, Katz_point_coeff_Gy):
	'''
	 * Calculates "new" Katz RDD (derived from power-law (on wmax) ER model):
	 *
	 * D(r) = (C / 2 pi) * (Zeff/beta)^2 * 1/rho * 1/r^2 * 1/alpha * (1 - r/rmax)^(1/alpha)
	 *
	 * thus:
	 *
	 * D(r) = coeff * 1/alpha * (rmax/r)^2 * (1 - r/rmax)^(1/alpha)
	 *
	 * where:
	 *
	 * coeff      =  (C / 2 pi) * (Zeff/beta)^2 * 1/rho * 1 /rmax^2
	 *
	 * @param[in] r_m                      distance r [m]
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return D(r) [Gy] radial dose distribution at distance r
	'''
	c_alpha = ctypes.c_double(alpha)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r_m = ctypes.c_double(r_m)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_function =  libamtrack.AT_RDD_Katz_PowerLawER_Dpoint_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_alpha, c_max_electron_range_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_KatzPoint_Gy ( r_m, r_min_m, max_electron_range_m, er_model, alpha, Katz_point_coeff_Gy):
	'''
	 * Single particle implementation of Katz model RDD
	 * @param[in] r_m                      distance r [m]
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] er_model                 delta electron range model code number
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return
	'''
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_RDD_KatzPoint_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_r_min_m, c_max_electron_range_m, c_er_model, c_alpha, c_Katz_point_coeff_Gy)
	return c_output


def AT_inverse_RDD_KatzPoint_LinearER_m ( D_Gy, r_min_m, max_electron_range_m, Katz_point_coeff_Gy):
	'''
	 * TODO
	 * @param[in] D_Gy
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_D_Gy = ctypes.c_double(D_Gy)
	c_function =  libamtrack.AT_inverse_RDD_KatzPoint_LinearER_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_r_min_m, c_max_electron_range_m, c_Katz_point_coeff_Gy)
	return c_output


def AT_inverse_RDD_KatzPoint_PowerLawER_solver_function_Gy ( r_m, params):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] params
	 * @return
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_inverse_RDD_KatzPoint_PowerLawER_solver_function_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_inverse_RDD_KatzPoint_m ( D_Gy, r_min_m, max_electron_range_m, er_model, alpha, Katz_point_coeff_Gy):
	'''
	 * Single particle implementation of inverse Katz model RDD
	 * @param[in] D_Gy
	 * @param[in] r_min_m                  minimum radius cut-off distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] er_model                 delta electron range model code number
	 * @param[in] alpha                    parameter of ER model
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return
	'''
	c_D_Gy = ctypes.c_double(D_Gy)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_inverse_RDD_KatzPoint_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_r_min_m, c_max_electron_range_m, c_er_model, c_alpha, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_Cucinotta_f_shortRange ( r_m, beta):
	'''
	 * Calculates short range modification function fS(r)
	 * for Cucinotta RDD
	 *
	 * fS(r) = 1.0/( r0/r + 0.6 + 1.7 beta + 1.1 beta^2)           [here r0 = 10^(-9) [m]]
	 *
	 * @param[in] r_m                      distance [m]
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @return fS(r)
	'''
	c_beta = ctypes.c_double(beta)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_RDD_Cucinotta_f_shortRange
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_beta)
	return c_output


def AT_RDD_Cucinotta_f_longRange ( r_m, max_electron_range_m):
	'''
	 * Calculates long range modification function fL(r)
	 * for Cucinotta RDD
	 *
	 * fL(r) = exp( -(r/(0.37rmax))^2 )
	 *
	 * @param[in] r_m                      distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @return fL(r)
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_RDD_Cucinotta_f_longRange
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_max_electron_range_m)
	return c_output


def AT_RDD_Cucinotta_Ddelta_Gy ( r_m, max_electron_range_m, beta, Katz_point_coeff_Gy):
	'''
	 * Calculates radial component D_delta
	 * for Cucinotta RDD
	 *
	 * Ddelta(r) = C z^2 / beta^2 1/rho fS(r) fL(r) /r^2
	 *
	 * We calculate using pre-calculated constant in following manner:
	 *
	 * Ddelta(r) = coeff * fS(r) * fL(r) * rmax^2/r^2
	 *
	 * where:
	 *
	 * coeff      =  (C / 2 pi) * (Zeff/beta)^2 * 1/rho * 1 /rmax^2
	 *
	 * @param[in] r_m                      distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return Ddelta(r) [Gy]
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_function =  libamtrack.AT_RDD_Cucinotta_Ddelta_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_max_electron_range_m, c_beta, c_Katz_point_coeff_Gy)
	return c_output

# problem with function const (zero parameters)
# comment [' * In Cucinotta RDD we have: d = (beta/2) * (hbar * c / wr) and wr = 13eV\n', ' * Part of this can be saved as a constant: 0.5 * hbar * c / wr , where wr = 13eV\n']

def AT_RDD_Cucinotta_Dexc_Gy ( r_m, max_electron_range_m, beta, C_norm, Katz_point_coeff_Gy):
	'''
	 * Calculates excitation component D_exc
	 * for Cucinotta RDD
	 *
	 * Dexc(r) = C exp( - r / 2d ) / r^2            [where d = (beta/2) * (hbar * c / wr) and wr = 13eV ]
	 *
	 * We calculate using pre-calculated constant in following manner:
	 *
	 * Dexc(r) = Cnorm * coeff * exp( - r / 2d ) * (rmax/r)^2
	 *
	 * where:
	 *
	 * coeff      =  (C / 2 pi) * (Zeff/beta)^2 * 1/rho * 1 /rmax^2
	 *
	 * Cnorm      =  Cnorm = (LET / (2 pi rho * ((pi rmax^2 - pi rmin^2)) ) - Ddelta_average(rmin,rmax) ) / Dexc_average(rmin,rmax)
	 *
	 * @param[in] r_m                      distance [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @param[in] C_norm                   TODO
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return Dexc(r) [Gy]
	'''
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r_m = ctypes.c_double(r_m)
	c_C_norm = ctypes.c_double(C_norm)
	c_function =  libamtrack.AT_RDD_Cucinotta_Dexc_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_max_electron_range_m, c_beta, c_C_norm, c_Katz_point_coeff_Gy)
	return c_output


def AT_RDD_CucinottaPoint_Gy ( r_m, r_min_m, max_electron_range_m, beta, C_norm, Katz_point_coeff_Gy):
	'''
	 * Calculates Cucinotta point RDD
	 *
	 * D(r)    = Dexc(r) + Ddelta(r)
	 *
	 * Ddelta(r) = C z^2 / beta^2 1/rho fS(r) fL(r) /r^2
	 *
	 * Dexc(r) = C exp( - r / 2d ) / r^2
	 *
	 * @param[in] r_m                      distance [m]
	 * @param[in] r_min_m                  minimum cut-off [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @param[in] C_norm                   TODO
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return D(r) [Gy]
	'''
	c_C_norm = ctypes.c_double(C_norm)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_RDD_CucinottaPoint_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_r_min_m, c_max_electron_range_m, c_beta, c_C_norm, c_Katz_point_coeff_Gy)
	return c_output


def AT_inverse_RDD_Cucinotta_solver_function_Gy ( r_m, params):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] params
	 * @return
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_inverse_RDD_Cucinotta_solver_function_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_inverse_RDD_Cucinotta_m ( D_Gy, r_min_m, max_electron_range_m, er_model, beta, C_norm, Katz_point_coeff_Gy):
	'''
	 * TODO
	 * @param[in] D_Gy
	 * @param[in] r_min_m                  minimum cut-off [m]
	 * @param[in] max_electron_range_m     delta electron maximum range rmax [m]
	 * @param[in] er_model
	 * @param[in] beta                     relative ion speed beta = v/c
	 * @param[in] C_norm
	 * @param[in] Katz_point_coeff_Gy      precalculated coefficient [Gy]
	 * @return
	'''
	c_D_Gy = ctypes.c_double(D_Gy)
	c_C_norm = ctypes.c_double(C_norm)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_r_min_m = ctypes.c_double(r_min_m)
	c_function =  libamtrack.AT_inverse_RDD_Cucinotta_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_D_Gy, c_r_min_m, c_max_electron_range_m, c_er_model, c_beta, c_C_norm, c_Katz_point_coeff_Gy)
	return c_output


def AT_KatzModel_KatzExtTarget_inactivation_probability ( r_m, a0_m, KatzPoint_r_min_m, max_electron_range_m, er_model, alpha, Katz_plateau_Gy, Katz_point_coeff_Gy, D0_characteristic_dose_Gy, c_hittedness, m_number_of_targets):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] a0_m
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] er_model
	 * @param[in] alpha
	 * @param[in] Katz_plateau_Gy
	 * @param[in] Katz_point_coeff_Gy
	 * @param[in] D0_characteristic_dose_Gy
	 * @param[in] c_hittedness
	 * @param[in] m_number_of_targets
	 * @return inactivation probability
	'''
	c_c_hittedness = ctypes.c_double(c_hittedness)
	c_Katz_plateau_Gy = ctypes.c_double(Katz_plateau_Gy)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_r_m = ctypes.c_double(r_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	c_function =  libamtrack.AT_KatzModel_KatzExtTarget_inactivation_probability
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_KatzPoint_r_min_m, c_max_electron_range_m, c_er_model, c_alpha, c_Katz_plateau_Gy, c_Katz_point_coeff_Gy, c_D0_characteristic_dose_Gy, c_c_hittedness, c_m_number_of_targets)
	return c_output


def AT_KatzModel_CucinottaExtTarget_inactivation_probability ( r_m, a0_m, KatzPoint_r_min_m, max_electron_range_m, beta, C_norm, Cucinotta_plateau_Gy, KatzPoint_point_coeff_Gy, D0_characteristic_dose_Gy, c_hittedness, m_number_of_targets):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] a0_m
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] beta
	 * @param[in] C_norm
	 * @param[in] Cucinotta_plateau_Gy
	 * @param[in] KatzPoint_point_coeff_Gy
	 * @param[in] D0_characteristic_dose_Gy
	 * @param[in] c_hittedness
	 * @param[in] m_number_of_targets
	 * @return inactivation probability
	'''
	c_c_hittedness = ctypes.c_double(c_hittedness)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_Cucinotta_plateau_Gy = ctypes.c_double(Cucinotta_plateau_Gy)
	c_C_norm = ctypes.c_double(C_norm)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_r_m = ctypes.c_double(r_m)
	c_a0_m = ctypes.c_double(a0_m)
	c_KatzPoint_point_coeff_Gy = ctypes.c_double(KatzPoint_point_coeff_Gy)
	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	c_function =  libamtrack.AT_KatzModel_CucinottaExtTarget_inactivation_probability
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_a0_m, c_KatzPoint_r_min_m, c_max_electron_range_m, c_beta, c_C_norm, c_Cucinotta_plateau_Gy, c_KatzPoint_point_coeff_Gy, c_D0_characteristic_dose_Gy, c_c_hittedness, c_m_number_of_targets)
	return c_output


def AT_KatzModel_inactivation_probability ( n, r_m, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameters, er_model, gamma_parameters, stop_power_source, inactivation_probability):
	'''
	 * TODO
	 * @param[in] n                             todo
	 * @param[in] r_m                           todo (array of size n)
	 * @param[in] E_MeV_u                       todo
	 * @param[in] particle_no                   todo
	 * @param[in] material_no                   todo
	 * @param[in] rdd_model                     todo
	 * @param[in] rdd_parameters                todo (array of size 4)
	 * @param[in] er_model                      todo
	 * @param[in] gamma_parameters              todo (array of size 5)
	 * @param[in] stop_power_source             todo
	 * @param[out] inactivation_probability     results (array of size n)
	 * @return status code
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_stop_power_source = ctypes.c_long(stop_power_source)
	tmp_array = (ctypes.c_double*n)()
	c_inactivation_probability= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_er_model = ctypes.c_long(er_model)
	tmp_array =ctypes.c_double* len(r_m)
	c_r_m = ctypes.byref(tmp_array(*r_m))

	c_particle_no = ctypes.c_long(particle_no)
	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_KatzModel_inactivation_probability
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_r_m, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_parameters, c_stop_power_source, c_inactivation_probability)
	return c_output,  c_inactivation_probability._obj


def AT_KatzModel_KatzExtTarget_inactivation_cross_section_integrand_m ( t_m, params):
	'''
	 * TODO
	 * @param[in] t_m
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_t_m = ctypes.c_double(t_m)
	c_function =  libamtrack.AT_KatzModel_KatzExtTarget_inactivation_cross_section_integrand_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_t_m, c_params)
	return c_output


def AT_KatzModel_KatzExtTarget_inactivation_cross_section_m2 ( a0_m, KatzPoint_r_min_m, max_electron_range_m, er_model, alpha, Katz_plateau_Gy, Katz_point_coeff_Gy, D0_characteristic_dose_Gy, c_hittedness, m_number_of_targets):
	'''
	 * TODO
	 * @param[in] a0_m
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] er_model
	 * @param[in] alpha
	 * @param[in] Katz_plateau_Gy
	 * @param[in] Katz_point_coeff_Gy
	 * @param[in] D0_characteristic_dose_Gy
	 * @param[in] c_hittedness
	 * @param[in] m_number_of_targets
	 * @return TODO
	'''
	c_c_hittedness = ctypes.c_double(c_hittedness)
	c_Katz_plateau_Gy = ctypes.c_double(Katz_plateau_Gy)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_er_model = ctypes.c_long(er_model)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_Katz_point_coeff_Gy = ctypes.c_double(Katz_point_coeff_Gy)
	c_alpha = ctypes.c_double(alpha)
	c_a0_m = ctypes.c_double(a0_m)
	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	c_function =  libamtrack.AT_KatzModel_KatzExtTarget_inactivation_cross_section_m2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_a0_m, c_KatzPoint_r_min_m, c_max_electron_range_m, c_er_model, c_alpha, c_Katz_plateau_Gy, c_Katz_point_coeff_Gy, c_D0_characteristic_dose_Gy, c_c_hittedness, c_m_number_of_targets)
	return c_output


def AT_KatzModel_CucinottaExtTarget_inactivation_cross_section_integrand_m ( t_m, params):
	'''
	 * TODO
	 * @param[in] t_m
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_t_m = ctypes.c_double(t_m)
	c_function =  libamtrack.AT_KatzModel_CucinottaExtTarget_inactivation_cross_section_integrand_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_t_m, c_params)
	return c_output


def AT_KatzModel_CucinottaExtTarget_inactivation_cross_section_m2 ( a0_m, KatzPoint_r_min_m, max_electron_range_m, beta, C_norm, Cucinotta_plateau_Gy, KatzPoint_point_coeff_Gy, D0_characteristic_dose_Gy, c_hittedness, m_number_of_targets):
	'''
	 * TODO
	 * @param[in] a0_m
	 * @param[in] KatzPoint_r_min_m
	 * @param[in] max_electron_range_m
	 * @param[in] beta
	 * @param[in] C_norm
	 * @param[in] Cucinotta_plateau_Gy
	 * @param[in] KatzPoint_point_coeff_Gy
	 * @param[in] D0_characteristic_dose_Gy
	 * @param[in] c_hittedness
	 * @param[in] m_number_of_targets
	 * @return TODO
	'''
	c_c_hittedness = ctypes.c_double(c_hittedness)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	c_KatzPoint_r_min_m = ctypes.c_double(KatzPoint_r_min_m)
	c_Cucinotta_plateau_Gy = ctypes.c_double(Cucinotta_plateau_Gy)
	c_C_norm = ctypes.c_double(C_norm)
	c_max_electron_range_m = ctypes.c_double(max_electron_range_m)
	c_beta = ctypes.c_double(beta)
	c_a0_m = ctypes.c_double(a0_m)
	c_KatzPoint_point_coeff_Gy = ctypes.c_double(KatzPoint_point_coeff_Gy)
	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	c_function =  libamtrack.AT_KatzModel_CucinottaExtTarget_inactivation_cross_section_m2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_a0_m, c_KatzPoint_r_min_m, c_max_electron_range_m, c_beta, c_C_norm, c_Cucinotta_plateau_Gy, c_KatzPoint_point_coeff_Gy, c_D0_characteristic_dose_Gy, c_c_hittedness, c_m_number_of_targets)
	return c_output


def AT_KatzModel_inactivation_cross_section_m2 ( n, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameters, er_model, gamma_parameters, stop_power_source, inactivation_cross_section_m2):
	'''
	 * TODO
	 * @param[in] n
	 * @param[in] E_MeV_u (array of size n)
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @param[in] rdd_model
	 * @param[in] rdd_parameters (array of size 4)
	 * @param[in] er_model
	 * @param[in] gamma_parameters (array of size 5)
	 * @param[in] stop_power_source             todo
	 * @param[out] inactivation_cross_section_m2 (array of size n)
	 * @return status code
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_stop_power_source = ctypes.c_long(stop_power_source)
	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_inactivation_cross_section_m2= ctypes.byref(tmp_array)

	c_er_model = ctypes.c_long(er_model)
	c_particle_no = ctypes.c_long(particle_no)
	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_KatzModel_inactivation_cross_section_m2
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_parameters, c_stop_power_source, c_inactivation_cross_section_m2)
	return c_output,  c_inactivation_cross_section_m2._obj


def AT_KatzModel_KatzExtTarget_ButtsKatz_TrackWidth ( z2kappabeta2, m):
	'''
	 * TODO
	 * @param[in] z2kappabeta2  TODO
	 * @param[in] m             TODO
	 * @return track width
	'''
	c_z2kappabeta2 = ctypes.c_double(z2kappabeta2)
	c_m = ctypes.c_double(m)
	c_function =  libamtrack.AT_KatzModel_KatzExtTarget_ButtsKatz_TrackWidth
	c_function.restype = ctypes.c_double
	c_output = c_function( c_z2kappabeta2, c_m)
	return c_output


def AT_KatzModel_single_field_survival_from_inactivation_cross_section ( fluence_cm2, E_MeV_u, particle_no, material_no, inactivation_cross_section_m2, D0_characteristic_dose_Gy, m_number_of_targets, sigma0_m2, stopping_power_source_no):
	'''
	 * TODO
	 * @param[in] fluence_cm2
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @param[in] inactivation_cross_section_m2
	 * @param[in] D0_characteristic_dose_Gy
	 * @param[in] m_number_of_targets
	 * @param[in] sigma0_m2
	 * @param[in] stopping_power_source_no
	 * @return TODO
	'''
	c_material_no = ctypes.c_long(material_no)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	c_sigma0_m2 = ctypes.c_double(sigma0_m2)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_inactivation_cross_section_m2 = ctypes.c_double(inactivation_cross_section_m2)
	c_particle_no = ctypes.c_long(particle_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_fluence_cm2 = ctypes.c_double(fluence_cm2)
	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	c_function =  libamtrack.AT_KatzModel_single_field_survival_from_inactivation_cross_section
	c_function.restype = ctypes.c_double
	c_output = c_function( c_fluence_cm2, c_E_MeV_u, c_particle_no, c_material_no, c_inactivation_cross_section_m2, c_D0_characteristic_dose_Gy, c_m_number_of_targets, c_sigma0_m2, c_stopping_power_source_no)
	return c_output


def AT_KatzModel_single_field_survival ( fluence_cm2, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameters, er_model, D0_characteristic_dose_Gy, m_number_of_targets, sigma0_m2, use_approximation, kappa, stopping_power_source_no, survival):
	'''
	 * TODO
	 * @param[in] fluence_cm2               TODO
	 * @param[in] E_MeV_u                   TODO
	 * @param[in] particle_no               TODO
	 * @param[in] material_no               TODO
	 * @param[in] rdd_model                 TODO
	 * @param[in] rdd_parameters            TODO (array of size 4)
	 * @param[in] er_model                  TODO
	 * @param[in] D0_characteristic_dose_Gy TODO
	 * @param[in] m_number_of_targets       TODO
	 * @param[in] sigma0_m2                 TODO
	 * @param[in] use_approximation         TODO
	 * @param[in] kappa                     TODO
	 * @param[in] stopping_power_source_no  TODO
	 * @param[out] survival                 TODO
	 * @return status code
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_kappa = ctypes.c_double(kappa)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	c_survival =  ctypes.byref(ctypes.c_double(survival))

	c_sigma0_m2 = ctypes.c_double(sigma0_m2)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_particle_no = ctypes.c_long(particle_no)
	c_use_approximation = ctypes.c_bool(use_approximation)
	c_fluence_cm2 = ctypes.c_double(fluence_cm2)
	c_er_model = ctypes.c_long(er_model)
	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_KatzModel_single_field_survival
	c_function.restype = ctypes.c_int
	c_output = c_function( c_fluence_cm2, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameters, c_er_model, c_D0_characteristic_dose_Gy, c_m_number_of_targets, c_sigma0_m2, c_use_approximation, c_kappa, c_stopping_power_source_no, c_survival)
	return c_output,  c_survival._obj.value


def AT_KatzModel_mixed_field_survival ( number_of_items, fluence_cm2, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameters, er_model, D0_characteristic_dose_Gy, m_number_of_targets, sigma0_m2, use_approximation, kappa, stopping_power_source_no, survival):
	'''
	 * TODO
	 * @param[in] number_of_items           TODO
	 * @param[in] fluence_cm2               TODO (array of size number_of_items)
	 * @param[in] E_MeV_u                   TODO (array of size number_of_items)
	 * @param[in] particle_no               TODO (array of size number_of_items)
	 * @param[in] material_no               TODO
	 * @param[in] rdd_model                 TODO
	 * @param[in] rdd_parameters            TODO (array of size 4)
	 * @param[in] er_model                  TODO
	 * @param[in] D0_characteristic_dose_Gy TODO
	 * @param[in] m_number_of_targets       TODO
	 * @param[in] sigma0_m2                 TODO
	 * @param[in] use_approximation         TODO
	 * @param[in] kappa                     TODO
	 * @param[in] stopping_power_source_no  TODO
	 * @param[out] survival                 TODO
	 * @return status code
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_kappa = ctypes.c_double(kappa)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	c_survival =  ctypes.byref(ctypes.c_double(survival))

	c_sigma0_m2 = ctypes.c_double(sigma0_m2)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_er_model = ctypes.c_long(er_model)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_use_approximation = ctypes.c_bool(use_approximation)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	c_number_of_items = ctypes.c_long(number_of_items)
	c_function =  libamtrack.AT_KatzModel_mixed_field_survival
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_items, c_fluence_cm2, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameters, c_er_model, c_D0_characteristic_dose_Gy, c_m_number_of_targets, c_sigma0_m2, c_use_approximation, c_kappa, c_stopping_power_source_no, c_survival)
	return c_output,  c_survival._obj.value


def AT_KatzModel_single_field_survival_optimized_for_fluence_vector ( number_of_items, fluence_cm2, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameters, er_model, D0_characteristic_dose_Gy, m_number_of_targets, sigma0_m2, use_approximation, kappa, stopping_power_source_no, survival):
	'''
	 * TODO
	 * @param[in] number_of_items
	 * @param[in] fluence_cm2 (array of size number_of_items)
	 * @param[in] E_MeV_u
	 * @param[in] particle_no
	 * @param[in] material_no
	 * @param[in] rdd_model
	 * @param[in] rdd_parameters (array of size 4)
	 * @param[in] er_model
	 * @param[in] D0_characteristic_dose_Gy
	 * @param[in] m_number_of_targets
	 * @param[in] sigma0_m2
	 * @param[in] use_approximation
	 * @param[in] kappa
	 * @param[in] stopping_power_source_no
	 * @param[out] survival (array of size number_of_items)
	 * @return
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_kappa = ctypes.c_double(kappa)
	c_D0_characteristic_dose_Gy = ctypes.c_double(D0_characteristic_dose_Gy)
	tmp_array = (ctypes.c_double*number_of_items)()
	c_survival= ctypes.byref(tmp_array)

	c_sigma0_m2 = ctypes.c_double(sigma0_m2)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_er_model = ctypes.c_long(er_model)
	c_particle_no = ctypes.c_long(particle_no)
	c_use_approximation = ctypes.c_bool(use_approximation)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_m_number_of_targets = ctypes.c_double(m_number_of_targets)
	c_number_of_items = ctypes.c_long(number_of_items)
	c_function =  libamtrack.AT_KatzModel_single_field_survival_optimized_for_fluence_vector
	c_function.restype = ctypes.c_int
	c_output = c_function( c_number_of_items, c_fluence_cm2, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameters, c_er_model, c_D0_characteristic_dose_Gy, c_m_number_of_targets, c_sigma0_m2, c_use_approximation, c_kappa, c_stopping_power_source_no, c_survival)
	return c_output,  c_survival._obj


def AT_P_RDD ( r_m, params):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_P_RDD
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_sI_int ( r_m, params):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_sI_int
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_D_RDD_Gy_int ( r_m, params):
	'''
	 * TODO
	 * @param[in] r_m
	 * @param[in] params
	 * @return TODO
	'''
	c_params = (params)
	c_r_m = ctypes.c_double(r_m)
	c_function =  libamtrack.AT_D_RDD_Gy_int
	c_function.restype = ctypes.c_double
	c_output = c_function( c_r_m, c_params)
	return c_output


def AT_run_IGK_method ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, stopping_power_source_no, rdd_model, rdd_parameters, er_model, gamma_model, gamma_parameters, saturation_cross_section_factor, write_output, relative_efficiency, S_HCP, S_gamma, sI_cm2, gamma_dose_Gy, P_I, P_g):
	'''
	 * Computes HCP response and relative efficiency/RBE using Katz\' Ion-Gamma-Kill approach
	 * according to Waligorski, 1988
	 *
	 * @param[in]      number_of_field_components       number of components in the mixed particle field
	 * @param[in]      E_MeV_u                          particle energy for each component in the mixed particle field [MeV/u] (array of size number_of_field_components)
	 * @param[in]      particle_no                      particle type for each component in the mixed particle field (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]      fluence_cm2_or_dose_Gy           if positive, particle fluence for each component in the mixed particle field [1/cm2]; if negative, particle dose for each component in the mixed particle field [Gy] (array of size number_of_field_components)
	 * @param[in]      material_no                      index number for detector material
	 * @param[in]      stopping_power_source_no         stopping power source number (PSTAR,...)
	 * @see AT_DataMaterial.h for definition
	 * @param[in]      rdd_model                        index number for chosen radial dose distribution
	 * @param[in]      rdd_parameters                   parameters for chosen radial dose distribution (array of size 4)
	 * @see AT_RDD.h for definition
	 * @param[in]      er_model                         index number for chosen electron-range model
	 * @see AT_ElectronRange.h for definition
	 * @param[in]      gamma_model                      index number for chosen gamma response
	 * @param[in]      gamma_parameters                 parameters for chosen gamma response (array of size 9)
	 * @see AT_GammaResponse.h for definition
	 * @param[in]      saturation_cross_section_factor  scaling factor for the saturation cross section
	 * @see Waligorski, 1988
	 * @param[in]      write_output                     if true, a protocol is written to a file in the working directory
	 * @param[out]     relative_efficiency              particle response at dose D / gamma response at dose D
	 * @param[out]     S_HCP                            absolute particle response
	 * @param[out]     S_gamma                          absolute gamma response
	 * @param[out]     sI_cm2                           resulting ion saturation cross section in cm2
	 * @param[out]     gamma_dose_Gy                    dose contribution from gamma kills
	 * @param[out]     P_I                              ion kill probability
	 * @param[out]     P_g                              gamma kill probability
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_sI_cm2 =  ctypes.byref(ctypes.c_double(sI_cm2))

	c_P_g =  ctypes.byref(ctypes.c_double(P_g))

	c_relative_efficiency =  ctypes.byref(ctypes.c_double(relative_efficiency))

	c_S_HCP =  ctypes.byref(ctypes.c_double(S_HCP))

	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	c_saturation_cross_section_factor = ctypes.c_double(saturation_cross_section_factor)
	c_write_output = ctypes.c_bool(write_output)
	c_P_I =  ctypes.byref(ctypes.c_double(P_I))

	c_S_gamma =  ctypes.byref(ctypes.c_double(S_gamma))

	c_gamma_model = ctypes.c_long(gamma_model)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_er_model = ctypes.c_long(er_model)
	c_gamma_dose_Gy =  ctypes.byref(ctypes.c_double(gamma_dose_Gy))

	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_run_IGK_method
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_stopping_power_source_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_model, c_gamma_parameters, c_saturation_cross_section_factor, c_write_output, c_relative_efficiency, c_S_HCP, c_S_gamma, c_sI_cm2, c_gamma_dose_Gy, c_P_I, c_P_g)
	return c_output,  c_relative_efficiency._obj.value, c_S_HCP._obj.value, c_S_gamma._obj.value, c_sI_cm2._obj.value, c_gamma_dose_Gy._obj.value, c_P_I._obj.value, c_P_g._obj.value


def AT_material_index_from_material_number ( material_number):
	'''
	 * Get index of material in AT_Material_Data for given material_no
	 * (currently for example material with number 2 has index 1)
	 *
	 * @param[in] material_number  material number
	 * @return                 material index in AT_Material_Data table
	'''
	c_material_number = ctypes.c_long(material_number)
	c_function =  libamtrack.AT_material_index_from_material_number
	c_function.restype = ctypes.c_long
	c_output = c_function( c_material_number)
	return c_output


def AT_material_name_from_number ( material_no, material_name):
	'''
	 * Get material name
	 * @param[in]  material_no
	 * @param[out] material_name
	'''
	c_material_no = ctypes.c_long(material_no)
	c_material_name =  ctypes.byref(ctypes.c_char(material_name))

	c_function =  libamtrack.AT_material_name_from_number
	c_output = c_function( c_material_no, c_material_name)
	return c_output,  c_material_name._obj.value


def AT_material_number_from_name ( material_name):
	'''
	 * Get material number
	 * @param[in] material_name
	 * @return    material number
	'''
	c_material_name = ctypes.c_char(material_name)
	c_function =  libamtrack.AT_material_number_from_name
	c_function.restype = ctypes.c_long
	c_output = c_function( c_material_name)
	return c_output


def AT_density_g_cm3_from_material_no ( material_no):
	'''
	 * Get material density [g/cm3] for single material with number material_no
	 * @param[in] material_no
	 * @return    material density [g/cm3]
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_density_g_cm3_from_material_no
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_I_eV_from_material_no ( material_no):
	'''
	 * Get mean ionization potential in eV for single material with number material_no
	 * @param[in] material_no
	 * @return    mean ionization potential [eV]
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_I_eV_from_material_no
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_alpha_g_cm2_MeV_from_material_no ( material_no):
	'''
	 * Get fit parameter for power-law representation of stp.power/range/E-dependence for single material with number material_no
	 * @param[in] material_no
	 * @return    fit parameter for power-law representation of stp.power/range/E-dependence
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_alpha_g_cm2_MeV_from_material_no
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_p_MeV_from_material_no ( material_no):
	'''
	 * Get fit parameter for power-law representation of stp.power/range/E-dependence for single material with number material_no
	 * @param[in] material_no
	 * @return    fit parameter for power-law representation of stp.power/range/E-dependence
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_p_MeV_from_material_no
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_m_g_cm2_from_material_no ( material_no):
	'''
	 * Get fit parameter for the linear representation of fluence changes due to nuclear interactions based on data from Janni for single material with number material_no
	 * @param[in] material_no
	 * @return    fit parameter for the linear representation of fluence changes due to nuclear interactions based on data from Janni
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_m_g_cm2_from_material_no
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_average_A_from_material_no ( material_no):
	'''
	 * Get average mass number for single material with number material_no
	 * @param[in] material_no
	 * @return    average mass number
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_average_A_from_material_no
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_average_Z_from_material_no ( material_no):
	'''
	 * Get average atomic number for single material with number material_no
	 * @param[in] material_no
	 * @return    average atomic number
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_average_Z_from_material_no
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_phase_from_material_no ( material_no):
	'''
	 * Get material phase
	 * @param[in] material_no
	 * @return    material phase index (enumerator)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_phase_from_material_no
	c_function.restype = ctypes.c_long
	c_output = c_function( c_material_no)
	return c_output


def AT_get_material_data ( material_no, density_g_cm3, I_eV, alpha_g_cm2_MeV, p_MeV, m_g_cm2, average_A, average_Z):
	'''
	 * Returns material data for single material
	 * @param[in]  material_no           index number of material
	 * @param[out] density_g_cm3         physical density [g/cm3]
	 *   electron_density = number_of_electron_per_molecule * avogadro_constant / molar_mass * 1m3 * density
	 * @param[out] I_eV                  mean ionization potential [eV]
	 * @param[out] alpha_g_cm2_MeV       fit parameter for power-law representation of stopping-power (Bortfeld, 1997)
	 *   @see  Bortfeld, T. (1997), An analytical approximation of the Bragg curve for therapeutic proton beams, Med. Phys. 24, 2024ff.
	 *   Here, however, we use the mass stopping power. The correct dimension is g/(cm^2 * MeV^p)
	 * @param[out] p_MeV                 fit parameter for power-law representation of stopping-power (Bortfeld, 1997)
	 *   @see  Bortfeld, T. (1997), An analytical approximation of the Bragg curve for therapeutic proton beams, Med. Phys. 24, 2024ff.\n
	 *   p is actually dimensionless, it should be nevertheless indicated, that the energy must be given in MeV
	 * @param[out] m_g_cm2               fit parameter for the linear representation of fluence changes due to nuclear interactions based on data from Janni 1982  (Bortfeld, 1997)
	 *   @see  Bortfeld, T. (1997), An analytical approximation of the Bragg curve for therapeutic proton beams, Med. Phys. 24, 2024ff.
	 * @param[out] average_A             average mass number
	 *   let f_i be fraction by weight of the constituent element with atomic number Z_i and atomic weight A_i\n
	 *   let us define average_Z/A = sum_i f_i Z_i / A_i \n
	 *   then we have: average_A = average_Z / (average_Z/A) \n
	 *   for water (H20) we have: average_Z/A = (2/18) * (1/1) + (16/18)*(8/16) = 0.5555 \n
	 *   average_A = 7.22 / 0.555 = 13
	 * @param[out] average_Z             average atomic number
	 *   let f_i be fraction by weight of the constituent element with atomic number Z_i and atomic weight A_i\n
	 *   average_Z = sum_i f_i Z_i \n
	 *   for water (H20) we have: average_Z = (2/18)*1 + (16/18)*8 = 7.22\n
	 *   @see Tabata, T. (1972) Generalized semiempirical equations for the extrapolated range of electrons, Nucl. Instr and Meth. 103, 85-91.
	'''
	c_material_no = ctypes.c_long(material_no)
	c_average_A =  ctypes.byref(ctypes.c_double(average_A))

	c_m_g_cm2 =  ctypes.byref(ctypes.c_double(m_g_cm2))

	c_density_g_cm3 =  ctypes.byref(ctypes.c_double(density_g_cm3))

	c_alpha_g_cm2_MeV =  ctypes.byref(ctypes.c_double(alpha_g_cm2_MeV))

	c_I_eV =  ctypes.byref(ctypes.c_double(I_eV))

	c_average_Z =  ctypes.byref(ctypes.c_double(average_Z))

	c_p_MeV =  ctypes.byref(ctypes.c_double(p_MeV))

	c_function =  libamtrack.AT_get_material_data
	c_output = c_function( c_material_no, c_density_g_cm3, c_I_eV, c_alpha_g_cm2_MeV, c_p_MeV, c_m_g_cm2, c_average_A, c_average_Z)
	return c_output,  c_density_g_cm3._obj.value, c_I_eV._obj.value, c_alpha_g_cm2_MeV._obj.value, c_p_MeV._obj.value, c_m_g_cm2._obj.value, c_average_A._obj.value, c_average_Z._obj.value


def AT_get_materials_data ( number_of_materials, material_no, density_g_cm3, I_eV, alpha_g_cm2_MeV, p_MeV, m_g_cm2, average_A, average_Z):
	'''
	 * Returns material data for list of materials
	 * @param[in]   number_of_materials  numbers of materials the routine is called for
	 * @param[in]   material_no          material indices (array of size number_of_materials)
	 * @param[out]  density_g_cm3        material density in g/cm3 (array of size number_of_materials)
	 * @param[out]  I_eV                 mean ionization potential in eV (array of size number_of_materials)
	 * @param[out]  alpha_g_cm2_MeV      fit parameter for power-law representation of stp.power/range/E-dependence (array of size number_of_materials)
	 * @param[out]  p_MeV                fit parameter for power-law representation of stp.power/range/E-dependence (array of size number_of_materials)
	 * @param[out]  m_g_cm2              fit parameter for the linear representation of fluence changes due to nuclear interactions based on data from Janni 1982 (array of size number_of_materials)
	 * @param[out]  average_A            average mass number (array of size number_of_materials)
	 * @param[out]  average_Z            average atomic number (array of size number_of_materials)
	'''
	tmp_array =ctypes.c_long* len(material_no)
	c_material_no = ctypes.byref(tmp_array(*material_no))

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_average_A= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_alpha_g_cm2_MeV= ctypes.byref(tmp_array)

	c_number_of_materials = ctypes.c_long(number_of_materials)
	tmp_array = (ctypes.c_double*number_of_materials)()
	c_density_g_cm3= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_m_g_cm2= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_I_eV= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_average_Z= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_p_MeV= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_get_materials_data
	c_output = c_function( c_number_of_materials, c_material_no, c_density_g_cm3, c_I_eV, c_alpha_g_cm2_MeV, c_p_MeV, c_m_g_cm2, c_average_A, c_average_Z)
	return c_output,  c_density_g_cm3._obj, c_I_eV._obj, c_alpha_g_cm2_MeV._obj, c_p_MeV._obj, c_m_g_cm2._obj, c_average_A._obj, c_average_Z._obj


def AT_electron_density_m3_from_material_no_single ( material_no):
	'''
	 * Get electron density [1/m3] for single material with number material_no
	 * @param[in] material_no
	 * @return    electron density [1/m3]
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_electron_density_m3_from_material_no_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_material_no)
	return c_output


def AT_electron_density_m3_from_material_no_multi ( n, material_no, electron_density_m3):
	'''
	 * Get electron density [1/m3] for materials
	 * @param[in]     n                    number of materials
	 * @param[in]     material_no          material indices (array of size n)
	 * @param[out]    electron_density_m3  electron densities per m3 (array of size n)
	'''
	tmp_array =ctypes.c_long* len(material_no)
	c_material_no = ctypes.byref(tmp_array(*material_no))

	tmp_array = (ctypes.c_double*n)()
	c_electron_density_m3= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_electron_density_m3_from_material_no_multi
	c_output = c_function( c_n, c_material_no, c_electron_density_m3)
	return c_output,  c_electron_density_m3._obj


def AT_plasma_energy_J_from_material_no ( material_no):
	'''
	 * Returns material\'s plasma energy needed for Sternheimer
	 * computation of density effect in stopping power
	 * @param[in]  material_no  material number
	'''
	c_material_no = ctypes.c_long(material_no)
	c_function =  libamtrack.AT_plasma_energy_J_from_material_no
	c_output = c_function( c_material_no)
	return c_output


def AT_electron_density_m3_single ( density_g_cm3, average_Z, average_A):
	'''
	 * Computes the electron density from average A and Z
	 * @param[in] density_g_cm3      physical density (in g/cm3) of material
	 * @param[in] average_Z          average atomic number of material
	 * @param[in] average_A          mass number of material
	 * @return                       electron density in 1/m3
	'''
	c_average_A = ctypes.c_double(average_A)
	c_density_g_cm3 = ctypes.c_double(density_g_cm3)
	c_average_Z = ctypes.c_double(average_Z)
	c_function =  libamtrack.AT_electron_density_m3_single
	c_function.restype = ctypes.c_double
	c_output = c_function( c_density_g_cm3, c_average_Z, c_average_A)
	return c_output


def AT_electron_density_m3_multi ( n, density_g_cm3, average_A, average_Z, electron_density_m3):
	'''
	 * Returns electron density from average A and Z
	 * @param[in]   n                    size of arrays
	 * @param[in]   density_g_cm3        material density in g/cm3 (array of size n)
	 * @param[in]   average_A            average mass number (array of size n)
	 * @param[in]   average_Z            average atomic number (array of size n)
	 * @param[out]  electron_density_m3  electron density in 1/m3 (array of size n)
	'''
	tmp_array =ctypes.c_double* len(average_A)
	c_average_A = ctypes.byref(tmp_array(*average_A))

	tmp_array =ctypes.c_double* len(density_g_cm3)
	c_density_g_cm3 = ctypes.byref(tmp_array(*density_g_cm3))

	tmp_array = (ctypes.c_double*n)()
	c_electron_density_m3= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(average_Z)
	c_average_Z = ctypes.byref(tmp_array(*average_Z))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_electron_density_m3_multi
	c_output = c_function( c_n, c_density_g_cm3, c_average_A, c_average_Z, c_electron_density_m3)
	return c_output,  c_electron_density_m3._obj


def AT_plasma_energy_J_single ( electron_density_m3):
	'''
	 * Returns plasma energy needed for Sternheimer
	 * computation of density effect in stopping power
	 * @param[in]  electron_density_m3  electron density in 1/m3
	'''
	c_electron_density_m3 = ctypes.c_double(electron_density_m3)
	c_function =  libamtrack.AT_plasma_energy_J_single
	c_output = c_function( c_electron_density_m3)
	return c_output


def AT_electron_density_m3_from_composition ( n, density_g_cm3, Z, A, weight_fraction, electron_density_m3):
	'''
	 * Computes the electron density for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  density_g_cm3         physical density (in g per cm3) of material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] electron_density_m3   electron density per m3
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_density_g_cm3 = ctypes.c_double(density_g_cm3)
	c_n = ctypes.c_long(n)
	c_electron_density_m3 =  ctypes.byref(ctypes.c_double(electron_density_m3))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_function =  libamtrack.AT_electron_density_m3_from_composition
	c_output = c_function( c_n, c_density_g_cm3, c_Z, c_A, c_weight_fraction, c_electron_density_m3)
	return c_output,  c_electron_density_m3._obj.value


def AT_average_A_from_composition ( n, A, weight_fraction, average_A):
	'''
	 * Computes the average mass number for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] average_A             average A
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_average_A =  ctypes.byref(ctypes.c_double(average_A))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_average_A_from_composition
	c_output = c_function( c_n, c_A, c_weight_fraction, c_average_A)
	return c_output,  c_average_A._obj.value


def AT_average_Z_from_composition ( n, Z, weight_fraction, average_Z):
	'''
	 * Computes the average atomic number for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] average_Z             average Z
	'''
	c_average_Z =  ctypes.byref(ctypes.c_double(average_Z))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_average_Z_from_composition
	c_output = c_function( c_n, c_Z, c_weight_fraction, c_average_Z)
	return c_output,  c_average_Z._obj.value


def AT_effective_Z_from_composition ( n, Z, weight_fraction, electron_densities_cm3, exponent, effective_Z):
	'''
	 * Computes the effective atomic number for a given material composition
	 *
	 * @param[in]  n                     	number of constituents in material
	 * @param[in]  Z                     	atomic numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       	relative fractions of weight of constituents (array of size n)
	 * @param[in]  electron_densities_cm3   if not zero, weight fractions will additionally include electron densities per volume (array of size n)
	 * @param[in]  exponent              	exponent for additivity rule reflecting the photon energy regime (usually 3.5 at ~ 100 kV)
	 * @param[out] effective_Z           	effective Z
	'''
	c_exponent = ctypes.c_double(exponent)
	tmp_array =ctypes.c_double* len(electron_densities_cm3)
	c_electron_densities_cm3 = ctypes.byref(tmp_array(*electron_densities_cm3))

	c_effective_Z =  ctypes.byref(ctypes.c_double(effective_Z))

	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_function =  libamtrack.AT_effective_Z_from_composition
	c_output = c_function( c_n, c_Z, c_weight_fraction, c_electron_densities_cm3, c_exponent, c_effective_Z)
	return c_output,  c_effective_Z._obj.value


def AT_I_eV_from_composition ( n, Z, A, weight_fraction, I_eV):
	'''
	 * Computes the I value for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] I_eV                  I value in eV
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_I_eV =  ctypes.byref(ctypes.c_double(I_eV))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_I_eV_from_composition
	c_output = c_function( c_n, c_Z, c_A, c_weight_fraction, c_I_eV)
	return c_output,  c_I_eV._obj.value


def AT_set_user_material ( density_g_cm3, I_eV, average_A, average_Z, status):
	'''
	 * Initializes user defined material. The material can then be used with material index number 0. !Be aware! that is
	 * definition is only valid during run-time. When the library is reloaded, the default settings are restored and the
	 * material is removed.
	 * @param[in] density_g_cm3  physical density in g per cm3
	 * @param[in] I_eV           I value in eV
	 * @param[in] average_A      average mass number
	 * @param[in] average_Z      average atomic number
	 * @param[out] status        material defined successfully if zero
	'''
	c_average_A = ctypes.c_double(average_A)
	c_density_g_cm3 = ctypes.c_double(density_g_cm3)
	c_average_Z = ctypes.c_double(average_Z)
	c_status =  ctypes.byref(ctypes.c_long(status))

	c_I_eV = ctypes.c_double(I_eV)
	c_function =  libamtrack.AT_set_user_material
	c_output = c_function( c_density_g_cm3, c_I_eV, c_average_A, c_average_Z, c_status)
	return c_output,  c_status._obj.value


def AT_set_user_material_from_composition ( n, density_g_cm3, Z, A, weight_fraction, status):
	'''
	 * Initializes user defined material from composition data. The material can then be used with material index number 0. !Be aware! that is
	 * definition is only valid during run-time. When the library is reloaded, the default settings are restored and the
	 * material is removed.
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  density_g_cm3         physical density (in g per cm3) of material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] status                material defined successfully if zero
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_status =  ctypes.byref(ctypes.c_long(status))

	c_density_g_cm3 = ctypes.c_double(density_g_cm3)
	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_function =  libamtrack.AT_set_user_material_from_composition
	c_output = c_function( c_n, c_density_g_cm3, c_Z, c_A, c_weight_fraction, c_status)
	return c_output,  c_status._obj.value


def getERName ( ER_no, ER_name):
	'''
	 * Returns name of the electron model from index
	 *
	 * @param[in]   ER_no    electron-range-model index
	 * @param[out]  ER_name  string containing the electron-range model name
	 * @return      Status code
	'''
	c_ER_no = ctypes.c_int(ER_no)
	c_ER_name =  ctypes.byref(ctypes.c_char(ER_name))

	c_function =  libamtrack.getERName
	c_function.restype = ctypes.c_int
	c_output = c_function( c_ER_no, c_ER_name)
	return c_output,  c_ER_name._obj.value


def AT_ER_ButtsKatz_range_g_cm2 ( wmax_keV):
	'''
	 * 1e-5 * wmax_keV
	 * @param[in] wmax_keV
	 * @return
	'''
	c_wmax_keV = ctypes.c_double(wmax_keV)
	c_function =  libamtrack.AT_ER_ButtsKatz_range_g_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_wmax_keV)
	return c_output


def AT_ER_Waligorski_range_g_cm2 ( wmax_keV):
	'''
	 * 6e-6 * pow( wmax_keV, alpha )
	 * @param[in] wmax_keV
	 * @return
	'''
	c_wmax_keV = ctypes.c_double(wmax_keV)
	c_function =  libamtrack.AT_ER_Waligorski_range_g_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_wmax_keV)
	return c_output


def AT_ER_Edmund_range_g_cm2 ( wmax_keV):
	'''
	 * 6.13*1e-6  * pow( wmax_keV, alpha )
	 * @param[in] wmax_keV
	 * @return
	'''
	c_wmax_keV = ctypes.c_double(wmax_keV)
	c_function =  libamtrack.AT_ER_Edmund_range_g_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_wmax_keV)
	return c_output


def AT_ER_Geiss_range_g_cm2 ( E_MeV_u):
	'''
	 * 4e-5 * pow(E_MeV_u, 1.5)
	 * @param[in] E_MeV_u
	 * @return
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_ER_Geiss_range_g_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_ER_Scholz_range_g_cm2 ( E_MeV_u):
	'''
	 * 5e-5 * pow(E_MeV_u, 1.7)
	 * @param[in] E_MeV_u
	 * @return
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_ER_Scholz_range_g_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_ER_Tabata_range_g_cm2 ( beta, a1_g_cm2, a2, a3, a4, a5):
	'''
	 *  tau = 2.0 * gsl_pow_2(beta) / (1.0 - gsl_pow_2(beta))
	 * (a1_g_cm2)*(((gsl_sf_log(1.0 + a2 * tau))/a2) - ((a3*tau)/(1.0 + a4*pow(tau,a5))) )
	 *
	 * @param[in] beta
	 * @param[in] a1_g_cm2
	 * @param[in] a2
	 * @param[in] a3
	 * @param[in] a4
	 * @param[in] a5
	 * @return range
	'''
	c_a3 = ctypes.c_double(a3)
	c_beta = ctypes.c_double(beta)
	c_a2 = ctypes.c_double(a2)
	c_a5 = ctypes.c_double(a5)
	c_a4 = ctypes.c_double(a4)
	c_a1_g_cm2 = ctypes.c_double(a1_g_cm2)
	c_function =  libamtrack.AT_ER_Tabata_range_g_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_beta, c_a1_g_cm2, c_a2, c_a3, c_a4, c_a5)
	return c_output


def AT_ER_PowerLaw_alpha ( E_MeV_u):
	'''
	 * Alpha exponent in power law ER models. It is defined as follows:
	 * alpha = 1.667   when energy of ejected delta electron wmax is higher than 1keV
	 * alpha = 1.079   when energy of ejected delta electron wmax is less or equal than 1keV
	 *
	 * @param[in] E_MeV_u  kinetic energy for particle [in MeV/u]
	 * @return
	'''
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_ER_PowerLaw_alpha
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u)
	return c_output


def AT_ER_Tabata_constants ( average_A, average_Z, a1_g_cm2, a2, a3, a4, a5):
	'''
	 * Tabata model constants
	 * @param[in] average_A
	 * @param[in] average_Z
	 * @param[out] a1_g_cm2
	 * @param[out] a2
	 * @param[out] a3
	 * @param[out] a4
	 * @param[out] a5
	'''
	c_average_A = ctypes.c_double(average_A)
	c_a1_g_cm2 =  ctypes.byref(ctypes.c_double(a1_g_cm2))

	c_a3 =  ctypes.byref(ctypes.c_double(a3))

	c_a2 =  ctypes.byref(ctypes.c_double(a2))

	c_a5 =  ctypes.byref(ctypes.c_double(a5))

	c_a4 =  ctypes.byref(ctypes.c_double(a4))

	c_average_Z = ctypes.c_double(average_Z)
	c_function =  libamtrack.AT_ER_Tabata_constants
	c_output = c_function( c_average_A, c_average_Z, c_a1_g_cm2, c_a2, c_a3, c_a4, c_a5)
	return c_output,  c_a1_g_cm2._obj.value, c_a2._obj.value, c_a3._obj.value, c_a4._obj.value, c_a5._obj.value


def AT_max_electron_ranges_m ( number_of_particles, E_MeV_u, material_no, er_model, max_electron_range_m):
	'''
	 * Returns the maximum electron range (track radius) in m
	 * for a given parametrization
	 *
	 * @param[in]  number_of_particles          number of particles in the incident field
	 * @param[in]  E_MeV_u                      kinetic energy for particles in the given field (array of size number_of_particles)
	 * @param[in]  material_no                  material index
	 * @param[in]  er_model                     electron-range model index
	 * @param[out] max_electron_range_m         electron range (track radius) in m  (array of size number_of_particles)
	'''
	c_material_no = ctypes.c_int(material_no)
	tmp_array = (ctypes.c_double*number_of_particles)()
	c_max_electron_range_m= ctypes.byref(tmp_array)

	c_er_model = ctypes.c_int(er_model)
	c_number_of_particles = ctypes.c_long(number_of_particles)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_max_electron_ranges_m
	c_output = c_function( c_number_of_particles, c_E_MeV_u, c_material_no, c_er_model, c_max_electron_range_m)
	return c_output,  c_max_electron_range_m._obj


def AT_max_electron_range_m ( E_MeV_u, material_no, er_model):
	'''
	 * Returns the maximum electron range (track diameter) in m for given energy
	 *
	 * @param[in]  E_MeV_u                      kinetic energy for particles in the given field
	 * @param[in]  material_no                  index for detector material
	 * @param[in]  er_model                     index for electron-range model chosen
	 * @return                                  electron range (track diameter) in m
	'''
	c_material_no = ctypes.c_int(material_no)
	c_er_model = ctypes.c_int(er_model)
	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_function =  libamtrack.AT_max_electron_range_m
	c_function.restype = ctypes.c_double
	c_output = c_function( c_E_MeV_u, c_material_no, c_er_model)
	return c_output

